{"pages":[{"title":"关于我","text":"QQ435956653 微信Justin_disco","link":"/about/index.html"}],"posts":[{"title":"AJAX-Day01","text":"第04阶段.前后端交互.AJAX基础 目标 Ajax 基础 Ajax 运行原理及实现 Ajax 异步编程 Ajax 基础传统网站中存在的问题 网速慢的情况下，页面加载时间长，用户只能等待 表单提交后，如果一项内容不合格，需要重新填写所有表单内容 页面跳转，重新加载页面，造成资源浪费，增加用户等待时间 概述Ajax：标准读音 [ˈeɪˌdʒæks] ，中文音译：阿贾克斯 它是浏览器提供的一套方法，可以实现页面无刷新更新数据，提高用户浏览网站应用的体验。 应用场景 运行环境Ajax 技术需要运行在网站环境中才能生效，当前课程会使用Node创建的服务器作为网站服务器。 Ajax 运行原理及实现运行原理Ajax 相当于浏览器发送请求与接收响应的代理人，以实现在不影响用户浏览页面的情况下，局部更新页面数据，从而提高用户体验。 实现步骤 创建 Ajax 对象 1var xhr = new XMLHttpRequest(); 告诉 Ajax 请求地址以及请求方式 1xhr.open(&apos;get&apos;, &apos;http://www.example.com&apos;); 发送请求 1xhr.send(); 获取服务器端给与客户端的响应数据 123xhr.onload = function () { console.log(xhr.responseText);} 服务器端响应的数据格式在真实的项目中，服务器端大多数情况下会以 JSON 对象作为响应数据的格式。当客户端拿到响应数据时，要将 JSON 数据和 HTML 字符串进行拼接，然后将拼接的结果展示在页面中。 在 http 请求与响应的过程中，无论是请求参数还是响应内容，如果是对象类型，最终都会被转换为对象字符串进行传输。 1JSON.parse() // 将 json 字符串转换为json对象 请求参数传递123456&lt;!– 传统网站表单提交 --&gt;&lt;form method=&quot;get&quot; action=&quot;http://www.example.com&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;/form&gt;&lt;!– http://www.example.com?username=zhangsan&amp;password=123456 --&gt; 12// GET 请求方式xhr.open(&apos;get&apos;, &apos;http://www.example.com?name=zhangsan&amp;age=20&apos;); 12// POST 请求方式xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;) xhr.send(&apos;name=zhangsan&amp;age=20&apos;); 请求报文在 HTTP 请求和响应的过程中传递的数据块就叫报文，包括要传送的数据和一些附加信息，这些数据和信息要遵守规定好的格式。 请求参数的格式 application/x-www-form-urlencoded 1name=zhangsan&amp;age=20&amp;sex=男 application/json 1{name: &apos;zhangsan&apos;, age: &apos;20&apos;, sex: &apos;男&apos;} 在请求头中指定 Content-Type 属性的值是 application/json，告诉服务器端当前请求参数的格式是 json。 1JSON.stringify() // 将json对象转换为json字符串 注意：get 请求是不能提交 json 对象数据格式的，传统网站的表单提交也是不支持 json 对象数据格式的。 Ajax 状态码在创建ajax对象，配置ajax对象，发送请求，以及接收完服务器端响应数据，这个过程中的每一个步骤都会对应一个数值，这个数值就是ajax状态码。 0：请求未初始化(还没有调用open())1：请求已经建立，但是还没有发送(还没有调用send())2：请求已经发送3：请求正在处理中，通常响应中已经有部分数据可以用了4：响应已经完成，可以获取并使用服务器的响应了 1xhr.readyState // 获取Ajax状态码 onreadystatechange 事件当 Ajax 状态码发生变化时将自动触发该事件。 在事件处理函数中可以获取 Ajax 状态码并对其进行判断，当状态码为 4 时就可以通过 xhr.responseText 获取服务器端的响应数据了。 12345678// 当Ajax状态码发生变化时xhr.onreadystatechange = function () { // 判断当Ajax状态码为4时 if (xhr.readyState == 4) { // 获取服务器端的响应数据 console.log(xhr.responseText); }} 两种获取服务器端响应方式的区别 区别描述 onload事件 onreadystatechange事件 是否兼容IE低版本 不兼容 兼容 是否需要判断Ajax状态码 不需要 需要 被调用次数 一次 多次 Ajax 错误处理1. 网络畅通，服务器端能接收到请求，服务器端返回的结果不是预期结果。 可以判断服务器端返回的状态码，分别进行处理。xhr.status 获取http状态码 2. 网络畅通，服务器端没有接收到请求，返回404状态码。 检查请求地址是否错误。 3. 网络畅通，服务器端能接收到请求，服务器端返回500状态码。 服务器端错误，找后端程序员进行沟通。 4. 网络中断，请求无法发送到服务器端。 会触发xhr对象下面的onerror事件，在onerror事件处理函数中对错误进行处理。 低版本 IE 浏览器的缓存问题问题：在低版本的 IE 浏览器中，Ajax 请求有严重的缓存问题，即在请求地址不发生变化的情况下，只有第一次请求会真正发送到服务器端，后续的请求都会从浏览器的缓存中获取结果。即使服务器端的数据更新了，客户端依然拿到的是缓存中的旧数据。 解决方案：在请求地址的后面加请求参数，保证每一次请求中的请求参数的值不相同。 1xhr.open(&apos;get&apos;, &apos;http://www.example.com?t=&apos; + Math.random()); Ajax 异步编程同步 一个人同一时间只能做一件事情，只有一件事情做完，才能做另外一件事情。 落实到代码中，就是上一行代码执行完成后，才能执行下一行代码，即代码逐行执行。 12console.log(&apos;before&apos;); console.log(&apos;after&apos;); 异步 一个人一件事情做了一半，转而去做其他事情，当其他事情做完以后，再回过头来继续做之前未完成的事情。 落实到代码上，就是异步代码虽然需要花费时间去执行，但程序不会等待异步代码执行完成后再继续执行后续代码，而是直接执行后续代码，当后续代码执行完成后再回头看异步代码是否返回结果，如果已有返回结果，再调用事先准备好的回调函数处理异步代码执行的结果。 12345console.log(&apos;before&apos;);setTimeout( () =&gt; { console.log(&apos;last&apos;);}, 2000);console.log(&apos;after&apos;); Ajax 封装问题：发送一次请求代码过多，发送多次请求代码冗余且重复。 解决方案：将请求代码封装到函数中，发请求时调用函数即可。 1234567ajax({ type: &apos;get&apos;, url: &apos;http://www.itfool.cn&apos;, success: function (data) { console.log(data); }})","link":"/前端笔记/ajax-day01/"},{"title":"CSS-day05","text":"第01阶段.前端基础.页面制作 实战|demo目标 理解 能够说写单页面我们基本的流程 能说出常见的css初始化语句 能说出我们CSS属性书写顺序 应用 能利用ps切图 能引入外部样式表 能把psd文件转换为html页面 学成在线的目的就是为了串联前面的所有知识。来一个春晚大联欢。 pink老师： 取义学有所成，为师之期望，君等成才者也，故曰学成网是也~~ 前期准备素材 学成在线PSD源文件 https://itfool.cn/前端笔记/css-day05/学成网首页.psd 开发工具 = PS（切图） + sublime（代码） + chrome（测试） 前期准备工作欲先善其事，必先利其器。 先把我们的前期准备工作做好， 我们本次采取结构与样式相分离思想。 创建 study 目录文件夹 (用于存放我们这个页面的相关内容) study目录内新建images 文件夹 用于保存图片。 新建index.html 首页html 文件（以后我们的网站首页统一规定为index.html) 新建style.css 样式文件。 我们本次采用外链样式表。 将样式引入到我们HTML页面文件中。 样式表写入 清除内外边距样式，来检测样式表是否引入成功。 CSS属性书写顺序(重点)建议遵循以下顺序： 布局定位属性：display / position / float / clear / visibility / overflow（建议 display 第一个写，毕竟关系到模式） 自身属性：width / height / margin / padding / border / background 文本属性：color / font / text-decoration / text-align / vertical-align / white- space / break-word 其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient … 1234567891011121314151617.jdc { display: block; position: relative; float: left; width: 100px; height: 100px; margin: 0 10px; padding: 20px 0; font-family: Arial, 'Helvetica Neue', Helvetica, sans-serif; color: #333; background: rgba(0,0,0,.5); -webkit-border-radius: 10px; -moz-border-radius: 10px; -o-border-radius: 10px; -ms-border-radius: 10px; border-radius: 10px;} 布局流程为了提高网页制作的效率，布局时通常有以下的布局流程，具体如下： 1、必须确定页面的版心（可视区）， 我们测量可得知。 2、分析页面中的行模块，以及每个行模块中的列模块。其实页面布局，就是一行行罗列而成 3、制作HTML结构。我们还是遵循，先有结构，后有样式的原则。结构永远最重要。 4、然后开始运用盒子模型的原理，通过DIV+CSS布局来控制网页的各个模块。 页面制作这个页面的版心是 1200像素 每个版心都要水平居中对齐，所以，我们干脆把版心定义为： 1234.w { width: 1200px; margin: auto;} 头部制作结构图如下： 1号是版心盒子header 1200 * 42 的盒子水平居中对齐, 上下给一个margin值就好了。 版心盒子 里面包含 2号盒子 logo 版心盒子 里面包含 3号盒子 nav导航栏 版心盒子 里面包含 4号盒子 search搜索框 版心盒子 里面包含 5号盒子 user个人信息 注意，要求里面的 4个盒子 必须都浮动 banner制作结构图如下： 1号盒子是通栏的大盒子banner， 不给宽度，给高度，给一个蓝色背景。 2号盒子是版心， 要水平居中对齐。 3号盒子版心内，左对齐 subnav侧导航栏。 4号盒子版心内，右对齐 course 课程。 课程表模块结构图如下： 1号盒子 是 228 * 300 的盒子 右浮动 注意 浮动的元素 不会有外边距塌陷的问题 1号盒子内 分为 上下 两个 子盒子 2号子盒子是 上部分 我们命名为 course-hd (hd 是 head 的简写 头部的意思，我们经常用) 3号子盒子是 下部分 我们命名为 course-bd (bd 是 body 的简写 主体的意思，我们经常用) 精品推荐小模块结构图如下： 复习点： 因为里面三个盒子都要垂直居中，我们利用 继承性，给 最大的盒子 一个垂直居中的代码就好了，还记得 那些 样式可以继承吗？？？ font- line- text- color 大盒子水平居中 goods 精品 ，注意此处有个盒子阴影 1号盒子是标题 H3 左侧浮动 2号盒子 里面放链接 左侧浮动 goods-item 距离可以控制链接的 左右外边距（注意行内元素只给左右内外边距） 3号盒子 右浮动 mod 修改 精品推荐大模块结构图如下： 1号盒子为最大的盒子 box 版心水平居中对齐 2号盒子为上面部分 box-hd – 里面 左侧标题H3 左浮动 右侧 链接 a 右浮动 3号盒子为底下部分 box-bd — 里面是无序列表 有 10个 小li 组成 小li 外边距的问题， 这里有个小技巧。 给box-hd 宽度为 1215 就可以一行装开5个 li了 复习点： 我们用到清除浮动 因为 box-hd 里面的盒子个数不一定多少，我们就不给高度了，但是里面的盒子浮动了， 影响下面的布局，此时需要浮动 底部模块制作结构图如下： 1号盒子通栏大盒子 底部 footer 给高度 底色是白色 2号盒子版心水平居中 3号盒子版权 copyright 左对齐 4号盒子 链接组 links 右对齐 chrome调试工具“工欲善其事，必先利其器” Chrome浏览器不仅可以调试页面、JS、请求、资源、cookie，还可以模拟手机进行调试。我们现在只是使用html和css，我们先讲一下现在常用的调试。 怎样打开Chrome的开发者工具？直接在页面上点击右键，然后选择 “检查” 快捷键 F12 或者 ctrl+shift+i 基本的结构布局是左边html 右边是 css chrome调试数值可以鼠标点击后面的数值， 按下键盘 上箭头 是 调大 数值， 下箭头是 调小数值 快速定位css所在行数 Chrome提示的常见布局错误css单词书写错误提示用下图所示的黑色箭头，点击我们需要的 html 元素。 css无显示声明类名和html调用名不一致 或者 css文件引入不对 或者 这个样式的前面 多余了一些符号影响的 html 结构不匹配(重要)左侧 展开可以看到html 标签是否匹配 通过颜色判断盒子蓝色是 盒子的 宽度高度 青色是 内边距 橙色 是外边距 通过这个很方便的看到盒子给的范围 看看你有如下错误吗","link":"/前端笔记/css-day05/"},{"title":"HTML-Day01","text":"第01阶段.前端基础.认识WEB 课程安排 HTML 第一天目标 能够写出基本的html页面（里面包含图片、链接、文字等网页元素标签） 认识WEB1. 认识网页1网页主要由文字、图像和超链接等元素构成。当然，除了这些元素，网页中还可以包含音频、视频以及Flash等。 思考： 网页是如何形成的呢? 总结网页有图片、链接、文字等元素组成，我们后面的任务就是要把这部分网页元素用代码写出来。。。 2. 浏览器（显示代码） 1浏览器是网页显示、运行的平台，常用的浏览器有IE、火狐（Firefox）、谷歌（Chrome）、Safari和Opera等。我们平时称为五大浏览器。 可能你最熟悉的是 IE浏览器，但是。。。 2.1 查看浏览器占有的市场份额查看网站： http://tongji.baidu.com/data/browser 2008年，大名鼎鼎的互联网巨头Google公司发布了它的首款浏览器Chrome浏览器。 跟王思聪一样，没办法，生下来人家就是富二代官二代啊，后台太强，而且确实先天能力得天独厚。 pink老师 一句话说出他们: 出自谷歌，唯我不败；一统江湖，千秋万代。 2.2 常见浏览器内核（了解）首先解释一下浏览器内核是什么东西。英文叫做：Rendering Engine，中文翻译很多，排版引擎、解释引擎、渲染引擎，现在流行称为浏览器内核. 1负责读取网页内容，整理讯息，计算网页的显示方式并显示页面. 因为浏览器太多啦， 但是现在主要流行的就是下面几个： 浏览器 内核 备注 IE Trident IE、猎豹安全、360极速浏览器、百度浏览器 firefox Gecko 可惜这几年已经没落了，打开速度慢、升级频繁、猪一样的队友flash、神一样的对手chrome。 Safari webkit 现在很多人错误地把 webkit 叫做 chrome内核（即使 chrome内核已经是 blink 了）。苹果感觉像被别人抢了媳妇，都哭晕再厕所里面了。 chrome Chromium/Blink 在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。Blink 其实是 WebKit 的分支。大部分国产浏览器最新版都采用Blink内核。二次开发 Opera blink 现在跟随chrome用blink内核。 拓展阅读： 12345移动端的浏览器内核主要说的是系统内置浏览器的内核。Android手机而言，使用率最高的就是Webkit内核，大部分国产浏览器宣称的自己的内核，基本上也是属于webkit二次开发。iOS以及WP7平台上，由于系统原因，系统大部分自带浏览器内核，一般是Safari或者IE内核Trident的 3. Web标准（重点）目标 记忆 能说出网页 中 web 标准三层组成 理解 能结合人来表述web标准三层 Web标准不是某一个标准，而是由W3C组织和其他标准化组织制定的一系列标准的集合。 W3C 万维网联盟是国际最著名的标准化组织。1994年成立后，至今已发布近百项相关万维网的标准，对万维网发展做出了杰出的贡献。 w3c就类似于现实世界中的联合国。 3.1 为什么要遵循WEB标准呢？ 通过以上浏览器不同内核不同，我们知道他们显示页面或者排版就有些许差异。 3.2 Web 标准的好处遵循web标准可以让不同我们写的页面更标准更统一外，还有许多优点 1、让Web的发展前景更广阔2、内容能被更广泛的设备访问3、更容易被搜寻引擎搜索4、降低网站流量费用5、使网站更易于维护6、提高页面浏览速度 3.3 Web 标准构成构成： 主要包括结构（Structure）、表现（Presentation）和行为（Behavior）三个方面。 标准 说明 备注 结构 结构用于对网页元素进行整理和分类，咱们主要学的是HTML。 表现 表现用于设置网页元素的版式、颜色、大小等外观样式，主要指的是CSS 行为 行为是指网页模型的定义及交互的编写，咱们主要学的是 Javascript 理想状态我们的源码： .HTML .css .js 结合人来记忆web标准： 结构标准： 是你天然的身体 表现标准： 决定你是否打扮的美丽外观(衣服？化妆？) 行为标准： 决定你是否有吸引人的行为(动作) web标准小结 web标准有三层结构，分别是结构（html）、表现（css）和行为（javascript） 结构类似人的身体， 表现类似人的着装， 行为类似人的行为动作 理想状态下，他们三层都是独立的， 放到不同的文件里面 4. 拓展@ 介绍一下你对浏览器内核的理解？常见的浏览器内核有哪些？ 浏览器内核包括两部分，渲染引擎和js引擎。渲染引擎负责读取网页内容，整理讯息，计算网页的显示方式并显示页面，js引擎是解析执行js获取网页的动态效果。 后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。IE：Tridentfirefox：Geckochrom、safari：webkitOpera：PrestoMicrosoft Edge：EdgeHTML 深度阅读：五大主流浏览器内核的源起以及国内各大浏览器内核总结","link":"/前端笔记/html-day01/"},{"title":"HTML-Day04","text":"第01阶段.前端基础.表格 HTML 第二天目标 能够利用表格、列表和表单完成注册页面的综合案例 能出说表格用来做什么的 能说出列表用来做什么的 能说出表单用来做什么的 为了让我们页面显示的更加整齐，我们需要学习三个表（表格、表单、列表） 表格 table(会使用)目标： 理解： 能说出表格用来做什么的 表格的基本结构组成 应用： 能够熟练写出n行n列的表格 能简单的合并单元格​ 表格作用： 存在即是合理的。 表格的现在还是较为常用的一种标签，但不是用来布局，常见显示、展示表格式数据。 因为它可以让数据显示的非常的规整，可读性非常好。 特别是后台展示数据的时候表格运用是否熟练就显得很重要，一个清爽简约的表格能够把繁杂的数据表现得很有条理，虽然 div 布局也可以做到，但是总没有表格来得方便。 ps: 这些地方用表格，你会觉得生活还是那么美好。。。。忍不住想说 PPAP i hava a pen 1. 创建表格在HTML网页中，要想创建表格，就需要使用表格相关的标签。 创建表格的基本语法： 1234567&lt;table&gt; &lt;tr&gt; &lt;td&gt;单元格内的文字&lt;/td&gt; ... &lt;/tr&gt; ...&lt;/table&gt; 要深刻体会表格、行、单元格他们的构成。 在上面的语法中包含基本的三对HTML标签，分别为 table、tr、td，他们是创建表格的基本标签，缺一不可，下面对他们进行具体地解释 table用于定义一个表格标签。 tr标签 用于定义表格中的行，必须嵌套在 table标签中。 td 用于定义表格中的单元格，必须嵌套在标签中。 字母 td 指表格数据（table data），即数据单元格的内容，现在我们明白，表格最合适的地方就是用来存储数据的。 *总结： * 表格的主要目的是用来显示特殊数据的 一个完整的表格有表格标签（table），行标签（tr），单元格标签（td）组成，没有列的标签 中只能嵌套 类的单元格 标签，他就像一个容器，可以容纳所有的元素 2. 表格属性表格有部分属性我们不常用，这里重点记住 cellspacing 、 cellpadding。 我们经常有个说法，是三参为0， 平时开发的我们这三个参数 border cellpadding cellspacing 为 0 案例1： 12345678&lt;table width=\"500\" height=\"300\" border=\"1\" cellpadding=\"20\" cellspacing=\"0\" align=\"center\"&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;刘德华&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;55&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;郭富城&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;52&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;张学友&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;58&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;黎明&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;18&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;刘晓庆&lt;/td&gt; &lt;td&gt;女&lt;/td&gt; &lt;td&gt;63&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 3. 表头单元格标签th 作用： 一般表头单元格位于表格的第一行或第一列，并且文本加粗居中 语法： 只需用表头标签&lt;th&gt;&lt;/th&gt;替代相应的单元格标签&lt;td&gt;&lt;/td&gt;即可。 案例2： ​ 效果图 ​ 代码： 1234567891011121314151617&lt;table width=\"500\" border=\"1\" align=\"center\" cellspacing=\"0\" cellpadding=\"0\"&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;电话&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小王&lt;/td&gt; &lt;td&gt;女&lt;/td&gt; &lt;td&gt;110&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小明&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;120&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; pink老师 一句话说出他们: th 也是一个单元格 只不过和普通的 td单元格不一样，它会让自己里面的文字居中且加粗 4. 表格标题caption定义和用法 123&lt;table&gt; &lt;caption&gt;我是表格标题&lt;/caption&gt;&lt;/table&gt; *注意： * caption 元素定义表格标题，通常这个标题会被居中且显示于表格之上。 caption 标签必须紧随 table 标签之后。 这个标签只存在 表格里面才有意义。你是风儿我是沙 案例3： 根据要求完成以下案例： 5. 合并单元格(难点)合并单元格是我们比较常用的一个操作，但是不会合并的很复杂。 5.1 合并单元格2种方式 跨行合并：rowspan=”合并单元格的个数” 跨列合并：colspan=”合并单元格的个数” 5.2 合并单元格顺序 *合并的顺序我们按照 先上 后下 先左 后右 的顺序 * 跟我们以前学习汉字的书写顺序完全一致。 5.3 合并单元格三步曲 先确定是跨行还是跨列合并 根据 先上 后下 先左 后右的原则找到目标单元格 然后写上 合并方式 还有 要合并的单元格数量 比如 ： 删除多余的单元格 单元格 6. 总结表格 标签名 定义 说明 表格标签 就是一个四方的盒子 表格行标签 行标签要再table标签内部才有意义 单元格标签 单元格标签是个容器级元素，可以放任何东西 表头单元格标签 它还是一个单元格，但是里面的文字会居中且加粗 表格标题标签 表格的标题，跟着表格一起走，和表格居中对齐 clospan 和 rowspan 合并属性 用来合并单元格的 表格提供了HTML 中定义表格式数据的方法。 表格中由行中的单元格组成。 表格中没有列元素，列的个数取决于行的单元格个数。 表格不要纠结于外观，那是CSS 的作用。 表格的学习要求： 能手写表格结构，并且能简单合并单元格。 7. 拓展阅读@表格划分结构（了解）1对于比较复杂的表格，表格的结构也就相对的复杂了，所以又将表格分割成三个部分：题头、正文和脚注。而这三部分分别用:thead,tbody,tfoot来标注， 这样更好的分清表格结构 注意： ：用于定义表格的头部。用来放标题之类的东西。 内部必须拥有 标签！ ：用于定义表格的主体。放数据本体 。 放表格的脚注之类。 以上标签都是放到table标签中。","link":"/前端笔记/html-day04/"},{"title":"HTML5+CSS3-Day02","text":"第02阶段.移动Web网页开发.CSS3属性 HTML5 第二天rotate 2d旋转指的是让元素在2维平面内顺时针旋转或者逆时针旋转 使用步骤： 给元素添加转换属性 transform 属性值为 rotate(角度) 如 transform:rotate(30deg) 顺时针方向旋转30度 123div{ transform: rotate(0deg);} 三角 代码演示 设置元素旋转中心点(transform-origin) transform-origin 基础语法 1transform-origin: x y; 重要知识点 注意后面的参数 x 和 y 用空格隔开 x y 默认旋转的中心点是元素的中心 (50% 50%)，等价于 center center 还可以给 x y 设置像素或者方位名词(top、bottom、left、right、center) 旋转中心案例 代码演示 2D 转换之 scale scale 的作用 用来控制元素的放大与缩小 语法 1transform: scale(x, y) 知识要点 注意，x 与 y 之间使用逗号进行分隔 transform: scale(1, 1): 宽高都放大一倍，相当于没有放大 transform: scale(2, 2): 宽和高都放大了二倍 transform: scale(2): 如果只写了一个参数，第二个参数就和第一个参数一致 transform:scale(0.5, 0.5): 缩小 scale 最大的优势：可以设置转换中心点缩放，默认以中心点缩放，而且不影响其他盒子 代码演示 12345678910div:hover { /* 注意，数字是倍数的含义，所以不需要加单位 */ /* transform: scale(2, 2) */ /* 实现等比缩放，同时修改宽与高 */ /* transform: scale(2) */ /* 小于 1 就等于缩放*/ transform: scale(0.5, 0.5)} 图片放大案例 代码演示 分页按钮案例 代码演示 2D 转换综合写法以及顺序问题 知识要点 同时使用多个转换，其格式为 transform: translate() rotate() scale() 顺序会影响到转换的效果(先旋转会改变坐标轴方向) 但我们同时有位置或者其他属性的时候，要将位移放到最前面 代码演示 123div:hover { transform: translate(200px, 0) rotate(360deg) scale(1.2)} 动画(animation) 什么是动画 动画是 CSS3 中最具颠覆性的特征之一，可通过设置多个节点来精确的控制一个或者一组动画，从而实现复杂的动画效果 动画的基本使用 先定义动画 在调用定义好的动画 语法格式(定义动画) 12345678@keyframes 动画名称 { 0% { width: 100px; } 100% { width: 200px }} 语法格式(使用动画) 123456div { /* 调用动画 */ animation-name: 动画名称; /* 持续时间 */ animation-duration: 持续时间；} 动画序列 0% 是动画的开始，100 % 是动画的完成，这样的规则就是动画序列 在 @keyframs 中规定某项 CSS 样式，就由创建当前样式逐渐改为新样式的动画效果 动画是使元素从一个样式逐渐变化为另一个样式的效果，可以改变任意多的样式任意多的次数 用百分比来规定变化发生的时间，或用 from 和 to，等同于 0% 和 100% 代码演示 123456789101112131415161718&lt;style&gt; div { width: 100px; height: 100px; background-color: aquamarine; animation-name: move; animation-duration: 0.5s; } @keyframes move{ 0% { transform: translate(0px) } 100% { transform: translate(500px, 0) } } &lt;/style&gt; 动画序列 代码演示 动画常见属性 常见的属性 代码演示 123456789101112131415161718192021222324div { width: 100px; height: 100px; background-color: aquamarine; /* 动画名称 */ animation-name: move; /* 动画花费时长 */ animation-duration: 2s; /* 动画速度曲线 */ animation-timing-function: ease-in-out; /* 动画等待多长时间执行 */ animation-delay: 2s; /* 规定动画播放次数 infinite: 无限循环 */ animation-iteration-count: infinite; /* 是否逆行播放 */ animation-direction: alternate; /* 动画结束之后的状态 */ animation-fill-mode: forwards;}div:hover { /* 规定动画是否暂停或者播放 */ animation-play-state: paused;} 动画简写方式 动画简写方式 12/* animation: 动画名称 持续时间 运动曲线 何时开始 播放次数 是否反方向 起始与结束状态 */animation: name duration timing-function delay iteration-count direction fill-mode 知识要点 简写属性里面不包含 animation-paly-state 暂停动画 animation-paly-state: paused; 经常和鼠标经过等其他配合使用 要想动画走回来，而不是直接调回来：animation-direction: alternate 盒子动画结束后，停在结束位置：animation-fill-mode: forwards 代码演示 1animation: move 2s linear 1s infinite alternate forwards; 速度曲线细节 速度曲线细节 animation-timing-function: 规定动画的速度曲线，默认是ease 代码演示 12345678910111213141516171819div { width: 0px; height: 50px; line-height: 50px; white-space: nowrap; overflow: hidden; background-color: aquamarine; animation: move 4s steps(24) forwards;}@keyframes move { 0% { width: 0px; } 100% { width: 480px; }} 奔跑的熊大 代码演示 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body { background-color: #ccc; } div { position: absolute; width: 200px; height: 100px; background: url(media/bear.png) no-repeat; /* 我们元素可以添加多个动画， 用逗号分隔 */ animation: bear .4s steps(8) infinite, move 3s forwards; } @keyframes bear { 0% { background-position: 0 0; } 100% { background-position: -1600px 0; } } @keyframes move { 0% { left: 0; } 100% { left: 50%; /* margin-left: -100px; */ transform: translateX(-50%); } } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","link":"/前端笔记/html5-css3-day02/"},{"title":"HTML5+CSS3-Day03","text":"第02阶段.移动Web网页开发.3D转换 HTML5 第三天一、 认识 3D 转换 3D 的特点 近大远小 物体和面遮挡不可见 三维坐标系 x 轴：水平向右 – 注意：x 轴右边是正值，左边是负值 y 轴：垂直向下 – 注意：y 轴下面是正值，上面是负值 z 轴：垂直屏幕 – 注意：往外边的是正值，往里面的是负值 ​ 二、3D 转换 3D 转换知识要点 3D 位移：translate3d(x, y, z) 3D 旋转：rotate3d(x, y, z) 透视：perspctive 3D呈现 transfrom-style 3D 移动 translate3d 3D 移动就是在 2D 移动的基础上多加了一个可以移动的方向，就是 z 轴方向 transform: translateX(100px)：仅仅是在 x 轴上移动 transform: translateY(100px)：仅仅是在 y 轴上移动 transform: translateZ(100px)：仅仅是在 z 轴上移动 transform: translate3d(x, y, z)：其中x、y、z 分别指要移动的轴的方向的距离 注意：x, y, z 对应的值不能省略，不需要填写用 0 进行填充 语法 1transform: translate3d(x, y, z) 代码演示 123transform: translate3d(100px, 100px, 100px)/* 注意：x, y, z 对应的值不能省略，不需要填写用 0 进行填充 */transform: translate3d(100px, 100px, 0) 三、透视 perspective 知识点讲解 如果想要网页产生 3D 效果需要透视(理解成 3D 物体投影的 2D 平面上) 实际上模仿人类的视觉位置，可视为安排一直眼睛去看 透视也称为视距，所谓的视距就是人的眼睛到屏幕的距离 距离视觉点越近的在电脑平面成像越大，越远成像越小 透视的单位是像素 知识要点 透视需要写在被视察元素的父盒子上面 注意下方图片 d：就是视距，视距就是指人的眼睛到屏幕的距离 z：就是 z 轴，z 轴越大(正值)，我们看到的物体就越大 ​ 代码演示 123body { perspective: 1000px;} 四、 translateZ translateZ 与 perspecitve 的区别 perspecitve 给父级进行设置，translateZ 给 子元素进行设置不同的大小 五、3D 旋转rotateX 3D 旋转指可以让元素在三维平面内沿着 x 轴、y 轴、z 轴 或者自定义轴进行旋转 语法 transform: rotateX(45deg) – 沿着 x 轴正方向旋转 45 度 transform: rotateY(45deg) – 沿着 y 轴正方向旋转 45 度 transform: rotateZ(45deg) – 沿着 z 轴正方向旋转 45 度 transform: rotate3d(x, y, z, 45deg) – 沿着自定义轴旋转 45 deg 为角度 代码案例 12345678910111213div { perspective: 300px;}img { display: block; margin: 100px auto; transition: all 1s;}img:hover { transform: rotateX(-45deg)} 左手准则 左手的手拇指指向 x 轴的正方向 其余手指的弯曲方向就是该元素沿着 x 轴旋转的方向 ​ 六、3D 旋转 rotateY 代码演示 12345678910111213div { perspective: 500px;}img { display: block; margin: 100px auto; transition: all 1s;}img:hover { transform: rotateY(180deg)} 左手准则 左手的拇指指向 y 轴的正方向 其余的手指弯曲方向就是该元素沿着 y 轴旋转的方向(正值) 七、 3D 旋转 rotateZ 代码演示 12345678910111213div { perspective: 500px;}img { display: block; margin: 100px auto; transition: all 1s;}img:hover { transform: rotateZ(180deg)} rotate3d transform: rotate3d(x, y, z, deg) – 沿着自定义轴旋转 deg 为角度 x, y, z 表示旋转轴的矢量，是标识你是否希望沿着该轴进行旋转，最后一个标识旋转的角度 transform: rotate3d(1, 1, 0, 180deg) – 沿着对角线旋转 45deg transform: rotate3d(1, 0, 0, 180deg) – 沿着 x 轴旋转 45deg 代码演示 12345678910111213div { perspective: 500px;}img { display: block; margin: 100px auto; transition: all 1s;}img:hover { transform: rotate3d(1, 1, 0, 180deg)} 八、3D 呈现 transform-style transform-style ☆☆☆☆☆ 控制子元素是否开启三维立体环境 transform-style: flat 代表子元素不开启 3D 立体空间，默认的 transform-style: preserve-3d 子元素开启立体空间 代码写给父级，但是影响的是子盒子 代码演示 12345678910111213141516171819202122232425262728 #div1 { position: relative; height: 200px; width: 200px; margin: 100px; padding:10px; border: 1px solid black; } #div2 { padding:50px; position: absolute; border: 1px solid black; background-color: red; transform: rotateY(60deg); transform-style: preserve-3d; -webkit-transform: rotateY(60deg); /* Safari and Chrome */ -webkit-transform-style: preserve-3d; /* Safari and Chrome */ } #div3 {padding:40px;position: absolute;border: 1px solid black;background-color: yellow;transform: rotateY(-60deg);-webkit-transform: rotateY(-60deg); /* Safari and Chrome */}","link":"/前端笔记/html5-css3-day03/"},{"title":"JavaScript-Day03","text":"第03阶段.JavaScript基础.循环 JavaScript基础第03天笔记循环for循环 语法结构 123for(初始化变量; 条件表达式; 操作表达式 ){ //循环体} 名称 作用 初始化变量 通常被用于初始化一个计数器，该表达式可以使用 var 关键字声明新的变量，这个变量帮我们来记录次数。 条件表达式 用于确定每一次循环是否能被执行。如果结果是 true 就继续循环，否则退出循环。 操作表达式 用于确定每一次循环是否能被执行。如果结果是 true 就继续循环，否则退出循环。 执行过程： 初始化变量，初始化操作在整个 for 循环只会执行一次。 执行条件表达式，如果为true，则执行循环体语句，否则退出循环，循环结束。 执行操作表达式，此时第一轮结束。 第二轮开始，直接去执行条件表达式（不再初始化变量），如果为 true ，则去执行循环体语句，否则退出循环。 继续执行操作表达式，第二轮结束。 后续跟第二轮一致，直至条件表达式为假，结束整个 for 循环。 断点调试： 1断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。断点调试可以帮助观察程序的运行过程 1234断点调试的流程：1、浏览器中按 F12--&gt; sources --&gt;找到需要调试的文件--&gt;在程序的某一行设置断点2、Watch: 监视，通过watch可以监视变量的值的变化，非常的常用。3、摁下F11，程序单步执行，让程序一行一行的执行，这个时候，观察watch中变量的值的变化。 for 循环重复相同的代码 比如输出10句“媳妇我错了” 123456789// 基本写法for(var i = 1; i &lt;= 10; i++){ console.log('媳妇我错了~');}// 用户输入次数var num = prompt('请输入次数:')；for ( var i = 1 ; i &lt;= num; i++) { console.log('媳妇我错了~');} for 循环重复不相同的代码 例如，求输出1到100岁： 1234// 基本写法for (var i = 1; i &lt;= 100; i++) { console.log('这个人今年' + i + '岁了');} 例如，求输出1到100岁，并提示出生、死亡 12345678910// for 里面是可以添加其他语句的 for (var i = 1; i &lt;= 100; i++) { if (i == 1) { console.log('这个人今年1岁了， 它出生了'); } else if (i == 100) { console.log('这个人今年100岁了，它死了'); } else { console.log('这个人今年' + i + '岁了'); }} for循环因为有了计数器的存在，还可以重复的执行某些操作，比如做一些算术运算。 双重for循环 双重 for 循环概述 循环嵌套是指在一个循环语句中再定义一个循环语句的语法结构，例如在for循环语句中，可以再嵌套一个for 循环，这样的 for 循环语句我们称之为双重for循环。 双重 for 循环语法 12345for (外循环的初始; 外循环的条件; 外循环的操作表达式) { for (内循环的初始; 内循环的条件; 内循环的操作表达式) { 需执行的代码; }} 内层循环可以看做外层循环的循环体语句 内层循环执行的顺序也要遵循 for 循环的执行顺序 外层循环执行一次，内层循环要执行全部次数 打印五行五列星星 123456789var star = '';for (var j = 1; j &lt;= 3; j++) { for (var i = 1; i &lt;= 3; i++) { star += '☆' } // 每次满 5个星星 就 加一次换行 star += '\\n'}console.log(star); 核心逻辑： 1.内层循环负责一行打印五个星星 2.外层循环负责打印五行 for 循环小结 for 循环可以重复执行某些相同代码 for 循环可以重复执行些许不同的代码，因为我们有计数器 for 循环可以重复执行某些操作，比如算术运算符加法操作 随着需求增加，双重for循环可以做更多、更好看的效果 双重 for 循环，外层循环一次，内层 for 循环全部执行 for 循环是循环条件和数字直接相关的循环 while循环while语句的语法结构如下： 123while (条件表达式) { // 循环体代码 } 执行思路： 1 先执行条件表达式，如果结果为 true，则执行循环体代码；如果为 false，则退出循环，执行后面代码 2 执行循环体代码 3 循环体代码执行完毕后，程序会继续判断执行条件表达式，如条件仍为true，则会继续执行循环体，直到循环条件为 false 时，整个循环过程才会结束 注意： 使用 while 循环时一定要注意，它必须要有退出条件，否则会成为死循环 do-while循环do… while 语句的语法结构如下： 123do { // 循环体代码 - 条件表达式为 true 时重复执行循环体代码} while(条件表达式); 执行思路 1 先执行一次循环体代码 2 再执行条件表达式，如果结果为 true，则继续执行循环体代码，如果为 false，则退出循环，继续执行后面代码 注意：先再执行循环体，再判断，do…while循环语句至少会执行一次循环体代码 continue、breakcontinue 关键字用于立即跳出本次循环，继续下一次循环（本次循环体中 continue 之后的代码就会少执行一次）。 例如，吃5个包子，第3个有虫子，就扔掉第3个，继续吃第4个第5个包子，其代码实现如下： 1234567for (var i = 1; i &lt;= 5; i++) { if (i == 3) { console.log('这个包子有虫子，扔掉'); continue; // 跳出本次循环，跳出的是第3次循环 } console.log('我正在吃第' + i + '个包子呢');} 运行结果： break 关键字用于立即跳出整个循环（循环结束）。 例如，吃5个包子，吃到第3个发现里面有半个虫子，其余的不吃了，其代码实现如下： 123456for (var i = 1; i &lt;= 5; i++) { if (i == 3) { break; // 直接退出整个for 循环，跳到整个for下面的语句 } console.log('我正在吃第' + i + '个包子呢'); } 运行结果： 代码规范标识符命名规范 变量、函数的命名必须要有意义 变量的名称一般用名词 函数的名称一般用动词 操作符规范1234567// 操作符的左右两侧各保留一个空格for (var i = 1; i &lt;= 5; i++) { if (i == 3) { break; // 直接退出整个 for 循环，跳到整个for循环下面的语句 } console.log('我正在吃第' + i + '个包子呢');} 单行注释规范123456for (var i = 1; i &lt;= 5; i++) { if (i == 3) { break; // 单行注释前面注意有个空格 } console.log('我正在吃第' + i + '个包子呢');} 其他规范关键词、操作符之间后加空格","link":"/前端笔记/javascript-day03/"},{"title":"Node.js-Day01","text":"第04阶段.前后端交互.Node.js基础 目标 能够知道Node是什么 能够安装Node运行环境 能够知道系统环境变量PATH的作用 能够使用Node环境执行代码 Node开发概述为什么要学习服务器端开发基础 能够和后端程序员更加紧密的配合 网站业务逻辑前置，学习前端技术需要后端技术支撑（Ajax） 扩宽知识视野，能够站在更高的角度审视整个项目 服务器端开发要做的事情 实现网站的业务逻辑 数据的增删改查 为什么选择Node 使用JavaScript语法开发后端应用 一些公司要求前端工程师掌握Node开发 生态系统活跃，有大量开源库可以使用 前端开发工具大多基于Node开发 Node是什么Node是一个基于Chrome V8引擎的JavaScript代码运行环境。 ) 运行环境 浏览器（软件）能够运行JavaScript代码，浏览器就是JavaScript代码的运行环境 Node（软件）能够运行JavaScript代码，Node就是JavaScript代码的运行环境 Node运行环境搭建Node.js运行环境安装国内下载地址：http://nodejs.cn/ Node环境安装失败解决办法错误代号2502、2503失败原因：系统帐户权限不足。解决办法： 以管理员身份运行powershell命令行工具 输入运行安装包命令 msiexec /package node安装包位置 执行命令报错 失败原因：Node安装目录写入环境变量失败解决办法：将Node安装目录添加到环境变量中 PATH环境变量存储系统中的目录，在命令行中执行命令的时候系统会自动去这些目录中查找命令的位置。 Node.js快速入门Node.js 的组成 JavaScript 由三部分组成，ECMAScript，DOM，BOM。 Node.js是由ECMAScript及Node 环境提供的一些附加API组成的，包括文件、网络、路径等等一些更加强大的 API。 ) Node.js基础语法所有ECMAScript语法在Node环境中都可以使用。在Node环境下执行代码，使用Node命令执行后缀为.js的文件即可 Node.js全局对象global在浏览器中全局对象是window，在Node中全局对象是global。 Node中全局对象下有以下方法，可以在任何地方使用，global可以省略。 console.log() 在控制台中输出 setTimeout() 设置超时定时器 clearTimeout() 清除超时时定时器 setInterval() 设置间歇定时器 clearInterval() 清除间歇定时器","link":"/前端笔记/node-js-day01/"},{"title":"Node.js-Day04","text":"第04阶段.前后端交互.MongoDB数据库 目标 能够安装数据库软件 能够知道集合、文档的概念 能够使用mongoose创建集合的方法创建集合 能够对数据库中的数据进行增删改查操作 数据库概述及环境搭建为什么要使用数据库 动态网站中的数据都是存储在数据库中的 数据库可以用来持久存储客户端通过表单收集的用户信息 数据库软件本身可以对数据进行高效的管理 什么是数据库数据库即存储数据的仓库，可以将数据进行有序的分门别类的存储。它是独立于语言之外的软件，可以通过API去操作它。常见的数据库软件有：mysql、mongoDB、oracle。 MongoDB数据库下载安装下载地址：https://www.mongodb.com/download-center/community MongoDB可视化软件MongoDB可视化操作软件，是使用图形界面操作数据库的一种方式。 数据库相关概念在一个数据库软件中可以包含多个数据仓库，在每个数据仓库中可以包含多个数据集合，每个数据集合中可以包含多条文档（具体的数据）。 术语 解释说明 database 数据库，mongoDB数据库软件中可以建立多个数据库 collection 集合，一组数据的集合，可以理解为JavaScript中的数组 document 文档，一条具体的数据，可以理解为JavaScript中的对象 field 字段，文档中的属性名称，可以理解为JavaScript中的对象属性 Mongoose第三方包 使用Node.js操作MongoDB数据库需要依赖Node.js第三方包mongoose 使用npm install mongoose命令下载 启动MongoDB在命令行工具中运行net start mongoDB即可启动MongoDB，否则MongoDB将无法连接。 数据库连接使用mongoose提供的connect方法即可连接数据库。 123mongoose.connect(&apos;mongodb://localhost/playground&apos;) .then(() =&gt; console.log(&apos;数据库连接成功&apos;)) .catch(err =&gt; console.log(&apos;数据库连接失败&apos;, err)); 创建数据库在MongoDB中不需要显式创建数据库，如果正在使用的数据库不存在，MongoDB会自动创建。 MongoDB增删改查操作创建集合创建集合分为两步，一是对对集合设定规则，二是创建集合，创建mongoose.Schema构造函数的实例即可创建集合。 12345678 // 设定集合规则const courseSchema = new mongoose.Schema({ name: String, author: String, isPublished: Boolean}); // 创建集合并应用规则const Course = mongoose.model(&apos;Course&apos;, courseSchema); // courses 创建文档创建文档实际上就是向集合中插入数据。分为两步： 创建集合实例。 调用实例对象下的save方法将数据保存到数据库中。 123456789 // 创建集合实例const course = new Course({ name: &apos;Node.js course&apos;, author: &apos;董冬懂冻&apos;, tags: [&apos;node&apos;, &apos;backend&apos;], isPublished: true}); // 将数据保存到数据库中course.save(); 123456Course.create({name: &apos;JavaScript基础&apos;, author: &apos;董冬懂冻&apos;, isPublish: true}, (err, doc) =&gt; { // 错误对象 console.log(err) // 当前插入的文档 console.log(doc)}); 123Course.create({name: &apos;JavaScript基础&apos;, author: &apos;董冬懂冻&apos;, isPublish: true}) .then(doc =&gt; console.log(doc)) .catch(err =&gt; console.log(err)) mongoDB数据库导入数据mongoimport –d 数据库名称 –c 集合名称 –file 要导入的数据文件找到mongodb数据库的安装目录，将安装目录下的bin目录放置在环境变量中。 查询文档12345678910111213// 根据条件查找文档（条件为空则查找所有文档）Course.find().then(result =&gt; console.log(result))// 返回文档集合[{ _id: 5c0917ed37ec9b03c07cf95f, name: &apos;node.js基础&apos;, author: &apos;董冬懂冻‘},{ _id: 5c09dea28acfb814980ff827, name: &apos;Javascript&apos;, author: &apos;董冬懂冻‘}] 123456789// 根据条件查找文档Course.findOne({name: &apos;node.js基础&apos;}).then(result =&gt; console.log(result))// 返回文档 { _id: 5c0917ed37ec9b03c07cf95f, name: &apos;node.js基础&apos;, author: &apos;董冬懂冻‘} 12// 匹配大于 小于User.find({age: {$gt: 20, $lt: 50}}).then(result =&gt; console.log(result)) 12// 匹配包含User.find({hobbies: {$in: [&apos;敲代码&apos;]}}).then(result =&gt; console.log(result)) 12// 选择要查询的字段 User.find().select(&apos;name email&apos;).then(result =&gt; console.log(result)) 12// 将数据按照年龄进行排序User.find().sort(&apos;age&apos;).then(result =&gt; console.log(result)) 12// skip 跳过多少条数据 limit 限制查询数量User.find().skip(2).limit(2).then(result =&gt; console.log(result)) 删除文档12 // 删除单个Course.findOneAndDelete({}).then(result =&gt; console.log(result)) 12 // 删除多个User.deleteMany({}).then(result =&gt; console.log(result)) 更新文档12// 更新单个User.updateOne({查询条件}, {要修改的值}).then(result =&gt; console.log(result)) 12// 更新多个User.updateMany({查询条件}, {要更改的值}).then(result =&gt; console.log(result)) mongoose验证在创建集合规则时，可以设置当前字段的验证规则，验证失败就则输入插入失败。 required: true 必传字段 minlength：3 字符串最小长度 maxlength: 20 字符串最大长度 min: 2 数值最小为2 max: 100 数值最大为100 enum: [‘html’, ‘css’, ‘javascript’, ‘node.js’] trim: true 去除字符串两边的空格 validate: 自定义验证器 default: 默认值 集合关联通常不同集合的数据之间是有关系的，例如文章信息和用户信息存储在不同集合中，但文章是某个用户发表的，要查询文章的所有信息包括发表用户，就需要用到集合关联。 使用id对集合进行关联 使用populate方法进行关联集合查询 集合关联实现1234567891011121314// 用户集合const User = mongoose.model(&apos;User&apos;, new mongoose.Schema({ name: { type: String } })); // 文章集合const Post = mongoose.model(&apos;Post&apos;, new mongoose.Schema({ title: { type: String }, // 使用ID将文章集合和作者集合进行关联 author: { type: mongoose.Schema.Types.ObjectId, ref: &apos;User&apos; }}));//联合查询Post.find() .populate(&apos;author&apos;) .then((err, result) =&gt; console.log(result)); 案例：用户信息增删改查 搭建网站服务器，实现客户端与服务器端的通信 连接数据库，创建用户集合，向集合中插入文档 当用户访问/list时，将所有用户信息查询出来 将用户信息和表格HTML进行拼接并将拼接结果响应回客户端 当用户访问/add时，呈现表单页面，并实现添加用户信息功能 当用户访问/modify时，呈现修改页面，并实现修改用户信息功能 当用户访问/delete时，实现用户删除功能","link":"/前端笔记/node-js-day04/"},{"title":"Node.js-Day05","text":"第04阶段.前后端交互.模板引擎artTemplate 目标 能够使用模板引擎渲染数据 能够使用模板引擎进行原文输出 能够使用循环输出数据 能够知道如何引用子模板 能够知道如何如何进行模板继承 模板引擎的基础概念模板引擎模板引擎是第三方模块。让开发者以更加友好的方式拼接字符串，使项目代码更加清晰、更加易于维护。 art-template模板引擎 在命令行工具中使用 npm install art-template 命令进行下载 使用const template = require(‘art-template’)引入模板引擎 告诉模板引擎要拼接的数据和模板在哪 const html = template(‘模板路径’, 数据); 使用模板语法告诉模板引擎，模板与数据应该如何进行拼接 art-template代码示例 模板引擎的语法模板语法 art-template同时支持两种模板语法：标准语法和原始语法。 标准语法可以让模板更容易读写，原始语法具有强大的逻辑处理能力。 输出将某项数据输出在模板中，标准语法和原始语法如下： 原文输出如果数据中携带HTML标签，默认模板引擎不会解析标签，会将其转义后输出。 条件判断 循环 子模版使用子模板可以将网站公共区块(头部、底部)抽离到单独的文件中。 模板继承使用模板继承可以将网站HTML骨架抽离到单独的文件中，其他页面模板可以继承骨架文件。 模板继承示例1234567891011&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;HTML骨架模板&lt;/title&gt; {{block &apos;head&apos;}}{{/block}} &lt;/head&gt; &lt;body&gt; {{block &apos;content&apos;}}{{/block}} &lt;/body&gt;&lt;/html&gt; 1234&lt;!--index.art 首页模板--&gt;{{extend &apos;./layout.art&apos;}}{{block &apos;head&apos;}} &lt;link rel=&quot;stylesheet&quot; href=&quot;custom.css&quot;&gt; {{/block}}{{block &apos;content&apos;}} &lt;p&gt;This is just an awesome page.&lt;/p&gt; {{/block}} 模板配置 向模板中导入变量 template.defaults.imports.变量名 = 变量值; 设置模板根目录 template.defaults.root = 模板目录 设置模板默认后缀 template.defaults.extname = ‘.art’ 案例案例介绍 – 学生档案管理目标：模板引擎应用，强化node.js项目制作流程。 知识点：http请求响应、数据库、模板引擎、静态资源访问。 制作流程 建立项目文件夹并生成项目描述文件 创建网站服务器实现客户端和服务器端通信 连接数据库并根据需求设计学员信息表 创建路由并实现页面模板呈递 实现静态资源访问 实现学生信息添加功能 实现学生信息展示功能 第三方模块 router功能：实现路由使用步骤： 获取路由对象 调用路由对象提供的方法创建路由 启用路由，使路由生效 123456const serveStatic = require(&apos;serve-static&apos;)const serve = serveStatic(&apos;public&apos;)server.on(&apos;request&apos;, () =&gt; { serve(req, res)})server.listen(3000) 添加学生信息功能步骤分析 在模板的表单中指定请求地址与请求方式 为每一个表单项添加name属性 添加实现学生信息功能路由 接收客户端传递过来的学生信息 将学生信息添加到数据库中 将页面重定向到学生信息列表页面 学生信息列表页面分析 从数据库中将所有的学生信息查询出来 通过模板引擎将学生信息和HTML模板进行拼接 将拼接好的HTML模板响应给客户端","link":"/前端笔记/node-js-day05/"},{"title":"flex布局","text":"第02阶段.移动Web网页开发.flex布局 移动web开发——flex布局传统布局和flex布局对比传统布局 兼容性好 布局繁琐 局限性，不能再移动端很好的布局 flex布局 操作方便，布局极其简单，移动端使用比较广泛 pc端浏览器支持情况比较差 IE11或更低版本不支持flex或仅支持部分 建议 如果是pc端页面布局，还是采用传统方式 如果是移动端或者是不考虑兼容的pc则采用flex flex布局原理 flex 是 flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为 flex 布局。 当我们为父盒子设为 flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。 flex布局又叫伸缩布局 、弹性布局 、伸缩盒布局 、弹性盒布局 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flexitem），简称”项目”。 总结：就是通过给父盒子添加flex属性，来控制子盒子的位置和排列方式 父项常见属性 flex-direction：设置主轴的方向 justify-content：设置主轴上的子元素排列方式 flex-wrap：设置子元素是否换行 align-content：设置侧轴上的子元素的排列方式（多行） align-items：设置侧轴上的子元素排列方式（单行） flex-flow：复合属性，相当于同时设置了 flex-direction 和 flex-wrap flex-direction设置主轴的方向 在 flex 布局中，是分为主轴和侧轴两个方向，同样的叫法有 ： 行和列、x 轴和y 轴 默认主轴方向就是 x 轴方向，水平向右 默认侧轴方向就是 y 轴方向，水平向下 注意： 主轴和侧轴是会变化的，就看 flex-direction 设置谁为主轴，剩下的就是侧轴。而我们的子元素是跟着主轴来排列的 justify-content 设置主轴上的子元素排列方式 flex-wrap设置是否换行 默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，flex布局中默认是不换行的。 nowrap 不换行 wrap 换行 align-items 设置侧轴上的子元素排列方式（单行 ） 该属性是控制子项在侧轴（默认是y轴）上的排列方式 在子项为单项（单行）的时候使用 flex-start 从头部开始 flex-end 从尾部开始 center 居中显示 stretch 拉伸 align-content 设置侧轴上的子元素的排列方式（多行）设置子项在侧轴上的排列方式 并且只能用于子项出现 换行 的情况（多行），在单行下是没有效果的。 align-content 和align-items区别 align-items 适用于单行情况下， 只有上对齐、下对齐、居中和 拉伸 align-content适应于换行（多行）的情况下（单行情况下无效）， 可以设置 上对齐、下对齐、居中、拉伸以及平均分配剩余空间等属性值。 总结就是单行找align-items 多行找 align-content flex-flow 属性是 flex-direction 和 flex-wrap 属性的复合属性1flex-flow:row wrap; flex布局子项常见属性 flex子项目占的份数 align-self控制子项自己在侧轴的排列方式 order属性定义子项的排列顺序（前后顺序） flex 属性flex 属性定义子项目分配剩余空间，用flex来表示占多少份数。 123.item { flex: &lt;number&gt;; /* 默认值 0 */} align-self控制子项自己在侧轴上的排列方式align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。 默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。 1234span:nth-child(2) { /* 设置自己在侧轴上的排列方式 */ align-self: flex-end;} order 属性定义项目的排列顺序数值越小，排列越靠前，默认为0。 注意：和 z-index 不一样。 123.item { order: &lt;number&gt;;} 携程网首页案例制作携程网链接：http://m.ctrip.com 1.技术选型 方案：我们采取单独制作移动页面方案 技术：布局采取flex布局 2.搭建相关文件夹 3.设置视口标签以及引入初始化样式 1234&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no,initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;css/normalize.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot;&gt; 4.常用初始化样式 12345678910body { max-width: 540px; min-width: 320px; margin: 0 auto; font: normal 14px/1.5 Tahoma,&quot;Lucida Grande&quot;,Verdana,&quot;Microsoft Yahei&quot;,STXihei,hei; color: #000; background: #f2f2f2; overflow-x: hidden; -webkit-tap-highlight-color: transparent;} 5.模块名字划分","link":"/前端笔记/flex布局/"},{"title":"需要笔记里的源码、素材可以私信我或在评论留下邮箱","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/JavaScript/需要笔记里的源码、素材可以私信我或在评论留下邮箱/"},{"title":"响应式布局","text":"第02阶段.移动Web网页开发.响应式布局 移动端WEB开发之响应式布局响应式开发原理响应式开发原理就是使用媒体查询针对不同宽度的设备进行布局和样式的设置，从而适配不同设备的目的。 设备的划分情况： 小于768的为超小屏幕（手机） 768~992之间的为小屏设备（平板） 992~1200的中等屏幕（桌面显示器） 大于1200的宽屏设备（大桌面显示器） 响应式布局容器 响应式需要一个父级做为布局容器，来配合子级元素来实现变化效果。 原理就是在不同屏幕下，通过媒体查询来改变这个布局容器的大小，再改变里面子元素的排列方式和大小，从而实现不同屏幕下，看到不同的页面布局和样式变化。 父容器版心的尺寸划分 超小屏幕（手机，小于 768px）：设置宽度为 100% 小屏幕（平板，大于等于 768px）：设置宽度为 750px 中等屏幕（桌面显示器，大于等于 992px）：宽度设置为 970px 大屏幕（大桌面显示器，大于等于 1200px）：宽度设置为 1170px 但是我们也可以根据实际情况自己定义划分 bootstrap的介绍Bootstrap简介Bootstrap 来自 Twitter（推特），是目前最受欢迎的前端框架。Bootstrap 是基于HTML、CSS 和 JAVASCRIPT 的，它简洁灵活，使得 Web 开发更加快捷。 中文网 官网 推荐网站 框架：顾名思义就是一套架构，它有一套比较完整的网页功能解决方案，而且控制权在框架本身，有预制样式库、组件和插件。使用者要按照框架所规定的某种规范进行开发。 bootstrap优点 标准化的html+css编码规范 提供了一套简洁、直观、强悍的组件 有自己的生态圈，不断的更新迭代 让开发更简单，提高了开发的效率 版本简介2.x.x：停止维护,兼容性好,代码不够简洁，功能不够完善。 3.x.x：目前使用最多,稳定,但是放弃了IE6-IE7。对 IE8 支持但是界面效果不好,偏向用于开发响应式布局、移动设备优先的WEB 项目。 4.x.x：最新版，目前还不是很流行 bootstrap基本使用在现阶段我们还没有接触JS相关课程，所以我们只考虑使用它的样式库。 Bootstrap 使用四步曲： 创建文件夹结构 创建 html 骨架结构 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;Bootstrap 101 Template&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;link href=&quot;css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries --&gt; &lt;!-- WARNING: Respond.js doesn&apos;t work if you view the page via file:// --&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;//cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;//cdn.bootcss.com/respond.js/1.4.2/respond.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;你好，世界！&lt;/h1&gt; &lt;!-- jQuery (necessary for Bootstrap&apos;s JavaScript plugins) --&gt; &lt;script src=&quot;//cdn.bootcss.com/jquery/1.11.3/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;!-- Include all compiled plugins (below), or include individual files as needed --&gt; &lt;script src=&quot;js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 引入相关样式文件 12&lt;!-- Bootstrap 核心样式--&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;bootstrap/css/bootstrap.min.css&quot;&gt; 书写内容 直接拿Bootstrap 预先定义好的样式来使用 修改Bootstrap 原来的样式，注意权重问题 学好Bootstrap 的关键在于知道它定义了哪些样式，以及这些样式能实现什么样的效果 bootstrap布局容器Bootstrap 需要为页面内容和栅格系统包裹一个 .container 或者.container-fluid 容器，它提供了两个作此用处的类。 .container 响应式布局的容器 固定宽度 大屏 ( &gt;=1200px) 宽度定为 1170px 中屏 ( &gt;=992px) 宽度定为 970px 小屏 ( &gt;=768px) 宽度定为 750px 超小屏 (100%) .container-fluid 流式布局容器 百分百宽度 占据全部视口（viewport）的容器。 Bootstrap栅格系统Bootstrap提供了一套响应式、移动设备优先的流式栅格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列。 栅格系统用于通过一系列的行（row）与列（column）的组合来创建页面布局，你的内容就可以放入这些创建好的布局中。 按照不同屏幕划分为1~12 等份 行（row） 可以去除父容器作用15px的边距 xs-extra small：超小； sm-small：小； md-medium：中等； lg-large：大； 列（column）大于 12，多余的“列（column）”所在的元素将被作为一个整体另起一行排列 每一列默认有左右15像素的 padding 可以同时为一列指定多个设备的类名，以便划分不同份数 例如 class=”col-md-4 col-sm-6” 栅格嵌套 栅格系统内置的栅格系统将内容再次嵌套。简单理解就是一个列内再分成若干份小列。我们可以通过添加一个新的 .row 元素和一系列 .col-sm-* 元素到已经存在的 .col-sm-*元素内。 1234567&lt;!-- 列嵌套 --&gt; &lt;div class=&quot;col-sm-4&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-6&quot;&gt;小列&lt;/div&gt; &lt;div class=&quot;col-sm-6&quot;&gt;小列&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 列偏移 使用 .col-md-offset-* 类可以将列向右侧偏移。这些类实际是通过使用 * 选择器为当前元素增加了左侧的边距（margin）。 12345&lt;!-- 列偏移 --&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-lg-4&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;col-lg-4 col-lg-offset-4&quot;&gt;2&lt;/div&gt; &lt;/div&gt; 列排序 通过使用 .col-md-push-* 和 .col-md-pull-* 类就可以很容易的改变列（column）的顺序。 12345&lt;!-- 列排序 --&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-lg-4 col-lg-push-8&quot;&gt;左侧&lt;/div&gt; &lt;div class=&quot;col-lg-8 col-lg-pull-4&quot;&gt;右侧&lt;/div&gt; &lt;/div&gt; 响应式工具 为了加快对移动设备友好的页面开发工作，利用媒体查询功能，并使用这些工具类可以方便的针对不同设备展示或隐藏页面内容。 阿里百秀案例制作技术选型方案：我们采取响应式页面开发方案 技术：bootstrap框架 设计图： 本设计图采用 1280px 设计尺寸 项目结构搭建 Bootstrap 使用四步曲： 创建文件夹结构 创建 html 骨架结构 引入相关样式文件 书写内容 container宽度修改 因为本效果图采取 1280的宽度， 而Bootstrap 里面 container宽度 最大为 1170px，因此我们需要手动改下container宽度 123456/* 利用媒体查询修改 container宽度适合效果图宽度 */ @media (min-width: 1280px) { .container { width: 1280px; } }","link":"/前端笔记/响应式布局/"},{"title":"流式布局","text":"第02阶段.移动Web网页开发.流式布局 移动web开发——流式布局移动端基础浏览器现状 PC端常见浏览器：360浏览器、谷歌浏览器、火狐浏览器、QQ浏览器、百度浏览器、搜狗浏览器、IE浏览器。 移动端常见浏览器：UC浏览器，QQ浏览器，欧朋浏览器，百度手机浏览器，360安全浏览器，谷歌浏览器，搜狗手机浏览器，猎豹浏览器，以及其他杂牌浏览器。 国内的UC和QQ，百度等手机浏览器都是根据Webkit修改过来的内核，国内尚无自主研发的内核，就像国内的手机操作系统都是基于Android修改开发的一样。 总结：兼容移动端主流浏览器，处理Webkit内核浏览器即可。 手机屏幕的现状 移动端设备屏幕尺寸非常多，碎片化严重。 Android设备有多种分辨率：480x800, 480x854, 540x960, 720x1280，1080x1920等，还有传说中的2K，4k屏。 近年来iPhone的碎片化也加剧了，其设备的主要分辨率有：640x960, 640x1136, 750x1334, 1242x2208等。 作为开发者无需关注这些分辨率，因为我们常用的尺寸单位是 px 。 常见移动端屏幕尺寸 移动端调试方法 Chrome DevTools（谷歌浏览器）的模拟手机调试 搭建本地web服务器，手机和服务器一个局域网内，通过手机访问服务器 使用外网服务器，直接IP或域名访问 视口视口（viewport）就是浏览器显示页面内容的屏幕区域。 视口可以分为布局视口、视觉视口和理想视口 布局视口 layout viewport一般移动设备的浏览器都默认设置了一个布局视口，用于解决早期的PC端页面在手机上显示的问题。 iOS, Android基本都将这个视口分辨率设置为 980px，所以PC上的网页大多都能在手机上呈现，只不过元素看上去很小，一般默认可以通过手动缩放网页。 视觉视口 visual viewport字面意思，它是用户正在看到的网站的区域。注意：是网站的区域。 我们可以通过缩放去操作视觉视口，但不会影响布局视口，布局视口仍保持原来的宽度。 理想视口 ideal viewport为了使网站在移动端有最理想的浏览和阅读宽度而设定 理想视口，对设备来讲，是最理想的视口尺寸 需要手动添写meta视口标签通知浏览器操作 meta视口标签的主要目的：布局视口的宽度应该与理想视口的宽度一致，简单理解就是设备有多宽，我们布局的视口就多宽 总结：我们开发最终会用理想视口，而理想视口就是将布局视口的宽度修改为视觉视口 meta标签 最标准的viewport设置 视口宽度和设备保持一致 视口的默认缩放比例1.0 不允许用户自行缩放 最大允许的缩放比例1.0 最小允许的缩放比例1.0 二倍图物理像素&amp;物理像素比物理像素点指的是屏幕显示的最小颗粒，是物理真实存在的。这是厂商在出厂时就设置好了,比如苹果6 是 750* 1334 我们开发时候的1px 不是一定等于1个物理像素的 一个px的能显示的物理像素点的个数，称为物理像素比或屏幕像素比 如果把1张100*100的图片放到手机里面会按照物理像素比给我们缩放 lRetina（视网膜屏幕）是一种显示技术，可以将把更多的物理像素点压缩至一块屏幕里，从而达到更高的分辨率，并提高屏幕显示的细腻程度。 对于一张 50px * 50px 的图片,在手机或 Retina 屏中打开，按照刚才的物理像素比会放大倍数，这样会造成图片模糊 在标准的viewport设置中，使用倍图来提高图片质量，解决在高清设备中的模糊问题 通常使用二倍图， 因为iPhone 6 的影响背景图片 注意缩放问题 背景缩放background-sizebackground-size 属性规定背景图像的尺寸 1background-size: 背景图片宽度 背景图片高度; 单位： 长度|百分比|cover|contain; cover把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。 contain把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域 移动开发选择和技术解决方案移动端主流方案1.单独制作移动端页面（主流） 通常情况下，网址域名前面加 m(mobile)可以打开移动端。通过判断设备，如果是移动设备打开，则跳到移动端页面。 也就是说，PC端和移动端为两套网站，pc端是pc断的样式，移动端在写一套，专门针对移动端适配的一套网站 京东pc端： 京东移动端： 2.响应式页面兼容移动端（其次） 响应式网站：即pc和移动端共用一套网站，只不过在不同屏幕下，样式会自动适配 移动端技术解决方案1.移动端浏览器兼容问题 移动端浏览器基本以 webkit 内核为主，因此我们就考虑webkit兼容性问题。 我们可以放心使用 H5 标签和 CSS3 样式。 同时我们浏览器的私有前缀我们只需要考虑添加 webkit 即可 2.移动端公共样式 移动端 CSS 初始化推荐使用 normalize.css/ Normalize.css：保护了有价值的默认值 Normalize.css：修复了浏览器的bug Normalize.css：是模块化的 Normalize.css：拥有详细的文档 官网地址： http://necolas.github.io/normalize.css/ 移动端大量使用 CSS3盒子模型box-sizin传统模式宽度计算：盒子的宽度 = CSS中设置的width + border + padding CSS3盒子模型： 盒子的宽度= CSS中设置的宽度width 里面包含了 border 和 padding 也就是说，我们的CSS3中的盒子模型， padding 和 border 不会撑大盒子了 1234/*CSS3盒子模型*/box-sizing: border-box;/*传统盒子模型*/box-sizing: content-box; 移动端可以全部CSS3 盒子模型 PC端如果完全需要兼容，我们就用传统模式，如果不考虑兼容性，我们就选择 CSS3 盒子模型 移动端特殊样式123456789/*CSS3盒子模型*/box-sizing: border-box;-webkit-box-sizing: border-box;/*点击高亮我们需要清除清除 设置为transparent 完成透明*/-webkit-tap-highlight-color: transparent;/*在移动端浏览器默认的外观在iOS上加上这个属性才能给按钮和输入框自定义样式*/-webkit-appearance: none;/*禁用长按页面时的弹出菜单*/img,a { -webkit-touch-callout: none; } 移动端常见布局移动端单独制作 流式布局（百分比布局） flex 弹性布局（强烈推荐） less+rem+媒体查询布局 混合布局 响应式 媒体查询 bootstarp 流式布局： 流式布局，就是百分比布局，也称非固定像素布局。 通过盒子的宽度设置成百分比来根据屏幕的宽度来进行伸缩，不受固定像素的限制，内容向两侧填充。 流式布局方式是移动web开发使用的比较常见的布局方式。","link":"/前端笔记/流式布局/"},{"title":"AJAX-Day02","text":"第04阶段.前后端交互.AJAX拓展 模板引擎模板引擎概述作用：使用模板引擎提供的模板语法，可以将数据和 HTML 拼接起来。 官方地址： https://aui.github.io/art-template/zh-cn/index.html 使用步骤 下载 art-template 模板引擎库文件并在 HTML 页面中引入库文件 1&lt;script src=&quot;lib/template-web.js&quot;&gt;&lt;/script&gt; 准备 art-template 模板 123&lt;script id=&quot;tpl&quot; type=&quot;text/html&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/script&gt; 告诉模板引擎将哪一个模板和哪个数据进行拼接 1var html = template(&apos;tpl&apos;, {username: &apos;zhangsan&apos;, age: &apos;20&apos;}); 将拼接好的html字符串添加到页面中 1document.getElementById(&apos;container&apos;).innerHTML = html; 通过模板语法告诉模板引擎，数据和html字符串要如何拼接 123&lt;script id=&quot;tpl&quot; type=&quot;text/html&quot;&gt; &lt;div class=&quot;box&quot;&gt; {{ username }} &lt;/div&gt;&lt;/script&gt; 案例验证邮箱地址唯一性 获取文本框并为其添加离开焦点事件 离开焦点时，检测用户输入的邮箱地址是否符合规则 如果不符合规则，阻止程序向下执行并给出提示信息 向服务器端发送请求，检测邮箱地址是否被别人注册 根据服务器端返回值决定客户端显示何种提示信息 搜索框内容自动提示 获取搜索框并为其添加用户输入事件 获取用户输入的关键字 向服务器端发送请求并携带关键字作为请求参数 将响应数据显示在搜索框底部 省市区三级联动 通过接口获取省份信息 使用JavaScript获取到省市区下拉框元素 将服务器端返回的省份信息显示在下拉框中 为下拉框元素添加表单值改变事件（onchange） 当用户选择省份时，根据省份id获取城市信息 当用户选择城市时，根据城市id获取县城信息 FormData作用 模拟HTML表单，相当于将HTML表单映射成表单对象，自动将表单对象中的数据拼接成请求参数的格式。 异步上传二进制文件 使用 准备 HTML 表单 12345 &lt;form id=&quot;form&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt; &lt;input type=&quot;button&quot;/&gt;&lt;/form&gt; 将 HTML 表单转化为 formData 对象 12var form = document.getElementById(&apos;form&apos;); var formData = new FormData(form); 删除表单对象中属性的值 1formData.delete(&apos;key&apos;); 向表单对象中追加属性值 1formData.append(&apos;key&apos;, &apos;value&apos;); 注意：set 方法与 append 方法的区别是，在属性名已存在的情况下，set 会覆盖已有键名的值，append会保留两个值。 二进制文件上传1&lt;input type=&quot;file&quot; id=&quot;file&quot;/&gt; 1234567891011 var file = document.getElementById(&apos;file&apos;)// 当用户选择文件的时候 file.onchange = function () { // 创建空表单对象 var formData = new FormData(); // 将用户选择的二进制文件追加到表单对象中 formData.append(&apos;attrName&apos;, this.files[0]); // 配置ajax对象，请求方式必须为post xhr.open(&apos;post&apos;, &apos;www.example.com&apos;); xhr.send(formData); } 文件上传进度展示123456789// 当用户选择文件的时候file.onchange = function () { // 文件上传过程中持续触发onprogress事件 xhr.upload.onprogress = function (ev) { // 当前上传文件大小/文件总大小 再将结果转换为百分数 // 将结果赋值给进度条的宽度属性 bar.style.width = (ev.loaded / ev.total) * 100 + &apos;%&apos;; }} 文件上传图片即时预览在我们将图片上传到服务器端以后，服务器端通常都会将图片地址做为响应数据传递到客户端，客户端可以从响应数据中获取图片地址，然后将图片再显示在页面中。 12345678xhr.onload = function () { var result = JSON.parse(xhr.responseText); var img = document.createElement(&apos;img&apos;); img.src = result.src; img.onload = function () { document.body.appendChild(this); }} 同源政策什么是同源如果两个页面拥有相同的协议、域名和端口，那么这两个页面就属于同一个源，其中只要有一个不相同，就是不同源。http://www.example.com/dir/page.html http://www.example.com/dir2/other.html：同源http://example.com/dir/other.html：不同源（域名不同）http://v2.www.example.com/dir/other.html：不同源（域名不同）http://www.example.com:81/dir/other.html：不同源（端口不同）https://www.example.com/dir/page.html：不同源（协议不同） 同源政策的目的 同源政策是为了保证用户信息的安全，防止恶意的网站窃取数据。最初的同源政策是指 A 网站在客户端设置的 Cookie，B网站是不能访问的。 随着互联网的发展，同源政策也越来越严格，在不同源的情况下，其中有一项规定就是无法向非同源地址发送Ajax 请求，如果请求，浏览器就会报错。 使用 JSONP 解决同源限制问题jsonp 是 json with padding 的缩写，它不属于 Ajax 请求，但它可以模拟 Ajax 请求。 将不同源的服务器端请求地址写在 script 标签的 src 属性中 1&lt;script src=&quot;www.example.com&quot;&gt;&lt;/script&gt; 1&lt;script src=“https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js&quot;&gt;&lt;/script&gt; 服务器端响应数据必须是一个函数的调用，真正要发送给客户端的数据需要作为函数调用的参数。 12const data = &apos;fn({name: &quot;张三&quot;, age: &quot;20&quot;})&apos;;res.send(data); 在客户端全局作用域下定义函数 fn 1function fn (data) { } 在 fn 函数内部对服务器端返回的数据进行处理 1function fn (data) { console.log(data); } JSONP 代码优化 客户端需要将函数名称传递到服务器端。 将 script 请求的发送变成动态请求。 封装 jsonp 函数，方便请求发送。 服务器端代码优化之 res.jsonp 方法。 CORS 跨域资源共享CORS：全称为 Cross-origin resource sharing，即跨域资源共享，它允许浏览器向跨域服务器发送 Ajax 请求，克服了 Ajax 只能同源使用的限制。 1origin: http://localhost:3000 12Access-Control-Allow-Origin: &apos;http://localhost:3000&apos;Access-Control-Allow-Origin: &apos;*&apos; Node 服务器端设置响应头示例代码： 12345app.use((req, res, next) =&gt; { res.header(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;); res.header(&apos;Access-Control-Allow-Methods&apos;, &apos;GET, POST&apos;); next();}) 访问非同源数据 服务器端解决方案同源政策是浏览器给予Ajax技术的限制，服务器端是不存在同源政策限制。 cookie复习 withCredentials属性 在使用Ajax技术发送跨域请求时，默认情况下不会在请求中携带cookie信息。 withCredentials：指定在涉及到跨域请求时，是否携带cookie信息，默认值为false Access-Control-Allow-Credentials：true 允许客户端发送请求时携带cookie","link":"/前端笔记/ajax-day02/"},{"title":"CSS-Day04","text":"第01阶段.前端基础.浮动 浮动(float)目标 记忆 能够说出 CSS 的布局的三种机制 理解 能够说出普通流在布局中的特点 能够说出我们为什么用浮动 能够说出我们为什么要清除浮动 应用 能够利用浮动完成导航栏案例 能够清除浮动 能够使用PS切图工具 CSS 布局的三种机制 网页布局的核心——就是用 CSS 来摆放盒子。 CSS 提供了 3 种机制来设置盒子的摆放位置，分别是普通流（标准流）、浮动和定位，其中： 普通流（标准流） 块级元素会独占一行，从上向下顺序排列； 常用元素：div、hr、p、h1~h6、ul、ol、dl、form、table 行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行； 常用元素：span、a、i、em等 浮动 让盒子从普通流中浮起来,主要作用让多个块级盒子一行显示。 定位 将盒子定在浏览器的某一个位置——CSS 离不开定位，特别是后面的 js 特效。 为什么需要浮动？思考题： 我们首先要思考以下2个布局中最常见的问题？ 如何让多个盒子(div)水平排列成一行？ 如何实现盒子的左右对齐？ 虽然我们前面学过行内块（inline-block） 但是他却有自己的缺陷： 它可以实现多个元素一行显示，但是中间会有空白缝隙，不能满足以上第一个问题。 它不能实现以上第二个问题，盒子左右对齐 pink老师一句话总结他们 因为一些网页布局要求，标准流不能满足我们的需要了，因此我们需要浮动来完成网页布局。 什么是浮动(float)概念：元素的浮动是指设置了浮动属性的元素会 脱离标准普通流的控制 移动到指定位置。 作用 让多个盒子(div)水平排列成一行，使得浮动成为布局的重要手段。 可以实现盒子的左右对齐等等.. 浮动最早是用来控制图片，实现文字环绕图片的效果。 语法在 CSS 中，通过 float 中文， 浮 漏 特 属性定义浮动，语法如下： 1选择器 { float: 属性值; } 属性值 描述 none 元素不浮动（默认值） left 元素向左浮动 right 元素向右浮动 pink老师教你学浮动口诀。通过 float —– 浮 漏 特 浮动口诀之 浮浮动——浮浮浮脱离标准流。 俗称 “脱标” 1234567891011121314151617181920212223242526272829303132333435363738 ![](CSS-Day04/23%E6%B5%AE%E5%8A%A8%E8%84%B1%E6%A0%87.png)```css.box1 { width: 200px; height: 200px; background-color: rgba(255, 0, 0, 0.5); float: left;}.box2 { width: 150px; height: 300px; background-color: skyblue;}```**小结**：- `float` 属性会让盒子漂浮在标准流的上面，所以第二个标准流的盒子跑到浮动盒子的底下了。#### 浮动口诀之 漏浮动——漏~漏~漏~ 浮动的盒子，把自己原来的位置漏给下面标准流的盒子，就是不占有原来位置，是脱离标准流的，我们俗称 “脱标”。~~~css.box1 { width: 200px; height: 200px; background-color: rgba(255, 0, 0, 0.5); /* 让第 1 个盒子漂浮起来，不占位置 */ float: left;}.box2 { width: 150px; height: 300px; background-color: skyblue;} 所以，box2下面的其实就是跑到box1盒子下面了， 被box1给压住了，遮挡起来了 来来来，我们看个立体图 浮动口诀之 特浮动——特性 float属性会改变元素display属性。 任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。 生成的块级框和我们前面的行内块极其相似。 体验案例——div 水平排列 12345678910111213141516171819202122div { width: 200px; height: 200px; background-color: pink; /* 转换为行内块元素，可以水平显示，不过 div 之间有间隙，不方便处理 */ /* display: inline-block; */ /* 设置浮动属性，可以让 div 水平排列，并且没有间隙 */ float: left;}.two { background-color: hotpink;} 注意： 浮动的元素互相贴靠一起的，但是如果父级宽度装不下这些浮动的盒子， 多出的盒子会另起一行对齐 浮动(float)小结 我们使用浮动的核心目的——让多个块级盒子在同一行显示。 因为这是我们最常见的一种布局方式 float —— 浮漏特 特点 说明 浮 加了浮动的盒子是浮起来的，漂浮在其他标准流盒子的上面。 漏 加了浮动的盒子是不占位置的，它原来的位置漏给了标准流的盒子。 特 特别注意：浮动元素会改变display属性， 类似转换为了行内块，但是元素之间没有空白缝隙 浮动(float)的应用（重要）浮动和标准流的父盒子搭配我们知道，浮动是脱标的，会影响下面的标准流元素，此时，我们需要给浮动的元素添加一个标准流的父亲，这样，最大化的减小了对其他标准流的影响。 pink老师说： 一个完整的网页，是 标准流 + 浮动 + 我们后面要讲的定位 一起完成的。 浮动应用案例 导航栏案例 注意，实际重要的导航栏中，我们不会直接用链接a 而是用 li 包含链接(li+a)的做法。 li+a 语义更清晰，一看这就是有条理的列表型内容。 如果直接用a，搜索引擎容易辨别为有堆砌关键字嫌疑（故意堆砌关键字容易被搜索引擎有降权的风险），从而影响网站排名 浮动(float)的扩展浮动元素与父盒子的关系 子盒子的浮动参照父盒子对齐 不会与父盒子的边框重叠，也不会超过父盒子的内边距​ 浮动元素与兄弟盒子的关系在一个父级盒子中，如果前一个兄弟盒子是： 浮动的，那么当前盒子会与前一个盒子的顶部对齐； 普通流的，那么当前盒子会显示在前一个兄弟盒子的下方。 pink老师 要你记住： 浮动只会影响当前的或者是后面的标准流盒子，不会影响前面的标准流。 建议 如果一个盒子里面有多个子盒子，如果其中一个盒子浮动了，其他兄弟也应该浮动。防止引起问题 清除浮动为什么要清除浮动因为父级盒子很多情况下，不方便给高度，但是子盒子浮动就不占有位置，最后父级盒子高度为0，就影响了下面的标准流盒子。 总结： 由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响 准确地说，并不是清除浮动，而是清除浮动后造成的影响 清除浮动本质听pink老师说清除浮动本质： ​ 清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题。清除浮动之后， 父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了 清除浮动的方法在CSS中，clear属性用于清除浮动，在这里，我们先记住清除浮动的方法，具体的原理，等我们学完css会再回头分析。 语法： 1选择器{clear:属性值;} clear 清除 属性值 描述 left 不允许左侧有浮动元素（清除左侧浮动的影响） right 不允许右侧有浮动元素（清除右侧浮动的影响） both 同时清除左右两侧浮动的影响 但是我们实际工作中， 几乎只用 clear: both; 额外标签法(隔墙法)1是W3C推荐的做法是通过在浮动元素末尾添加一个空的标签例如 &lt;div style=”clear:both”&gt;&lt;/div&gt;，或则其他标签br等亦可。 优点： 通俗易懂，书写方便 缺点： 添加许多无意义的标签，结构化较差。 父级添加overflow属性方法1可以给父级添加： overflow为 hidden| auto| scroll 都可以实现。 优点： 代码简洁 缺点： 内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。 使用after伪元素清除浮动:after 方式为空元素额外标签法的升级版，好处是不用单独加标签了 使用方法： 123.clearfix:after { content: \"\"; display: block; height: 0; clear: both; visibility: hidden; } .clearfix {*zoom: 1;} /* IE6、7 专有 */ 优点： 符合闭合浮动思想 结构语义化正确 缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。 代表网站： 百度、淘宝网、网易等 使用双伪元素清除浮动使用方法： 12345678910.clearfix:before,.clearfix:after { content:\"\"; display:table; }.clearfix:after { clear:both;}.clearfix { *zoom:1;} 优点： 代码更简洁 缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。 代表网站： 小米、腾讯等 清除浮动总结pink老师告诉你我们以后什么时候用清除浮动呢？ 父级没高度 子盒子浮动了 影响下面布局了，我们就应该清除浮动了。 清除浮动的方式 优点 缺点 额外标签法（隔墙法） 通俗易懂，书写方便 添加许多无意义的标签，结构化较差。 父级overflow:hidden; 书写简单 溢出隐藏 父级after伪元素 结构语义化正确 由于IE6-7不支持:after，兼容性问题 父级双伪元素 结构语义化正确 由于IE6-7不支持:after，兼容性问题 后面两种伪元素清除浮动，大家暂且会使用就好， 深入原理，我们后面学完伪元素再讲。 Photoshop 切图常见的图片格式 123456781. jpg图像格式： JPEG（.JPG）对色彩的信息保留较好，高清，颜色较多，我们产品类的图片经常用jpg格式的2. gif图像格式：GIF格式最多只能储存256色，所以通常用来显示简单图形及字体，但是可以保存透明背景和动画效果3. png图像格式是一种新兴的网络图形格式，结合了GIF和JPEG的优点，具有存储形式丰富的特点，能够保持透明背景4. PSD图像格式PSD格式是Photoshop的专用格式，里面可以存放图层、通道、遮罩等多种设计草稿。 PS切图 可以 分为 利用切片工具切图 以及 利用PS的插件快速切图。 切片工具 ps切图片，分两大步： 1). 用切片选中图片 利用切片工具手动划出 图层菜单—新建基于图层的切片 利用辅助线 来切图 – 基于参考线的切片 2). 导出切片 文件菜单 – 存储为web设备所用格式 —- 选择 我们要的图片格式 —- 点存储 — 别忘了选中的切片 辅助线和切片使用及清除视图菜单– 清除 辅助线/ 清除切片 切图插件Cutterman是一款运行在photoshop中的插件，能够自动将你需要的图层进行输出， 以替代传统的手工 “导出web所用格式” 以及使用切片工具进行挨个切图的繁琐流程。 它支持各种各样的图片尺寸、格式、形态输出，方便你在pc、ios、Android等端上使用。 它不需要你记住一堆的语法、规则，纯点击操作，方便、快捷，易于上手。 官网: http://www.cutterman.cn/zh/cutterman 注意： cutterman插件要求你的ps 必须是完整版，不能是绿色版，所以大家需要从新安装完整版本。","link":"/前端笔记/css-day04/"},{"title":"CSS-Day07","text":"第01阶段.前端基础.CSS高级技巧 CSS高级技巧目标 理解 能说出元素显示隐藏最常见的写法 能说出精灵图产生的目的 能说出去除图片底侧空白缝隙的方法 应用 能写出最常见的鼠标样式 能使用精灵图技术 能用滑动门做导航栏案例 元素的显示与隐藏 目的 让一个元素在页面中消失或者显示出来 场景 类似网站广告，当我们点击关闭就不见了，但是我们重新刷新页面，会重新出现！ display 显示（重点） display 设置或检索对象是否及如何显示。 123display: none 隐藏对象display：block 除了转换为块级元素之外，同时还有显示元素的意思。 特点： 隐藏之后，不再保留位置。 实际开发场景： 配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛 visibility 可见性 (了解) 设置或检索是否显示对象。 123visibility：visible ; 对象可视visibility：hidden; 对象隐藏 特点： 隐藏之后，继续保留原有位置。（停职留薪） overflow 溢出(重点) 检索或设置当对象的内容超过其指定高度及宽度时如何管理内容。 属性值 描述 visible 不剪切内容也不添加滚动条 hidden 不显示超过对象尺寸的内容，超出的部分隐藏掉 scroll 不管超出内容否，总是显示滚动条 auto 超出自动显示滚动条，不超出不显示滚动条 实际开发场景： 清除浮动 隐藏超出内容，隐藏掉, 不允许内容超过父盒子。 显示与隐藏总结 属性 区别 用途 display 隐藏对象，不保留位置 配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛 visibility 隐藏对象，保留位置 使用较少 overflow 只是隐藏超出大小的部分 1. 可以清除浮动 2. 保证盒子里面的内容不会超出该盒子范围 CSS用户界面样式 所谓的界面样式， 就是更改一些用户操作样式，以便提高更好的用户体验。 更改用户的鼠标样式 (滚动条因为兼容性非常差，我们不研究) 表单轮廓等。 防止表单域拖拽 鼠标样式cursor 设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。 属性值 描述 default 小白 默认 pointer 小手 move 移动 text 文本 not-allowed 禁止 鼠标放我身上查看效果哦： 1234567&lt;ul&gt; &lt;li style=\"cursor:default\"&gt;我是小白&lt;/li&gt; &lt;li style=\"cursor:pointer\"&gt;我是小手&lt;/li&gt; &lt;li style=\"cursor:move\"&gt;我是移动&lt;/li&gt; &lt;li style=\"cursor:text\"&gt;我是文本&lt;/li&gt; &lt;li style=\"cursor:not-allowed\"&gt;我是文本&lt;/li&gt;&lt;/ul&gt; 轮廓线 outline 是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。 1outline : outline-color ||outline-style || outline-width 但是我们都不关心可以设置多少，我们平时都是去掉的。 li 最直接的写法是 ： outline: 0; 或者 outline: none; 1&lt;input type=\"text\" style=\"outline: 0;\"/&gt; 防止拖拽文本域resize 实际开发中，我们文本域右下角是不可以拖拽： 1&lt;textarea style=\"resize: none;\"&gt;&lt;/textarea&gt; 用户界面样式总结 属性 用途 用途 鼠标样式 更改鼠标样式cursor 样式很多，重点记住 pointer 轮廓线 表单默认outline outline 轮廓线，我们一般直接去掉，border是边框，我们会经常用 防止拖拽 主要针对文本域resize 防止用户随意拖拽文本域，造成页面布局混乱，我们resize:none vertical-align 垂直对齐 有宽度的块级元素居中对齐，是margin: 0 auto; 让文字居中对齐，是 text-align: center; 但是我们从来没有讲过有垂直居中的属性。 vertical-align 垂直对齐，它只针对于行内元素或者行内块元素， 1vertical-align : baseline |top |middle |bottom 设置或检索对象内容的垂直对其方式。 注意： vertical-align 不影响块级元素中的内容对齐，它只针对于行内元素或者行内块元素， 特别是行内块元素， 通常用来控制图片/表单与文字的对齐。 图片、表单和文字对齐所以我们知道，我们可以通过vertical-align 控制图片和文字的垂直关系了。 默认的图片会和文字基线对齐。 去除图片底侧空白缝隙 原因： 图片或者表单等行内块元素，他的底线会和父级盒子的基线对齐。 就是图片底侧会有一个空白缝隙。 解决的方法就是： 给img vertical-align:middle | top| bottom等等。 让图片不要和基线对齐。 给img 添加 display：block; 转换为块级元素就不会存在问题了。 溢出的文字省略号显示white-space white-space设置或检索对象内文本显示方式。通常我们使用于强制一行显示内容 123white-space:normal ；默认处理方式white-space:nowrap ； 强制在同一行内显示所有文本，直到文本结束或者遭遇br标签对象才换行。 text-overflow 文字溢出 设置或检索是否使用一个省略标记（…）标示对象内文本的溢出 123text-overflow : clip ；不显示省略标记（...），而是简单的裁切 text-overflow：ellipsis ； 当对象内文本溢出时显示省略标记（...） 注意： 一定要首先强制一行内显示，再次和overflow属性 搭配使用 总结三步曲123456/*1. 先强制一行内显示文本*/ white-space: nowrap;/*2. 超出的部分隐藏*/ overflow: hidden;/*3. 文字用省略号替代超出的部分*/ text-overflow: ellipsis; CSS精灵技术（sprite) 重点为什么需要精灵技术 图所示为网页的请求原理图，当用户访问一个网站时，需要向服务器发送请求，网页上的每张图像都要经过一次请求才能展现给用户。 然而，一个网页中往往会应用很多小的背景图像作为修饰，当网页中的图像过多时，服务器就会频繁地接受和发送请求，这将大大降低页面的加载速度。 pink老师告诉你我们为什么需要精灵技术： 为了有效地减少服务器接受和发送请求的次数，提高页面的加载速度。 出现了CSS精灵技术（也称CSS Sprites、CSS雪碧）。 精灵技术讲解CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），然而，各个网页元素通常只需要精灵图中不同位置的某个小图，要想精确定位到精灵图中的某个小图。 这样，当用户访问该页面时，只需向服务发送一次请求，网页中的背景图像即可全部展示出来。 我们需要使用CSS的 background-image、 background-repeat background-position属性进行背景定位， 其中最关键的是使用background-position 属性精确地定位。 精灵技术使用的核心总结首先我们知道，css精灵技术主要针对于背景图片，插入的图片img 是不需要这个技术的。 精确测量，每个小背景图片的大小和 位置。 给盒子指定小背景图片时， 背景定位基本都是 负值。 制作精灵图(了解)CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），那我们要做的，就是把小图拼合成一张大图。 大部分情况下，精灵图都是网页美工做。 123我们精灵图上放的都是小的装饰性质的背景图片。 插入图片不能往上放。我们可以横向摆放也可以纵向摆放，但是每个图片之间留有适当的空隙在我们精灵图的最低端，留一片空隙，方便我们以后添加其他精灵图。 结束语： 小公司，背景图片很少的情况，没有必要使用精灵技术，维护成本太高。 如果是背景图片比较多，可以建议使用精灵技术。 滑动门先来体会下现实中的滑动门,或者你可以叫做推拉门： 滑动门出现的背景制作网页时，为了美观，常常需要为网页元素设置特殊形状的背景，比如微信导航栏，有凸起和凹下去的感觉，最大的问题是里面的字数不一样多，咋办？ 为了使各种特殊形状的背景能够自适应元素中文本内容的多少，出现了CSS滑动门技术。它从新的角度构建页面，使各种特殊形状的背景能够自由拉伸滑动，以适应元素内部的文本内容，可用性更强。 最常见于各种导航栏的滑动门。 http://weixin.qq.com/ 核心技术核心技术就是利用CSS精灵（主要是背景位置）和 盒子padding撑开宽度, 以便能适应不同字数的导航栏。 一般的经典布局都是这样的： 12345&lt;li&gt; &lt;a href=\"#\"&gt; &lt;span&gt;导航栏内容&lt;/span&gt; &lt;/a&gt;&lt;/li&gt; css样式 12345678910111213141516171819202122232425262728293031* { padding:0; margin:0; } body{ background: url(images/wx.jpg) repeat-x; } .father { padding-top:20px; } li { padding-left: 16px; height: 33px; float: left; line-height: 33px; margin:0 10px; background: url(./images/to.png) no-repeat left ; } a { padding-right: 16px; height: 33px; display: inline-block; color:#fff; background: url(./images/to.png) no-repeat right ; text-decoration: none; } li:hover, li:hover a { background-image:url(./images/ao.png); } 总结： a 设置 背景左侧，padding撑开合适宽度。 span 设置背景右侧， padding撑开合适宽度 剩下由文字继续撑开宽度。 之所以a包含span就是因为 整个导航都是可以点击的。 拓展@margin负值之美负边距+定位：水平垂直居中咱们前面讲过， 一个绝对定位的盒子， 利用 父级盒子的 50%， 然后 往左(上) 走 自己宽度的一半 ，可以实现盒子水平垂直居中。 压住盒子相邻边框 CSS三角形之美12345678910111213141516div { width: 0; height: 0; line-height:0； font-size: 0;border-top: 10px solid red;border-right: 10px solid green;border-bottom: 10px solid blue;border-left: 10px solid #000; } 一张图， 你就知道 css 三角是怎么来的了, 做法如下： 我们用css 边框可以模拟三角效果 宽度高度为0 我们4个边框都要写， 只保留需要的边框颜色，其余的不能省略，都改为 transparent 透明就好了 为了照顾兼容性 低版本的浏览器，加上 font-size: 0; line-height: 0;","link":"/前端笔记/css-day07/"},{"title":"CSS-Day06","text":"第01阶段.前端基础.定位(position) 定位(position)目标 理解 能说出为什么要用定位 能说出定位的4种分类 能说出四种定位的各自特点 能说出我们为什么常用子绝父相布局 应用 能写出淘宝轮播图布局 CSS 布局的三种机制 网页布局的核心 —— 就是用 CSS 来摆放盒子位置。 CSS 提供了 3 种机制来设置盒子的摆放位置，分别是普通流、浮动和定位，其中： 普通流（标准流） 浮动 让盒子从普通流中浮起来 —— 让多个盒子(div)水平排列成一行。 定位 将盒子定在某一个位置 自由的漂浮在其他盒子的上面 —— CSS 离不开定位，特别是后面的 js 特效。 为什么使用定位 我们先来看一个效果，同时思考一下用标准流或浮动能否实现类似的效果？ 1. 小黄色块在图片上移动，吸引用户的眼球。 2. 当我们滚动窗口的时候，盒子是固定屏幕某个位置的 结论：要实现以上效果，标准流或浮动都无法快速实现 pink老师一句话说出定位： 将盒子定在某一个位置 自由的漂浮在其他盒子(包括标准流和浮动)的上面 所以，我们脑海应该有三种布局机制的上下顺序 标准流在最底层 (海底) ——- 浮动 的盒子 在 中间层 (海面) ——- 定位的盒子 在 最上层 （天空） 定位详解定位也是用来布局的，它有两部分组成： 定位 = 定位模式 + 边偏移 边偏移简单说， 我们定位的盒子，是通过边偏移来移动位置的。 在 CSS 中，通过 top、bottom、left 和 right 属性定义元素的边偏移：（方位名词） 边偏移属性 示例 描述 top top: 80px 顶端偏移量，定义元素相对于其父元素上边线的距离。 bottom bottom: 80px 底部偏移量，定义元素相对于其父元素下边线的距离。 left left: 80px 左侧偏移量，定义元素相对于其父元素左边线的距离。 right right: 80px 右侧偏移量，定义元素相对于其父元素右边线的距离 定位的盒子有了边偏移才有价值。 一般情况下，凡是有定位地方必定有边偏移。 定位模式 (position)在 CSS 中，通过 position 属性定义元素的定位模式，语法如下： 1选择器 { position: 属性值; } 定位模式是有不同分类的，在不同情况下，我们用到不同的定位模式。 值 语义 static 静态定位 relative 相对定位 absolute 绝对定位 fixed 固定定位 静态定位(static) - 了解 静态定位是元素的默认定位方式，无定位的意思。它相当于 border 里面的none， 不要定位的时候用。 静态定位 按照标准流特性摆放位置，它没有边偏移。 静态定位在布局时我们几乎不用的 相对定位(relative) - 重要 相对定位是元素相对于它 原来在标准流中的位置 来说的。（自恋型） 效果图： 相对定位的特点：（务必记住） 相对于 自己原来在标准流中位置来移动的 原来在标准流的区域继续占有，后面的盒子仍然以标准流的方式对待它。 绝对定位(absolute) - 重要绝对定位是元素以带有定位的父级元素来移动位置 （拼爹型） 完全脱标 —— 完全不占位置； 父元素没有定位，则以浏览器为准定位（Document 文档）。 父元素要有定位 将元素依据最近的已经定位（绝对、固定或相对定位）的父元素（祖先）进行定位。 绝对定位的特点：（务必记住） 绝对是以带有定位的父级元素来移动位置 （拼爹型） 如果父级都没有定位，则以浏览器文档为准移动位置 不保留原来的位置，完全是脱标的。 因为绝对定位的盒子是拼爹的，所以要和父级搭配一起来使用。 定位口诀 —— 子绝父相刚才咱们说过，绝对定位，要和带有定位的父级搭配使用，那么父级要用什么定位呢？ 子绝父相 —— 子级是绝对定位，父级要用相对定位。 子绝父相是使用绝对定位的口诀，要牢牢记住！ 疑问：为什么在布局时，子级元素使用绝对定位时，父级元素就要用相对定位呢？ 观察下图，思考一下在布局时，左右两个方向的箭头图片以及父级盒子的定位方式。 分析： 方向箭头叠加在其他图片上方，应该使用绝对定位，因为绝对定位完全脱标，完全不占位置。 父级盒子应该使用相对定位，因为相对定位不脱标，后续盒子仍然以标准流的方式对待它。 如果父级盒子也使用绝对定位，会完全脱标，那么下方的广告盒子会上移，这显然不是我们想要的。 结论：父级要占有位置，子级要任意摆放，这就是子绝父相的由来。 固定定位(fixed) - 重要固定定位是绝对定位的一种特殊形式： （认死理型） 如果说绝对定位是一个矩形 那么 固定定位就类似于正方形 完全脱标 —— 完全不占位置； 只认浏览器的可视窗口 —— 浏览器可视窗口 + 边偏移属性 来设置元素的位置； 跟父元素没有任何关系；单独使用的 不随滚动条滚动。 案例演练：固定定位案例。 提示：IE 6 等低版本浏览器不支持固定定位。 定位(position)的案例哈根达斯案例截图： 哈根达斯分析 一个大的 div 中包含 3 张图片； 大的 div 水平居中； 2 张小图片重叠在广告图片上方 —— 脱标，不占位置，需要使用绝对定位； 2 张小图片分别显示在左上角和右下角 —— 需要使用边偏移确定准确位置。 案例小结： 子绝父相 —— 子元素使用绝对定位，父元素使用相对定位； 与浮动的对比： 绝对定位：脱标，利用边偏移指定准确位置； 浮动：脱标，不能指定准确位置，让多个块级元素在一行显示。 课堂练习：模拟老师的随堂案例完成哈根达斯案例（5 分钟）。 仿新浪头部和广告 新浪案例分析 顶部图片固定在浏览器可视窗口顶部，不会随窗口一起滚动； 左右两侧的广告图片固定在浏览器可视窗口的左右两侧，不会随窗口一起滚动； 注意：底部的内容图片初始显示在顶部图片的下方，如何解决？ 步骤 1 —— 顶部图片和底部内容123456789101112131415.top { /* 注意：使用固定定位时，如果盒子中没有内容，需要指定宽度 */ width: 100%; height: 44px; background: url(images/top.png) no-repeat top center; position: fixed; left: 0px; top: 0px;}.box { width: 1002px; /* 顶部的 44px 的 margin 可以让 box 显示在顶部图片下方 */ margin: 44px auto;} 注意： 在使用固定定位时，如果盒子中没有内容，需要指定宽度 设置底部内容图片的顶部 margin，可以让底部盒子初始显示在顶部图片的下方。 步骤 2 —— 左右两侧广告12345678910111213.ad-left,.ad-right { position: fixed; top: 100px;}.ad-left { left: 0px;}.ad-right { right: 0px;} 注意：不要同时使用 left 和 right 和边偏移属性。 案例小结： 固定定位的应用场景：固定在浏览器可视窗口某个位置的布局； 在使用固定和绝对定位时，如果盒子中没有内容，需要指定宽度（稍后就讲）。 课堂练习：模拟老师的随堂案例完成仿新浪头部和广告案例（5 分钟）。 定位(position)的扩展绝对定位的盒子居中 注意：绝对定位/固定定位的盒子不能通过设置 margin: auto 设置水平居中。 在使用绝对定位时要想实现水平居中，可以按照下图的方法： left: 50%;：让盒子的左侧移动到父级元素的水平中心位置； margin-left: -100px;：让盒子向左移动自身宽度的一半。 案例演示：相对定位案例。 盒子居中定位示意图 课堂练习：实现盒子左中、右中、中上、中下、中中定位（5 分钟）。 堆叠顺序（z-index）在使用定位布局时，可能会出现盒子重叠的情况。 加了定位的盒子，默认后来者居上， 后面的盒子会压住前面的盒子。 应用 z-index 层叠等级属性可以调整盒子的堆叠顺序。如下图所示： z-index 的特性如下： 属性值：正整数、负整数或 0，默认值是 0，数值越大，盒子越靠上； 如果属性值相同，则按照书写顺序，后来居上； 数字后面不能加单位。 注意：z-index 只能应用于相对定位、绝对定位和固定定位的元素，其他标准流、浮动和静态定位无效。 案例演示：堆叠顺序。 定位改变display属性 前面我们讲过， display 是 显示模式， 可以改变显示模式有以下方式: 可以用inline-block 转换为行内块 可以用浮动 float 默认转换为行内块（类似，并不完全一样，因为浮动是脱标的） 绝对定位和固定定位也和浮动类似， 默认转换的特性 转换为行内块。 所以说， 一个行内的盒子，如果加了浮动、固定定位和绝对定位，不用转换，就可以给这个盒子直接设置宽度和高度等。 完善新浪导航案例 同时注意： 浮动元素、绝对定位(固定定位）元素的都不会触发外边距合并的问题。 （我们以前是用padding border overflow解决的） 也就是说，我们给盒子改为了浮动或者定位，就不会有垂直外边距合并的问题了。 综合演练 - 淘宝轮播图 圆角矩形设置4个角圆角矩形可以为4个角分别设置圆度， 但是是有顺序的 1234border-top-left-radius:20px;border-top-right-radius:20px;border-bottom-right-radius:20px;border-bottom-left-radius:20px; 如果4个角，数值相同 1border-radius: 15px; 里面数值不同，我们也可以按照简写的形式，具体格式如下: 1border-radius: 左上角 右上角 右下角 左下角; 还是遵循的顺时针。 定位小结 定位模式 是否脱标占有位置 移动位置基准 模式转换（行内块） 使用情况 静态static 不脱标，正常模式 正常模式 不能 几乎不用 相对定位relative 不脱标，占有位置 相对自身位置移动 不能 基本单独使用 绝对定位absolute 完全脱标，不占有位置 相对于定位父级移动位置 能 要和定位父级元素搭配使用 固定定位fixed 完全脱标，不占有位置 相对于浏览器移动位置 能 单独使用，不需要父级 注意： 边偏移需要和定位模式联合使用，单独使用无效； top 和 bottom 不要同时使用； left 和 right 不要同时使用。 学成网定位总结添加一个小技巧: 网页布局总结一个完整的网页，有标准流 、 浮动 、 定位 一起完成布局的。每个都有自己的专门用法。 标准流可以让盒子上下排列 或者 左右排列的 浮动可以让多个块级元素一行显示 或者 左右对齐盒子 浮动的盒子就是按照顺序左右排列 定位定位最大的特点是有层叠的概念，就是可以让多个盒子 前后 叠压来显示。 但是每个盒子需要测量数值。","link":"/前端笔记/css-day06/"},{"title":"HTML-Day02","text":"第01阶段.前端基础.认识HTML 学习目标 理解 HTML标签的概念 HTML标签的分类 HTML标签的关系 HTML标签的语义化 应用 HTML骨架格式 sublime基本使用 1. HTML 初识 HTML 指的是超文本标记语言 (Hyper Text Markup Language)是用来描述网页的一种语言。 H（很）T（甜）M（蜜）L（啦） HTML 不是一种编程语言，而是一种标记语言 (markup language) 标记语言是一套标记标签 (markup tag) 所谓超文本，有2层含义： 因为它可以加入图片、声音、动画、多媒体等内容（*超越文本限制 *） 不仅如此，它还可以从一个文件跳转到另一个文件，与世界各地主机的文件连接（*超级链接文本 *）。 1&lt;h1&gt; 我是一个大标题 &lt;/h1&gt; pink老师 一句话说出他们: 网页是由网页元素组成的 ， 这些元素是利用html标签描述出来，然后通过浏览器解析，就可以显示给用户了。 门外汉眼中的效果页面 我们要做的html页面 1.1 HTML骨架格式日常生活的书信，我们要遵循共同的约定。 同理：HTML 有自己的语言语法骨架格式：（要遵循，要专业） 要求务必非常流畅的默写下来。。 1234567&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; html骨架标签总结 标签名 定义 说明 HTML标签 页面中最大的标签，我们成为 根标签 文档的头部 注意在head标签中我们必须要设置的标签是title 文档的标题 让页面拥有一个属于自己的网页标题 文档的主体 元素包含文档的所有内容，页面内容 基本都是放到body里面的 文档的标题 让页面拥有一个属于自己的网页标题 *课堂练习1： * 书写我们的第一个HTML 页面。 新建一个demo 的 TXT 文件。 里面写入刚才的HTML 骨架。 把后缀名改为 .HTML。 右击–谷歌浏览器打开。 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;我的第一个页面&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 黑马洗练 一飞冲天 月薪过万 你我之间 &lt;/body&gt;&lt;/html&gt; 为了便于记忆，我们请出刚才要辞职回家养猪的二师兄来帮忙， 我称之为 猪八戒记忆法 团队约定大小写HTML标签名、类名、标签属性和大部分属性值统一用小写 推荐： 123&lt;head&gt; &lt;title&gt;我的第一个页面&lt;/title&gt; &lt;/head&gt; 不推荐： 123&lt;HEAD&gt; &lt;TITLE&gt;我的第一个页面&lt;/TITLE&gt;&lt;/HEAD&gt; 1.2 HTML元素标签分类标签： 在HTML页面中，带有“&lt; &gt;”符号的元素被称为HTML标签，如上面提到的 &lt;html&gt;、&lt;head&gt;、&lt;body&gt;都是HTML骨架结构标签。 分类： 常规元素（双标签） 1&lt;标签名&gt; 内容 &lt;/标签名&gt; 比如 &lt;body&gt; 我是文字 &lt;/body&gt; 该语法中“&lt;标签名&gt;”表示该标签的作用开始，一般称为“开始标签（start tag）”，“&lt;/标签名&gt;” 表示该标签的作用结束，一般称为“结束标签（end tag）”。 和开始标签相比，结束标签只是在前面加了一个关闭符“/”。 我们以后接触的基本都是双标签 空元素（单标签） 1&lt;标签名 /&gt; 比如 &lt;br /&gt; 空元素 用单标签来表示， 简单点说，就是里面不需要包含内容， 只有一个开始标签不需要关闭。 这种单身狗标签非常少，一共没多少，我们多记忆就好 pink老师 一句话说出他们: 世界上单身狗毕竟是少数的， 大部分还是喜欢成双成对，不要拉下你的另外一半，对待一个双标签要有始有终。 1.3 HTML标签关系主要针对于双标签 的相互关系分为两种： 请大家务必熟悉记住这种标签关系，因为后面我们标签嵌套特别多，很容易弄混他们的关系。 嵌套关系 123&lt;head&gt; &lt;title&gt; &lt;/title&gt; &lt;/head&gt; 2.并列关系 12&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; 倡议： 12&gt; 如果两个标签之间的关系是嵌套关系，子元素最好缩进一个tab键的身位（一个tab是4个空格）。如果是并列关系，最好上下对齐。&gt; pink老师 一句话说出他们: html双标签 可以分为 有 一种是 父子级 包含关系的标签 一种是 兄弟级 并列关系的标签 1.4 课堂一练*请问下列哪组标签关系是错误的？ * 2. 代码开发工具（书写代码） 为了提高我们的开发效率 减少代码的出错我们不提倡用记事本开发，我们有更好的犀利哥。 Dreamweaver SublimeText WebStorm HBuilder VScode 有人说： 普通青年 Dreamweaver 文艺青年 sublime 高手和傻子 用记事本 其实。。。。 感觉： 这个feel 倍儿爽 feel feel倍儿爽 爽爽爽爽！ sublime有非常多的优点， 最开心的就是非常轻量级，打开速度超快，后面更高的功能，后面再接触。 sublime生成html骨架小技巧 双击打开软件 新建文件（ctrl+n） 保存（ctrl+s）,保存为：文件名.html （ 注意 后缀名必须是 .html ) 放大缩小代码 ctrl+ 加号 键 和 ctrl + 减号键 或者 按住 ctrl 在 滚动鼠标滚轮 生成页面骨架结构 html: 5 按下tab键 或者 ! 按下tab键 在浏览器中预览页面 右键在 浏览器中打开 3. 文档类型&lt;!DOCTYPE&gt;同学你用啥手机？你咋回答？ 用法： 1&lt;!DOCTYPE html&gt; 作用： 声明位于文档中的最前面的位置，处于 标签之前。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。 *注意： * 一些老网站可能用的还是老版本的文档类型比如 XHTML之类的，但是我们学的是HTML5,而且HTML5的文档类型兼容很好(向下兼容的原则)，所以大家放心的使用HTML5的文档类型就好了。 pink老师 一句话说出他们: 就是告诉浏览器按照HTML5 规范解析页面. 团队约定： 12&gt; HTML文件必须加上 DOCTYPE 声明，并统一使用 HTML5 的文档声明&gt; 4. 页面语言lang1&lt;html lang=\"en\"&gt; 指定html 语言种类 最常见的2个： en定义语言为英语 zh-CN定义语言为中文 pink老师 一句话说出他们: 指定该html标签 内容 所用的语言为中文 团队约定： 12&gt; 考虑浏览器和操作系统的兼容性，目前仍然使用 zh-CN 属性值&gt; @拓展阅读： 简单来说，可能对于程序来说没有太大的作用，但是它可以告诉浏览器，搜索引擎，一些处理Html的程序对页面语言内容来做一些对应的处理或者事情。比如可以 根据根据lang属性来设定不同语言的css样式，或者字体 告诉搜索引擎做精确的识别 让语法检查程序做语言识别 帮助翻译工具做识别 帮助网页阅读程序做识别等等 5. 字符集1&lt;meta charset=\"UTF-8\" /&gt; 123字符集(Character set)是多个字符的集合。计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。 utf-8是目前最常用的字符集编码方式，常用的字符集编码方式还有gbk和gb2312。 gb2312 简单中文 包括6763个汉字 BIG5 繁体中文 港澳台等用 GBK包含全部中文字符 是GB2312的扩展，加入对繁体字的支持，兼容GB2312 UTF-8则基本包含全世界所有国家需要用到的字符 这句代码非常关键， 是必须要写的代码，否则可能引起乱码的情况。 pink老师 一句话说出他们: 这句话是让 html 文件是以 UTF-8 编码保存的， 浏览器根据编码去解码对应的html内容。 团队约定： 12&gt; 一般情况下统一使用 &quot;UTF-8&quot; 编码, 请尽量统一写成标准的 &quot;UTF-8&quot;，不要写成 &quot;utf-8&quot; 或 &quot;utf8&quot; 或 &quot;UTF8&quot;。&gt; 6. HTML标签的语义化白话： 所谓标签语义化，就是指标签的含义。 方便代码的阅读和维护 同时让浏览器或是网络爬虫可以很好地解析，从而更好分析其中的内容 使用语义化标签会具有更好地搜索引擎优化 pink老师 一句话说出他们: 根据标签的语义，在合适的地方给一个最为合理的标签。 语义是否良好： 当我们去掉CSS之后，网页结构依然组织有序，并且有良好的可读性。( 裸奔起来一样好看 ) 遵循的原则：先确定语义的HTML ，再选合适的CSS。所以，我们接下来学习html标签，要根据语义去记忆。 HTML网页中任何元素的实现都要依靠HTML标签。 7. 拓展阅读@单身狗的由来单身狗一词最早是出自网络社区，起源与大话西游有关。 大话西游之大圣娶亲最后一幕“他好像一条狗”由来。","link":"/前端笔记/html-day02/"},{"title":"HTML-Day05","text":"第01阶段.前端基础.列表和表单 1. 列表标签（重点）学习目标 理解 无序列表的应用场景 自定义列表的应用场景 应用 无序列表语法 自定义列表语法 问？ 前面我们知道表格一般用于数据展示的，但是网页中还是有很多跟表格类似的布局，如下图~~ 我们用什么做呢？ 答： 答案是列表， 那什么是列表？ 表格是用来显示数据的，那么列表就是用来布局的。 因为非常整齐和自由 概念： 容器里面装载着结构，样式一致的文字或图表的一种形式，叫列表 特点： 列表最大的特点就是 整齐 、整洁、 有序，跟表格类似，但是他可组合自由度会更高。 1.1 无序列表 ul （重点）无序列表的各个列表项之间没有顺序级别之分，是并列的。其基本语法格式如下： 123456&lt;ul&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ......&lt;/ul&gt; 比如下面这些，新闻是没有顺序的，不用排队，先到先得，后发布先显示。 脚下留心： 1231. &lt;ul&gt;&lt;/ul&gt;中只能嵌套&lt;li&gt;&lt;/li&gt;，直接在&lt;ul&gt;&lt;/ul&gt;标签中输入其他标签或者文字的做法是不被允许的。2. &lt;li&gt;与&lt;/li&gt;之间相当于一个容器，可以容纳所有元素。3. 无序列表会带有自己样式属性，放下那个样式，一会让CSS来！ 1.2 有序列表 ol （了解） 有序列表即为有排列顺序的列表，其各个列表项按照一定的顺序排列定义，有序列表的基本语法格式如下： 123456&lt;ol&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ......&lt;/ol&gt; 所有特性基本与ul 一致。 但是实际中比 无序列表 用的少很多。 1.3 自定义列表（理解）定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。其基本语法如下： 12345678910&lt;dl&gt; &lt;dt&gt;名词1&lt;/dt&gt; &lt;dd&gt;名词1解释1&lt;/dd&gt; &lt;dd&gt;名词1解释2&lt;/dd&gt; ... &lt;dt&gt;名词2&lt;/dt&gt; &lt;dd&gt;名词2解释1&lt;/dd&gt; &lt;dd&gt;名词2解释2&lt;/dd&gt; ...&lt;/dl&gt; 用的还可以： 1.4 列表总结 标签名 定义 说明 无序标签 里面只能包含li 没有顺序，我们以后布局中最常用的列表 有序标签 里面只能包含li 有顺序， 使用情况较少 自定义列表 里面有2个兄弟， dt 和 dd 我们现在还没有学布局，现在只要保证2个点： 学会什么时候用无序列表， 学会什么时候用自定义列表 无序列表和自定义列表代码怎么写？ 具体的我们刚才看的布局，等我们学了css 在来全面布局。 2. 表单标签(掌握)目标： 能写出最常用的注册类表单 能说出input表单常见属性 现实中的表单，类似我们去银行办理信用卡填写的单子。 如下图 *作用： * 表单目的是为了收集用户信息。 在我们网页中， 我们也需要跟用户进行交互，收集用户资料，此时也需要表单。 在HTML中，一个完整的表单通常由表单控件（也称为表单元素）、提示信息和表单域3个部分构成。 *表单控件： * ​ 包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。 提示信息： ​ 一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作。 表单域： ​ 他相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。 2.1 input 控件(重点) 语法： 1&lt;input type=\"属性值\" value=\"你好\"&gt; input 输入的意思 &lt;input /&gt;标签为单标签 type属性设置不同的属性值用来指定不同的控件类型 除了type属性还有别的属性 常用属性： 1. type 属性 这个属性通过改变值，可以决定了你属于那种input表单。 比如 type = ‘text’ 就表示 文本框 可以做 用户名， 昵称等。 比如 type = ‘password’ 就是表示密码框 用户输入的内容 是不可见的。 12用户名: &lt;input type=\"text\" /&gt; 密 码：&lt;input type=\"password\" /&gt; 2. value属性 值1用户名:&lt;input type=\"text\" name=\"username\" value=\"请输入用户名\"&gt; value 默认的文本值。 有些表单想刚打开页面就默认显示几个文字，就可以通过这个value 来设置。 3. name属性1用户名:&lt;input type=\"text\" name=“username” /&gt; name表单的名字， 这样，后台可以通过这个name属性找到这个表单。 页面中的表单很多，name主要作用就是用于区别不同的表单。 name属性后面的值，是我们自己定义的。 radio 如果是一组，我们必须给他们命名相同的名字 name 这样就可以多个选其中的一个啦 12&lt;input type=\"radio\" name=\"sex\" /&gt;男&lt;input type=\"radio\" name=\"sex\" /&gt;女 name属性，我们现在用的较少， 但是，当我们学ajax 和后台的时候，是必须的。 4. checked属性 表示默认选中状态。 较常见于 单选按钮和复选按钮。 123性 别:&lt;input type=\"radio\" name=\"sex\" value=\"男\" checked=\"checked\" /&gt;男&lt;input type=\"radio\" name=\"sex\" value=\"女\" /&gt;女 上面这个，表示就默认选中了 男 这个单选按钮 5. input 属性小结 属性 说明 作用 type 表单类型 用来指定不同的控件类型 value 表单值 表单里面默认显示的文本 name 表单名字 页面中的表单很多，name主要作用就是用于区别不同的表单。 checked 默认选中 表示那个单选或者复选按钮一开始就被选中了 2.2 label标签(理解)目标： label标签主要目的是为了提高用户体验。 为用户提高最优秀的服务。 概念： label 标签为 input 元素定义标注（标签）。 作用： 用于绑定一个表单元素, 当点击label标签的时候, 被绑定的表单元素就会获得输入焦点。 如何绑定元素呢？ 第一种用法就是用label直接包括input表单。 1&lt;label&gt; 用户名： &lt;input type=\"radio\" name=\"usename\" value=\"请输入用户名\"&gt; &lt;/label&gt; 适合单个表单选择 第二种用法 for 属性规定 label 与哪个表单元素绑定。 12&lt;label for=\"sex\"&gt;男&lt;/label&gt;&lt;input type=\"radio\" name=\"sex\" id=\"sex\"&gt; pink老师 一句话说出他们: 当我们鼠标点击 label标签里面的文字时， 光标会定位到指定的表单里面 2.3 textarea控件(文本域) 语法： 123&lt;textarea &gt; 文本内容&lt;/textarea&gt; 作用： 通过textarea控件可以轻松地创建多行文本输入框. cols=”每行中的字符数” rows=”显示的行数” 我们实际开发不用 文本框和文本域区别 表单 名称 区别 默认值显示 用于场景 input type=”text” 文本框 只能显示一行文本 单标签，通过value显示默认值 用户名、昵称、密码等 textarea 文本域 可以显示多行文本 双标签，默认值写到标签中间 留言板 2.4 select下拉列表目的： 如果有多个选项让用户选择，为了节约空间，我们可以使用select控件定义下拉列表. 语法： 123456&lt;select&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option&gt;选项2&lt;/option&gt; &lt;option&gt;选项3&lt;/option&gt; ...&lt;/select&gt; 注意： &lt;select&gt; 中至少包含一对 option 在option 中定义selected =” selected “时，当前项即为默认选中项。 但是我们实际开发会用的比较少 3. form表单域 收集的用户信息怎么传递给服务器？ 通过form表单域 目的： 在HTML中，form标签被用于定义表单域，以实现用户信息的收集和传递，form中的所有内容都会被提交给服务器。 *语法: * 123&lt;form action=\"url地址\" method=\"提交方式\" name=\"表单名称\"&gt; 各种表单控件&lt;/form&gt; 常用属性： 属性 属性值 作用 action url地址 用于指定接收并处理表单数据的服务器程序的url地址。 method get/post 用于设置表单数据的提交方式，其取值为get或post。 name 名称 用于指定表单的名称，以区分同一个页面中的多个表单。 注意: 每个表单都应该有自己表单域。我们现在做页面，不写看不到效果，但是 如果后面学 ajax 后台交互的时候，必须需要 form表单域。 2.6 团队约定元素属性 元素属性值使用双引号语法 元素属性值可以写上的都写上 推荐： 12&lt;input type=\"text\" /&gt; &lt;input type=\"radio\" name=\"name\" checked=\"checked\" /&gt; 不推荐： 123&lt;input type=text /&gt; &lt;input type='text' /&gt; &lt;input type=\"radio\" name=\"name\" checked /&gt; 4.综合案例（注册页面） 5. 查文档经常查阅文档是一个非常好的学习习惯。 W3C : http://www.w3school.com.cn/ MDN: https://developer.mozilla.org/zh-CN/","link":"/前端笔记/html-day05/"},{"title":"HTML5+CSS3-Day01","text":"第02阶段.移动Web网页开发.HTML5标签 HTML5 第一天什么是 HTML5 HTML5 的概念与定义 定义：HTML5 定义了 HTML 标准的最新版本，是对 HTML 的第五次重大修改，号称下一代的 HTML 两个概念： 是一个新版本的 HTML 语言，定义了新的标签、特性和属性 拥有一个强大的技术集，这些技术集是指： HTML5 、CSS3 、javascript, 这也是广义上的 HTML5 HTML5 拓展了哪些内容 语义化标签 本地存储 兼容特性 2D、3D 动画、过渡 CSS3 特性 性能与集成 HTML5 的现状 绝对多数新的属性，都已经被浏览器所支持，最新版本的浏览器已经开始陆续支持最新的特性， 总的来说：HTML5 已经是大势所趋 HTML5 新增标签 什么是语义化 新增了那些语义化标签 header — 头部标签 nav — 导航标签 article — 内容标签 section — 块级标签 aside — 侧边栏标签 footer — 尾部标签 ![](HTML5-CSS3-Day01/yuyibq.png) 使用语义化标签的注意 语义化标签主要针对搜索引擎 新标签可以使用一次或者多次 在 IE9 浏览器中，需要把语义化标签都转换为块级元素 语义化标签，在移动端支持比较友好， 另外，HTML5 新增的了很多的语义化标签，随着课程深入，还会学习到其他的 三、多媒体音频标签 多媒体标签有两个，分别是 音频 – audio 视频 – video audio 标签说明 可以在不使用标签的情况下，也能够原生的支持音频格式文件的播放， 但是：播放格式是有限的 audio 支持的音频格式 audio 目前支持三种格式 audio 的参数 5、audio 代码演示 1234567891011&lt;body&gt; &lt;!-- 注意：在 chrome 浏览器中已经禁用了 autoplay 属性 --&gt; &lt;!-- &lt;audio src=\"./media/snow.mp3\" controls autoplay&gt;&lt;/audio&gt; --&gt; &lt;!-- 因为不同浏览器支持不同的格式，所以我们采取的方案是这个音频准备多个文件 --&gt; &lt;audio controls&gt; &lt;source src=\"./media/snow.mp3\" type=\"audio/mpeg\" /&gt; &lt;/audio&gt;&lt;/body&gt; 多媒体视频标签 video 视频标签 目前支持三种格式 语法格式 1&lt;video src=\"./media/video.mp4\" controls=\"controls\"&gt;&lt;/video&gt; video 参数 video 代码演示 123456789&lt;body&gt; &lt;!-- &lt;video src=\"./media/video.mp4\" controls=\"controls\"&gt;&lt;/video&gt; --&gt; &lt;!-- 谷歌浏览器禁用了自动播放功能，如果想自动播放，需要添加 muted 属性 --&gt; &lt;video controls=\"controls\" autoplay muted loop poster=\"./media/pig.jpg\"&gt; &lt;source src=\"./media/video.mp4\" type=\"video/mp4\"&gt; &lt;source src=\"./media/video.ogg\" type=\"video/ogg\"&gt; &lt;/video&gt;&lt;/body&gt; 多媒体标签总结 音频标签与视频标签使用基本一致 多媒体标签在不同浏览器下情况不同，存在兼容性问题 谷歌浏览器把音频和视频标签的自动播放都禁止了 谷歌浏览器中视频添加 muted 标签可以自己播放 注意：重点记住使用方法以及自动播放即可，其他属性可以在使用时查找对应的手册 新增 input 标签 新增表单属性 CSS3 属性选择器(上) 什么是 CSS3 在 CSS2 的基础上拓展、新增的样式 CSS3 发展现状 移动端支持优于 PC 端 CSS3 目前还草案，在不断改进中 CSS3 相对 H5，应用非常广泛 属性选择器列表 属性选择器代码演示 123456button { cursor: pointer;}button[disabled] { cursor: default} CSS3 属性选择器(下) 代码演示 123456789101112131415input[type=search] { color: skyblue;}span[class^=black] { color: lightgreen;}span[class$=black] { color: lightsalmon;}span[class*=black] { color: lightseagreen;} 结构伪类选择器 属性列表 代码演示 1234567891011ul li:first-child { background-color: lightseagreen;}ul li:last-child { background-color: lightcoral;}ul li:nth-child(3) { background-color: aqua;} nth-child 参数详解 nth-child 详解 注意：本质上就是选中第几个子元素 n 可以是数字、关键字、公式 n 如果是数字，就是选中第几个 常见的关键字有 even 偶数、odd 奇数 常见的公式如下(如果 n 是公式，则从 0 开始计算) 但是第 0 个元素或者超出了元素的个数会被忽略 代码演示 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;style&gt; /* 偶数 */ ul li:nth-child(even) { background-color: aquamarine; } /* 奇数 */ ul li:nth-child(odd) { background-color: blueviolet; } /*n 是公式，从 0 开始计算 */ ul li:nth-child(n) { background-color: lightcoral; } /* 偶数 */ ul li:nth-child(2n) { background-color: lightskyblue; } /* 奇数 */ ul li:nth-child(2n + 1) { background-color: lightsalmon; } /* 选择第 0 5 10 15, 应该怎么选 */ ul li:nth-child(5n) { background-color: orangered; } /* n + 5 就是从第5个开始往后选择 */ ul li:nth-child(n + 5) { background-color: peru; } /* -n + 5 前五个 */ ul li:nth-child(-n + 5) { background-color: tan; }&lt;/style&gt; nth-child 和 nt-of-type 的区别 代码演示 1234567891011121314151617&lt;style&gt; div :nth-child(1) { background-color: lightblue; } div :nth-child(2) { background-color: lightpink; } div span:nth-of-type(2) { background-color: lightseagreen; } div span:nth-of-type(3) { background-color: #fff; }&lt;/style&gt; 区别 nth-child 选择父元素里面的第几个子元素，不管是第几个类型 nt-of-type 选择指定类型的元素 十二、伪元素选择器 伪类选择器 伪类选择器注意事项 before 和 after 必须有 content 属性 before 在内容前面，after 在内容后面 before 和 after 创建的是一个元素，但是属于行内元素 创建出来的元素在 Dom 中查找不到，所以称为伪元素 伪元素和标签选择器一样，权重为 1 代码演示 123456789101112131415161718192021222324&lt;style&gt; div { width: 100px; height: 100px; border: 1px solid lightcoral; } div::after, div::before { width: 20px; height: 50px; text-align: center; display: inline-block; } div::after { content: '德'; background-color: lightskyblue; } div::before { content: '道'; background-color: mediumaquamarine; } &lt;/style&gt; 伪元素的案例 添加字体图标 1234567891011121314p { width: 220px; height: 22px; border: 1px solid lightseagreen; margin: 60px; position: relative;}p::after { content: '\\ea50'; font-family: 'icomoon'; position: absolute; top: -1px; right: 10px;} 2D 转换之 translate 2D 转换 2D 转换是改变标签在二维平面上的位置和形状 移动： translate 旋转： rotate 缩放： scale translate 语法 x 就是 x 轴上水平移动 y 就是 y 轴上水平移动 123transform: translate(x, y)transform: translateX(n)transfrom: translateY(n) 重点知识点 2D 的移动主要是指 水平、垂直方向上的移动 translate 最大的优点就是不影响其他元素的位置 translate 中的100%单位，是相对于本身的宽度和高度来进行计算的 行内标签没有效果 代码演示 1234567891011121314151617181920div { background-color: lightseagreen; width: 200px; height: 100px; /* 平移 */ /* 水平垂直移动 100px */ /* transform: translate(100px, 100px); */ /* 水平移动 100px */ /* transform: translate(100px, 0) */ /* 垂直移动 100px */ /* transform: translate(0, 100px) */ /* 水平移动 100px */ /* transform: translateX(100px); */ /* 垂直移动 100px */ transform: translateY(100px)} 让一个盒子水平垂直居中 看代码 2D 转换 rotate rotate 旋转 2D 旋转指的是让元素在二维平面内顺时针或者逆时针旋转 rotate 语法 12/* 单位是：deg */transform: rotate(度数) 重点知识点 rotate 里面跟度数，单位是 deg 角度为正时，顺时针，角度为负时，逆时针 默认旋转的中心点是元素的中心点 代码演示 123img:hover { transform: rotate(360deg)}","link":"/前端笔记/html5-css3-day01/"},{"title":"JavaScript-Day02","text":"第03阶段.JavaScript基础.运算符 JavaScript基础第02天运算符（操作符）运算符的分类运算符（operator）也被称为操作符，是用于实现赋值、比较和执行算数运算等功能的符号。 JavaScript中常用的运算符有： 算数运算符 递增和递减运算符 比较运算符 逻辑运算符 赋值运算符 算数运算符 算术运算符概述 概念：算术运算使用的符号，用于执行两个变量或值的算术运算。 浮点数的精度问题 浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。 12var result = 0.1 + 0.2; // 结果不是 0.3，而是：0.30000000000000004console.log(0.07 * 100); // 结果不是 7， 而是：7.000000000000001 所以：不要直接判断两个浮点数是否相等 ! 表达式和返回值 表达式：是由数字、运算符、变量等以能求得数值的有意义排列方法所得的组合 简单理解：是由数字、运算符、变量等组成的式子 表达式最终都会有一个结果，返回给开发者，称为返回值 递增和递减运算符 递增和递减运算符概述 如果需要反复给数字变量添加或减去1，可以使用递增（++）和递减（ – ）运算符来完成。 在 JavaScript 中，递增（++）和递减（ -- ）既可以放在变量前面，也可以放在变量后面。放在变量前面时，我们可以称为前置递增（递减）运算符，放在变量后面时，我们可以称为后置递增（递减）运算符。 注意：递增和递减运算符必须和变量配合使用。 递增运算符 前置递增运算符 ++num 前置递增，就是自加1，类似于 num = num + 1，但是 ++num 写起来更简单。 使用口诀：先自加，后返回值 12var num = 10;alert(++num + 10); // 21 后置递增运算符 num++ 后置递增，就是自加1，类似于 num = num + 1 ，但是 num++ 写起来更简单。 使用口诀：先返回原值，后自加 12var num = 10;alert(10 + num++); // 20 比较运算符 比较运算符概述 概念：比较运算符（关系运算符）是两个数据进行比较时所使用的运算符，比较运算后，会返回一个布尔值（true / false）作为比较运算的结果。 等号比较 12console.log(18 == '18');console.log(18 === '18'); 逻辑运算符 逻辑运算符概述 概念：逻辑运算符是用来进行布尔值运算的运算符，其返回值也是布尔值。后面开发中经常用于多个条件的判断 逻辑与&amp;&amp; 两边都是 true才返回 true，否则返回 false ​ ​ 逻辑或 || 两边都是 true才返回 true，否则返回 false ​ ​ 逻辑非 ！ 逻辑非（!）也叫作取反符，用来取一个布尔值相反的值，如 true 的相反值是 false 12var isOk = !true;console.log(isOk); // false 短路运算（逻辑中断） 短路运算的原理：当有多个表达式（值）时,左边的表达式值可以确定结果时,就不再继续运算右边的表达式的值; 逻辑与 语法： 表达式1 &amp;&amp; 表达式2 - 如果第一个表达式的值为真，则返回表达式2 - 如果第一个表达式的值为假，则返回表达式1123console.log( 123 &amp;&amp; 456 ); // 456console.log( 0 &amp;&amp; 456 ); // 0console.log( 123 &amp;&amp; 456&amp;&amp; 789 ); // 789 逻辑或 语法： 表达式1 || 表达式2 - 如果第一个表达式的值为真，则返回表达式1 - 如果第一个表达式的值为假，则返回表达式2 123console.log( 123 || 456 ); // 123console.log( 0 || 456 ); // 456console.log( 123 || 456 || 789 ); // 123 赋值运算符概念：用来把数据赋值给变量的运算符。 1234var age = 10;age += 5; // 相当于 age = age + 5;age -= 5; // 相当于 age = age - 5;age *= 10; // 相当于 age = age * 10; 运算符优先级 一元运算符里面的逻辑非优先级很高 逻辑与比逻辑或优先级高 流程控制流程控制概念在一个程序执行的过程中，各条代码的执行顺序对程序的结果是有直接影响的。很多时候我们要通过控制代码的执行顺序来实现我们要完成的功能。 简单理解：**流程控制就是来控制代码按照一定结构顺序来执行** 流程控制主要有三种结构，分别是**顺序结构**、**分支结构**和**循环结构**，代表三种代码执行的顺序。 顺序流程控制​ ​ 顺序结构是程序中最简单、最基本的流程控制，它没有特定的语法结构，程序会按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的。​ 分支流程控制 分支结构 由上到下执行代码的过程中，根据不同的条件，执行不同的路径代码（执行代码多选一的过程），从而得到不同的结果 ![](JavaScript-Day02/%E5%9B%BE%E7%89%8713.png) JS 语言提供了两种分支结构语句：if 语句、switch 语句 if 语句 语法结构 1234// 条件成立执行代码，否则什么也不做if (条件表达式) { // 条件成立执行的代码语句} 语句可以理解为一个行为，循环语句和分支语句就是典型的语句。一个程序由很多个语句组成，一般情况下，会分割成一个一个的语句。 执行流程 if else语句（双分支语句） 语法结构 123456// 条件成立 执行 if 里面代码，否则执行else 里面的代码if (条件表达式) { // [如果] 条件成立执行的代码} else { // [否则] 执行的代码} 执行流程 if else if 语句(多分支语句) 语法结构 1234567891011// 适合于检查多重条件。if (条件表达式1) { 语句1；} else if (条件表达式2) { 语句2；} else if (条件表达式3) { 语句3； ....} else { // 上述条件都不成立执行此处代码} 执行逻辑 三元表达式 语法结构 1表达式1 ? 表达式2 : 表达式3; 执行思路 如果表达式1为 true ，则返回表达式2的值，如果表达式1为 false，则返回表达式3的值 简单理解： 就类似于 if else （双分支） 的简写 switch分支流程控制 语法结构 switch 语句也是多分支语句，它用于基于不同的条件来执行不同的代码。当要针对变量设置一系列的特定值的选项时，就可以使用 switch。 12345678910switch( 表达式 ){ case value1: // 表达式 等于 value1 时要执行的代码 break; case value2: // 表达式 等于 value2 时要执行的代码 break; default: // 表达式 不等于任何一个 value 时要执行的代码} switch ：开关 转换 ， case ：小例子 选项 关键字 switch 后面括号内可以是表达式或值， 通常是一个变量 关键字 case , 后跟一个选项的表达式或值，后面跟一个冒号 switch 表达式的值会与结构中的 case 的值做比较 如果存在匹配全等(===) ，则与该 case 关联的代码块会被执行，并在遇到 break 时停止，整个 switch 语句代码执行结束 如果所有的 case 的值都和表达式的值不匹配，则执行 default 里的代码 注意： 执行case 里面的语句时，如果没有break，则继续执行下一个case里面的语句。 switch 语句和 if else if 语句的区别 一般情况下，它们两个语句可以相互替换 switch…case 语句通常处理 case为比较确定值的情况， 而 if…else…语句更加灵活，常用于范围判断(大于、等于某个范围) switch 语句进行条件判断后直接执行到程序的条件语句，效率更高。而if…else 语句有几种条件，就得判断多少次。 当分支比较少时，if… else语句的执行效率比 switch语句高。 当分支比较多时，switch语句的执行效率比较高，而且结构更清晰。","link":"/前端笔记/javascript-day02/"},{"title":"JavaScript-Day04","text":"第03阶段.JavaScript基础.数组 JavaScript基础第04天笔记数组数组的概念 数组可以把一组相关的数据一起存放，并提供方便的访问(获取）方式。 数组是指一组数据的集合，其中的每个数据被称作元素，在数组中可以存放任意类型的元素。数组是一种将一组数据存储在单个变量名下的优雅方式。 创建数组 JS 中创建数组有两种方式： 利用 new 创建数组 12var 数组名 = new Array() ；var arr = new Array(); // 创建一个新的空数组 注意 Array () ，A 要大写 利用数组字面量创建数组 1234//1. 使用数组字面量方式创建空的数组var 数组名 = []；//2. 使用数组字面量方式创建带初始值的数组var 数组名 = ['小白','小黑','大黄','瑞奇']; 数组的字面量是方括号 [ ] 声明数组并赋值称为数组的初始化 这种字面量方式也是我们以后最多使用的方式 数组元素的类型 数组中可以存放任意类型的数据，例如字符串，数字，布尔值等。 1var arrStus = ['小白',12,true,28.9]; 获取数组中的元素​ 索引 (下标) ：用来访问数组元素的序号（数组下标从 0 开始）。 ​ 数组可以通过索引来访问、设置、修改对应的数组元素，可以通过“数组名[索引]”的形式来获取数组中的元素。 1234// 定义数组var arrStus = [1,2,3];// 获取数组中的第2个元素alert(arrStus[1]); 注意：如果访问时数组没有和索引值对应的元素，则得到的值是undefined 遍历数组 数组遍历 ​ 把数组中的每个元素从头到尾都访问一次（类似学生的点名），可以通过 for 循环索引遍历数组中的每一项 1234var arr = ['red','green', 'blue'];for(var i = 0; i &lt; arr.length; i++){ console.log(arrStus[i]);} 数组的长度 数组的长度：默认情况下表示数组中元素的个数 使用“数组名.length”可以访问数组元素的数量（数组长度）。 12var arrStus = [1,2,3];alert(arrStus.length); // 3 注意： 此处数组的长度是数组元素的个数 ，不要和数组的索引号混淆。 当我们数组里面的元素个数发生了变化，这个 length 属性跟着一起变化 数组的length属性可以被修改： 如果设置的length属性值大于数组的元素个数，则会在数组末尾出现空白元素； 如果设置的length属性值小于数组的元素个数，则会把超过该值的数组元素删除 数组中新增元素​ 数组中可以通过以下方式在数组的末尾插入新元素： 1数组[ 数组.length ] = 新数据; 函数函数的概念​ 在 JS 里面，可能会定义非常多的相同代码或者功能相似的代码，这些代码可能需要大量重复使用。虽然 for循环语句也能实现一些简单的重复操作，但是比较具有局限性，此时我们就可以使用 JS 中的函数。 ​ 函数：就是封装了一段可被重复调用执行的代码块。通过此代码块可以实现大量代码的重复使用。 函数的使用声明函数1234// 声明函数function 函数名() { //函数体代码} function 是声明函数的关键字,必须小写 由于函数一般是为了实现某个功能才定义的， 所以通常我们将函数名命名为动词，比如 getSum 调用函数12// 调用函数函数名(); // 通过调用函数名来执行函数体代码 调用的时候千万不要忘记添加小括号 口诀：函数不调用，自己不执行 注意：声明函数本身并不会执行代码，只有调用函数时才会执行函数体代码。 函数的封装 函数的封装是把一个或者多个功能通过函数的方式封装起来，对外只提供一个简单的函数接口 简单理解：封装类似于将电脑配件整合组装到机箱中 ( 类似快递打包） 例子：封装计算1-100累加和 12345678910111213/* 计算1-100之间值的函数*/// 声明函数function getSum(){ var sumNum = 0;// 准备一个变量，保存数字和 for (var i = 1; i &lt;= 100; i++) { sumNum += i;// 把每个数值 都累加 到变量中 } alert(sumNum);}// 调用函数getSum(); 函数的参数函数参数语法 形参：函数定义时设置接收调用时传入 实参：函数调用时传入小括号内的真实数据 ​ 参数的作用 : 在函数内部某些值不能固定，我们可以通过参数在调用函数时传递不同的值进去。 函数参数的运用： 123456// 带参数的函数声明function 函数名(形参1, 形参2 , 形参3...) { // 可以定义任意多的参数，用逗号分隔 // 函数体}// 带参数的函数调用函数名(实参1, 实参2, 实参3...); 调用的时候实参值是传递给形参的 形参简单理解为：不用声明的变量 实参和形参的多个参数之间用逗号（,）分隔 函数形参和实参数量不匹配时 注意：在JavaScript中，形参的默认值是undefined。小结： 函数可以带参数也可以不带参数 声明函数的时候，函数名括号里面的是形参，形参的默认值为 undefined 调用函数的时候，函数名括号里面的是实参 多个参数中间用逗号分隔 形参的个数可以和实参个数不匹配，但是结果不可预计，我们尽量要匹配 函数的返回值return 语句返回值：函数调用整体代表的数据；函数执行完成后可以通过return语句将指定数据返回 。1234567// 声明函数function 函数名（）{ ... return 需要返回的值；}// 调用函数函数名(); // 此时调用函数就可以得到函数体内return 后面的值 在使用 return 语句时，函数会停止执行，并返回指定的值 如果函数没有 return ，返回的值是 undefined break ,continue ,return 的区别 break ：结束当前的循环体（如 for、while） continue ：跳出本次循环，继续执行下次循环（如 for、while） return ：不仅可以退出循环，还能够返回 return 语句中的值，同时还可以结束当前的函数体内的代码 arguments的使用​ 当不确定有多少个参数传递的时候，可以用 arguments 来获取。JavaScript 中，arguments实际上它是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参。arguments展示形式是一个伪数组，因此可以进行遍历。伪数组具有以下特点： 具有 length 属性 按索引方式储存数据 不具有数组的 push , pop 等方法 注意：在函数内部使用该对象，用此对象获取函数调用时传的实参。 函数案例函数内部可以调用另一个函数，在同一作用域代码中，函数名即代表封装的操作，使用函数名加括号即可以将封装的操作执行。函数的两种声明方式 自定义函数方式(命名函数) 利用函数关键字 function 自定义函数方式 1234// 声明定义方式function fn() {...}// 调用 fn(); 因为有名字，所以也被称为命名函数 调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面 函数表达式方式(匿名函数） 利用函数表达式方式的写法如下： 1234// 这是函数表达式写法，匿名函数后面跟分号结束var fn = function(){...}；// 调用的方式，函数调用必须写到函数体下面fn(); 因为函数没有名字，所以也被称为匿名函数 这个fn 里面存储的是一个函数 函数表达式方式原理跟声明变量方式是一致的 函数调用的代码必须写到函数体后面","link":"/前端笔记/javascript-day04/"},{"title":"JavaScript-Day05","text":"第03阶段.JavaScript基础.作用域 JavaScript基础第05天笔记作用域作用域概述通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突。JavaScript（es6前）中的作用域有两种： 全局作用域 局部作用域（函数作用域） 全局作用域 作用于所有代码执行的环境(整个 script 标签内部)或者一个独立的 js 文件。 局部作用域作用于函数内的代码环境，就是局部作用域。 因为跟函数有关系，所以也称为函数作用域。JS没有块级作用域 块作用域由 { } 包括。 在其他编程语言中（如 java、c#等），在 if 语句、循环语句中创建的变量，仅仅只能在本 if 语句、本循环语句中使用，如下面的Java代码： java有块级作用域： 12345if(true){ int num = 123; system.out.print(num); // 123}system.out.print(num); // 报错 以上java代码会报错，是因为代码中 { } 即一块作用域，其中声明的变量 num，在 “{ }” 之外不能使用； 而与之类似的JavaScript代码，则不会报错： Js中没有块级作用域（在ES6之前） 12345if(true){ var num = 123; console.log(123); //123}console.log(123); //123 变量的作用域在JavaScript中，根据作用域的不同，变量可以分为两种： 全局变量 局部变量 全局变量在全局作用域下声明的变量叫做全局变量（在函数外部定义的变量）。 全局变量在代码的任何位置都可以使用 在全局作用域下 var 声明的变量 是全局变量 特殊情况下，在函数内不使用 var 声明的变量也是全局变量（不建议使用） 局部变量在局部作用域下声明的变量叫做局部变量（在函数内部定义的变量） 局部变量只能在该函数内部使用 在函数内部 var 声明的变量是局部变量 函数的形参实际上就是局部变量 全局变量和局部变量的区别 全局变量：在任何一个地方都可以使用，只有在浏览器关闭时才会被销毁，因此比较占内存 局部变量：只在函数内部使用，当其所在的代码块被执行时，会被初始化；当代码块运行结束后，就会被销毁，因此更节省内存空间 作用域链只要是代码都一个作用域中，写在函数内部的局部作用域，未写在任何函数内部即在全局作用域中；如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域；根据在**[内部函数可以访问外部函数变量]**的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作作用域链 案例分析1：123456789function f1() { var num = 123; function f2() { console.log( num ); } f2();}var num = 456;f1(); 作用域链：采取就近原则的方式来查找变量最终的值。12345678910111213141516var a = 1;function fn1() { var a = 2; var b = '22'; fn2(); function fn2() { var a = 3; fn3(); function fn3() { var a = 4; console.log(a); //a的值 ? console.log(b); //b的值 ? } }}fn1(); 预解析预解析的相关概念JavaScript 代码是由浏览器中的 JavaScript 解析器来执行的。JavaScript 解析器在运行 JavaScript 代码的时候分为两步：预解析和代码执行。 预解析：在当前作用域下, JS 代码执行之前，浏览器会默认把带有 var 和 function 声明的变量在内存中进行提前声明或者定义。 代码执行： 从上到下执行JS语句。 预解析会把变量和函数的声明在代码执行之前执行完成。 变量预解析预解析也叫做变量、函数提升。 变量提升（变量预解析）： 变量的声明会被提升到当前作用域的最上面，变量的赋值不会提升。12console.log(num); // 结果是多少？var num = 10; // ？ 结果：undefined 注意：**变量提升只提升声明，不提升赋值**函数预解析函数提升： 函数的声明会被提升到当前作用域的最上面，但是不会调用函数。1234fn();function fn() { console.log('打印');} 结果：控制台打印字符串 --- ”打印“ 注意：函数声明代表函数整体，所以函数提升后，函数名代表整个函数，但是函数并没有被调用！ 函数表达式声明函数问题函数表达式创建函数，会执行变量提升，此时接收函数的变量名无法正确的调用：1234fn();var fn = function() { console.log('想不到吧');} 结果：报错提示 ”fn is not a function&quot; 解释：该段代码执行之前，会做变量声明提升，fn在提升之后的值是undefined；而fn调用是在fn被赋值为函数体之前，此时fn的值是undefined，所以无法正确调用对象对象的相关概念 什么是对象？ 在 JavaScript 中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等。 对象是由属性和方法组成的。 属性：事物的特征，在对象中用属性来表示（常用名词） 方法：事物的行为，在对象中用方法来表示（常用动词） 为什么需要对象？ 保存一个值时，可以使用变量，保存多个值（一组值）时，可以使用数组。 如果要保存一个人的完整信息呢？ 例如，将“张三疯”的个人的信息保存在数组中的方式为：1var arr = [‘张三疯’, ‘男&apos;, 128,154]; 上述例子中用数组保存数据的缺点是：数据只能通过索引值访问，开发者需要清晰的清除所有的数据的排行才能准确地获取数据，而当数据量庞大时，不可能做到记忆所有数据的索引值。 为了让更好地存储一组数据，对象应运而生：对象中为每项数据设置了属性名称，可以访问数据更语义化，数据结构清晰，表意明显，方便开发者使用。 使用对象记录上组数据为：123456var obj = { \"name\":\"张三疯\", \"sex\":\"男\", \"age\":128, \"height\":154} JS中的对象表达结构更清晰，更强大。 创建对象的三种方式 利用字面量创建对象 使用对象字面量创建对象：就是花括号 { } 里面包含了表达这个具体事物（对象）的属性和方法；{ } 里面采取键值对的形式表示 键：相当于属性名 值：相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型，函数类型等） 代码如下： 12345678var star = { name : 'pink', age : 18, sex : '男', sayHi : function(){ alert('大家好啊~'); }}; 上述代码中 star即是创建的对象。 对象的使用 对象的属性 对象中存储具体数据的 “键值对”中的 “键”称为对象的属性，即对象中存储具体数据的项 对象的方法 对象中存储函数的 “键值对”中的 “键”称为对象的方法，即对象中存储函数的项 访问对象的属性 对象里面的属性调用 : 对象.属性名 ，这个小点 . 就理解为“ 的 ” 对象里面属性的另一种调用方式 : 对象[‘属性名’]，注意方括号里面的属性必须加引号 示例代码如下： 12console.log(star.name) // 调用名字属性console.log(star['name']) // 调用名字属性 调用对象的方法 对象里面的方法调用：对象.方法名() ，注意这个方法名字后面一定加括号 示例代码如下： 1star.sayHi(); // 调用 sayHi 方法,注意，一定不要忘记带后面的括号 变量、属性、函数、方法总结 属性是对象的一部分，而变量不是对象的一部分，变量是单独存储数据的容器 变量：单独声明赋值，单独存在 属性：对象里面的变量称为属性，不需要声明，用来描述该对象的特征 方法是对象的一部分，函数不是对象的一部分，函数是单独封装操作的容器 - 函数：单独存在的，通过“函数名()”的方式就可以调用 - 方法：对象里面的函数称为方法，方法不需要声明，使用“对象.方法名()”的方式就可以调用，方法用来描述该对象的行为和功能。 利用 new Object 创建对象 创建空对象 1var andy = new Obect(); 通过内置构造函数Object创建对象，此时andy变量已经保存了创建出来的空对象 给空对象添加属性和方法 通过对象操作属性和方法的方式，来为对象增加属性和方法 示例代码如下： 123456andy.name = 'pink';andy.age = 18;andy.sex = '男';andy.sayHi = function(){ alert('大家好啊~');} 注意： Object() ：第一个字母大写 new Object() ：需要 new 关键字 使用的格式：对象.属性 = 值; 利用构造函数创建对象 构造函数 构造函数：是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。 构造函数的封装格式： 123456function 构造函数名(形参1,形参2,形参3) { this.属性名1 = 参数1; this.属性名2 = 参数2; this.属性名3 = 参数3; this.方法名 = 函数体;} 构造函数的调用格式 1var obj = new 构造函数名(实参1，实参2，实参3) 以上代码中，obj即接收到构造函数创建出来的对象。 注意事项 构造函数约定首字母大写。 函数内的属性和方法前面需要添加 this ，表示当前对象的属性和方法。 构造函数中不需要 return 返回结果。 当我们创建对象的时候，必须用 new 来调用构造函数。 其他 构造函数，如 Stars()，抽象了对象的公共部分，封装到了函数里面，它泛指某一大类（class）创建对象，如 new Stars()，特指某一个，通过 new 关键字创建对象的过程我们也称为对象实例化 new关键字的作用 在构造函数代码开始执行之前，创建一个空对象； 修改this的指向，把this指向创建出来的空对象； 执行函数的代码 在函数完成之后，返回this—即创建出来的对象 遍历对象for...in 语句用于对数组或者对象的属性进行循环操作。 其语法如下：123for (变量 in 对象名字) { // 在此执行代码} 语法中的变量是自定义的，它需要符合命名规范，通常我们会将这个变量写为 k 或者 key。1234for (var k in obj) { console.log(k); // 这里的 k 是属性名 console.log(obj[k]); // 这里的 obj[k] 是属性值}","link":"/前端笔记/javascript-day05/"},{"title":"JavaScript-Day06","text":"第03阶段.JavaScript基础.内置对象 JavaScript基础第06天笔记内置对象内置对象​ JavaScript 中的对象分为3种：自定义对象 、内置对象、 浏览器对象​ 前面两种对象是JS 基础 内容，属于 ECMAScript； 第三个浏览器对象属于 JS 独有的， JS API 讲解内置对象就是指 JS 语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是最基本而必要的功能（属性和方法），内置对象最大的优点就是帮助我们快速开发 ​ JavaScript 提供了多个内置对象：Math、 Date 、Array、String等 查文档​ 查找文档：学习一个内置对象的使用，只要学会其常用成员的使用即可，我们可以通过查文档学习，可以通过MDN/W3C来查询。​ Mozilla 开发者网络（MDN）提供了有关开放网络技术（Open Web）的信息，包括 HTML、CSS 和万维网及 HTML5 应用的 API。​ MDN:https://developer.mozilla.org/zh-CN/ Math对象​ Math 对象不是构造函数，它具有数学常数和函数的属性和方法。跟数学相关的运算（求绝对值，取整、最大值等）可以使用 Math 中的成员。 属性、方法名 功能 Math.PI 圆周率 Math.floor() 向下取整 Math.ceil() 向上取整 Math.round() 四舍五入版 就近取整 注意 -3.5 结果是 -3 Math.abs() 绝对值 Math.max()/Math.min() 求最大和最小值 Math.random() 获取范围在[0,1)内的随机值 ​ 注意：上面的方法使用时必须带括号 ​ 获取指定范围内的随机整数： 123function getRandom(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; } 日期对象​ Date 对象和 Math 对象不一样，Date是一个构造函数，所以使用时需要实例化后才能使用其中具体方法和属性。Date 实例用来处理日期和时间 使用Date实例化日期对象 获取当前时间必须实例化： 1var now = new Date(); 获取指定时间的日期对象 1var future = new Date('2019/5/1'); 注意：如果创建实例时并未传入参数，则得到的日期对象是当前时间对应的日期对象 使用Date实例的方法和属性 通过Date实例获取总毫米数 总毫秒数的含义 ​ 基于1970年1月1日（世界标准时间）起的毫秒数 获取总毫秒数 123456789// 实例化Date对象var now = new Date();// 1. 用于获取对象的原始值console.log(date.valueOf()) console.log(date.getTime()) // 2. 简单写可以这么做var now = + new Date(); // 3. HTML5中提供的方法，有兼容性问题var now = Date.now(); 数组对象创建数组的两种方式 字面量方式 示例代码如下： 1var arr = [1,\"test\",true]; new Array() 示例代码如下： 1var arr = new Array(); ​ 注意：上面代码中arr创建出的是一个空数组，如果需要使用构造函数Array创建非空数组，可以在创建数组时传入参数 ​ 参数传递规则如下： 如果只传入一个参数，则参数规定了数组的长度 如果传入了多个参数，则参数称为数组的元素 检测是否为数组 instanceof 运算符 instanceof 可以判断一个对象是否是某个构造函数的实例 1234var arr = [1, 23];var obj = {};console.log(arr instanceof Array); // trueconsole.log(obj instanceof Array); // false Array.isArray() Array.isArray()用于判断一个对象是否为数组，isArray() 是 HTML5 中提供的方法 1234var arr = [1, 23];var obj = {};console.log(Array.isArray(arr)); // trueconsole.log(Array.isArray(obj)); // false 添加删除数组元素的方法 数组中有进行增加、删除元素的方法，部分方法如下表 注意：push、unshift为增加元素方法；pop、shift为删除元素的方法 数组排序 数组中有对数组本身排序的方法，部分方法如下表 注意：sort方法需要传入参数来设置升序、降序排序 如果传入“function(a,b){ return a-b;}”，则为升序 如果传入“function(a,b){ return b-a;}”，则为降序 数组索引方法 数组中有获取数组指定元素索引值的方法，部分方法如下表 数组转换为字符串 数组中有把数组转化为字符串的方法，部分方法如下表 注意：join方法如果不传入参数，则按照 “ , ”拼接元素 其他方法 数组中还有其他操作方法，同学们可以在课下自行查阅学习 字符串对象基本包装类型​ 为了方便操作基本数据类型，JavaScript 还提供了三个特殊的引用类型：String、Number和 Boolean。 ​ 基本包装类型就是把简单数据类型包装成为复杂数据类型，这样基本数据类型就有了属性和方法。 123// 下面代码有什么问题？var str = 'andy';console.log(str.length); ​ 按道理基本数据类型是没有属性和方法的，而对象才有属性和方法，但上面代码却可以执行，这是因为 ​ js 会把基本数据类型包装为复杂数据类型，其执行过程如下 ： 123456// 1. 生成临时变量，把简单类型包装为复杂数据类型var temp = new String('andy');// 2. 赋值给我们声明的字符变量str = temp;// 3. 销毁临时变量temp = null; 字符串的不可变​ 指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间。 ​ 当重新给字符串变量赋值的时候，变量之前保存的字符串不会被修改，依然在内存中重新给字符串赋值，会重新在内存中开辟空间，这个特点就是字符串的不可变。​ 由于字符串的不可变，在大量拼接字符串的时候会有效率问题 根据字符返回位置​ 字符串通过基本包装类型可以调用部分方法来操作字符串，以下是返回指定字符的位置的方法： ​ 案例：查找字符串”abcoefoxyozzopp”中所有o出现的位置以及次数 先查找第一个o出现的位置 然后 只要indexOf 返回的结果不是 -1 就继续往后查找 因为indexOf 只能查找到第一个，所以后面的查找，利用第二个参数，当前索引加1，从而继续查找 根据位置返回字符​ 字符串通过基本包装类型可以调用部分方法来操作字符串，以下是根据位置返回指定位置上的字符： ​ 在上述方法中，charCodeAt方法返回的是指定位置上字符对应的ASCII码，ASCII码对照表如下： ​ 案例：判断一个字符串 ‘abcoefoxyozzopp’ 中出现次数最多的字符，并统计其次数 核心算法：利用 charAt(） 遍历这个字符串 把每个字符都存储给对象， 如果对象没有该属性，就为1，如果存在了就 +1 遍历对象，得到最大值和该字符 ​ 注意：在遍历的过程中，把字符串中的每个字符作为对象的属性存储在对象总，对应的属性值是该字符出现的次数 字符串操作方法​ 字符串通过基本包装类型可以调用部分方法来操作字符串，以下是部分操作方法： replace()方法​ replace() 方法用于在字符串中用一些字符替换另一些字符，其使用格式如下： 1字符串.replace(被替换的字符串， 要替换为的字符串)； split()方法​ split()方法用于切分字符串，它可以将字符串切分为数组。在切分完毕之后，返回的是一个新数组。 ​ 其使用格式如下： 1字符串.split(&quot;分割字符&quot;) 简单数据类型和复杂数据类型简单数据类型​ 简单类型（基本数据类型、值类型）：在存储时变量中存储的是值本身，包括string ，number，boolean，undefined，null 复杂数据类型​ 复杂数据类型（引用类型）：在存储时变量中存储的仅仅是地址（引用），通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等； 堆栈 堆栈空间分配区别： 1、栈（操作系统）：由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈； 简单数据类型存放到栈里面 2、堆（操作系统）：存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。 简单数据类型的存储方式 ​ 值类型变量的数据直接存放在变量（栈空间）中 复杂数据类型的存储方式 ​ 引用类型变量（栈空间）里存放的是地址，真正的对象实例存放在堆空间中 简单类型传参​ 函数的形参也可以看做是一个变量，当我们把一个值类型变量作为参数传给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到的外部变量。 1234567function fn(a) { a++; console.log(a); }var x = 10;fn(x);console.log(x)； ​ 运行结果如下： 复杂数据类型传参​ 函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。 123456789101112function Person(name) { this.name = name;}function f1(x) { // x = p console.log(x.name); // 2. 这个输出什么 ? x.name = \"张学友\"; console.log(x.name); // 3. 这个输出什么 ? }var p = new Person(\"刘德华\");console.log(p.name); // 1. 这个输出什么 ? f1(p);console.log(p.name); // 4. 这个输出什么 ? ​ 运行结果如下：","link":"/前端笔记/javascript-day06/"},{"title":"JavaScript高级-Day01","text":"第03阶段.JavaScript高级.面向对象 面向过程与面向对象面向过程 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了。 面向对象 面向对象是把事务分解成为一个个对象，然后由对象之间分工与合作。 面向过程与面向对象对比 面向过程 面向对象 优点 性能比面向对象高，适合跟硬件联系很紧密的东西，例如单片机就采用的面向过程编程。 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护 缺点 不易维护、不易复用、不易扩展 性能比面向过程低 对象与类对象对象是由属性和方法组成的：是一个无序键值对的集合,指的是一个具体的事物 属性：事物的特征，在对象中用属性来表示（常用名词） 方法：事物的行为，在对象中用方法来表示（常用动词） 创建对象123456789101112131415//以下代码是对对象的复习//字面量创建对象var ldh = { name: '刘德华', age: 18}console.log(ldh);//构造函数创建对象 function Star(name, age) { this.name = name; this.age = age; }var ldh = new Star('刘德华', 18)//实例化对象console.log(ldh); 如上两行代码运行结果为: 类 在 ES6 中新增加了类的概念，可以使用 class 关键字声明一个类，之后以这个类来实例化对象。类抽象了对象的公共部分，它泛指某一大类（class）对象特指某一个，通过类实例化一个具体的对象 创建类 语法: 123456//步骤1 使用class关键字class name { // class body} //步骤2使用定义的类创建实例 注意new关键字var xx = new name(); 示例 1234567891011// 1. 创建类 class 创建一个 明星类class Star { // 类的共有属性放到 constructor 里面 constructor(name, age) { this.name = name; this.age = age; }} // 2. 利用类创建对象 new var ldh = new Star('刘德华', 18); console.log(ldh); 以上代码运行结果: 通过结果我们可以看出,运行结果和使用构造函数方式一样 类创建添加属性和方法123456789101112131415 // 1. 创建类 class 创建一个类class Star { // 类的共有属性放到 constructor 里面 constructor是 构造器或者构造函数 constructor(uname, age) { this.uname = uname; this.age = age; }//-------------------------------------------&gt;注意,方法与方法之间不需要添加逗号 sing(song) { console.log(this.uname + '唱' + song); }}// 2. 利用类创建对象 newvar ldh = new Star('刘德华', 18);console.log(ldh); // Star {uname: \"刘德华\", age: 18}ldh.sing('冰雨'); // 刘德华唱冰雨 以上代码运行结果: 注意哟: 通过class 关键字创建类, 类名我们还是习惯性定义首字母大写 类里面有个constructor 函数,可以接受传递过来的参数,同时返回实例对象 constructor 函数 只要 new 生成实例时,就会自动调用这个函数, 如果我们不写这个函数,类也会自动生成这个函数 多个函数方法之间不需要添加逗号分隔 生成实例 new 不能省略 语法规范, 创建类 类名后面不要加小括号,生成实例 类名后面加小括号, 构造函数不需要加function 类的继承 语法 1234567// 父类class Father{ } // 子类继承父类class Son extends Father { } 示例 12345678910111213class Father { constructor(surname) { this.surname= surname; } say() { console.log('你的姓是' + this.surname); }}class Son extends Father{ // 这样子类就继承了父类的属性和方法}var damao= new Son('刘');damao.say(); //结果为 你的姓是刘 以上代码运行结果: 子类使用super关键字访问父类的方法 123456789101112131415161718//定义了父类class Father { constructor(x, y) { this.x = x; this.y = y; } sum() { console.log(this.x + this.y); } }//子元素继承父类 class Son extends Father { constructor(x, y) { super(x, y); //使用super调用了父类中的构造函数 } } var son = new Son(1, 2); son.sum(); //结果为3 注意: 继承中,如果实例化子类输出一个方法,先看子类有没有这个方法,如果有就先执行子类的 继承中,如果子类里面没有,就去查找父类有没有这个方法,如果有,就执行父类的这个方法(就近原则) 如果子类想要继承父类的方法,同时在自己内部扩展自己的方法,利用super 调用父类的构造函数,super 必须在子类this之前调用 1234567891011121314151617181920212223242526 // 父类有加法方法 class Father { constructor(x, y) { this.x = x; this.y = y; } sum() { console.log(this.x + this.y); } } // 子类继承父类加法方法 同时 扩展减法方法 class Son extends Father { constructor(x, y) { // 利用super 调用父类的构造函数 super 必须在子类this之前调用,放到this之后会报错 super(x, y); this.x = x; this.y = y; } subtract() { console.log(this.x - this.y); }}var son = new Son(5, 3);son.subtract(); //2son.sum();//8 以上代码运行结果为: 时刻注意this的指向问题,类里面的共有的属性和方法一定要加this使用. constructor中的this指向的是new出来的实例对象 自定义的方法,一般也指向的new出来的实例对象 绑定事件之后this指向的就是触发事件的事件源 在 ES6 中类没有变量提升，所以必须先定义类，才能通过类实例化对象 面向对象版tab 栏切换功能需求 点击 tab栏,可以切换效果. 点击 + 号, 可以添加 tab 项和内容项. 点击 x 号, 可以删除当前的tab项和内容项. 双击tab项文字或者内容项文字可以修改里面的文字内容 案例准备 获取到标题元素 获取到内容元素 获取到删除的小按钮 x号 新建js文件,定义类,添加需要的属性方法(切换,删除,增加,修改) 时刻注意this的指向问题 切换 为获取到的标题绑定点击事件,展示对应的内容区域,存储对应的索引 12this.lis[i].index = i;this.lis[i].onclick = this.toggleTab; 使用排他,实现只有一个元素的显示 1234567891011toggleTab() { //将所有的标题与内容类样式全部移除 for (var i = 0; i &lt; this.lis.length; i++) { this.lis[i].className = ''; this.sections[i].className = ''; } //为当前的标题添加激活样式 this.className = 'liactive'; //为当前的内容添加激活样式 that.sections[this.index].className = 'conactive'; } 添加 为添加按钮+ 绑定点击事件 1this.add.onclick = this.addTab; 实现标题与内容的添加,做好排他处理 1234567891011addTab() { that.clearClass(); // (1) 创建li元素和section元素 var random = Math.random(); var li = '&lt;li class=\"liactive\"&gt;&lt;span&gt;新选项卡&lt;/span&gt;&lt;span class=\"iconfont icon-guanbi\"&gt; &lt;/span&gt;&lt;/li&gt;'; var section = '&lt;section class=\"conactive\"&gt;测试 ' + random + '&lt;/section&gt;'; // (2) 把这两个元素追加到对应的父元素里面 that.ul.insertAdjacentHTML('beforeend', li); that.fsection.insertAdjacentHTML('beforeend', section); that.init(); } 删除 为元素的删除按钮x绑定点击事件 1this.remove[i].onclick = this.removeTab; 获取到点击的删除按钮的所在的父元素的所有,删除对应的标题与内容 123456789101112131415removeTab(e) { e.stopPropagation(); // 阻止冒泡 防止触发li 的切换点击事件 var index = this.parentNode.index; console.log(index); // 根据索引号删除对应的li 和section remove()方法可以直接删除指定的元素 that.lis[index].remove(); that.sections[index].remove(); that.init(); // 当我们删除的不是选中状态的li 的时候,原来的选中状态li保持不变 if (document.querySelector('.liactive')) return; // 当我们删除了选中状态的这个li 的时候, 让它的前一个li 处于选定状态 index--; // 手动调用我们的点击事件 不需要鼠标触发 that.lis[index] &amp;&amp; that.lis[index].click();} 编辑 为元素(标题与内容)绑定双击事件 12this.spans[i].ondblclick = this.editTab;this.sections[i].ondblclick = this.editTab; 在双击事件处理文本选中状态,修改内部DOM节点,实现新旧value值的传递 123456789101112131415161718192021editTab() { var str = this.innerHTML; // 双击禁止选定文字 window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty(); // alert(11); this.innerHTML = '&lt;input type=\"text\" /&gt;'; var input = this.children[0]; input.value = str; input.select(); // 文本框里面的文字处于选定状态 // 当我们离开文本框就把文本框里面的值给span input.onblur = function() { this.parentNode.innerHTML = this.value; }; // 按下回车也可以把文本框里面的值给span input.onkeyup = function(e) { if (e.keyCode === 13) { // 手动调用表单失去焦点事件 不需要鼠标离开操作 this.blur(); } }}","link":"/前端笔记/javascript高级-day01/"},{"title":"JavaScript高级-Day02","text":"第03阶段.JavaScript高级.构造函数和原型 构造函数和原型1对象的三种创建方式–复习 字面量方式 1var obj = {}; new关键字 1var obj = new Object(); 构造函数方式 12345function Person(name,age){ this.name = name; this.age = age;}var obj = new Person('zs',12); 静态成员和实例成员实例成员实例成员就是构造函数内部通过this添加的成员 如下列代码中uname age sing 就是实例成员,实例成员只能通过实例化的对象来访问 123456789 function Star(uname, age) { this.uname = uname; this.age = age; this.sing = function() { console.log('我会唱歌'); }}var ldh = new Star('刘德华', 18);console.log(ldh.uname);//实例成员只能通过实例化的对象来访问 静态成员静态成员 在构造函数本身上添加的成员 如下列代码中 sex 就是静态成员,静态成员只能通过构造函数来访问 12345678910 function Star(uname, age) { this.uname = uname; this.age = age; this.sing = function() { console.log('我会唱歌'); }}Star.sex = '男';var ldh = new Star('刘德华', 18);console.log(Star.sex);//静态成员只能通过构造函数来访问 构造函数的问题构造函数方法很好用，但是存在浪费内存的问题。 构造函数原型prototype构造函数通过原型分配的函数是所有对象所共享的。 JavaScript 规定，每一个构造函数都有一个prototype 属性，指向另一个对象。注意这个prototype就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。 我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。 1234567891011function Star(uname, age) { this.uname = uname; this.age = age;}Star.prototype.sing = function() { console.log('我会唱歌');}var ldh = new Star('刘德华', 18);var zxy = new Star('张学友', 19);ldh.sing();//我会唱歌zxy.sing();//我会唱歌 对象原型123对象都会有一个属性 __proto__ 指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有 __proto__ 原型的存在。__proto__对象原型和原型对象 prototype 是等价的__proto__对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象 prototype constructor构造函数123对象原型（ __proto__）和构造函数（prototype）原型对象里面都有一个属性 constructor 属性 ，constructor 我们称为构造函数，因为它指回构造函数本身。constructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor 就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。 如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数如: 1234567891011121314151617 function Star(uname, age) { this.uname = uname; this.age = age; } // 很多情况下,我们需要手动的利用constructor 这个属性指回 原来的构造函数 Star.prototype = { // 如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数 constructor: Star, // 手动设置指回原来的构造函数 sing: function() { console.log('我会唱歌'); }, movie: function() { console.log('我会演电影'); }}var zxy = new Star('张学友', 19);console.log(zxy) 以上代码运行结果,设置constructor属性如图: 如果未设置constructor属性,如图: 原型链​ 每一个实例对象又有一个proto属性，指向的构造函数的原型对象，构造函数的原型对象也是一个对象，也有proto属性，这样一层一层往上找就形成了原型链。 构造函数实例和原型对象三角关系1231.构造函数的prototype属性指向了构造函数原型对象2.实例对象是由构造函数创建的,实例对象的__proto__属性指向了构造函数的原型对象3.构造函数的原型对象的constructor属性指向了构造函数,实例对象的原型的constructor属性也指向了构造函数 原型链和成员的查找机制任何对象都有原型对象,也就是prototype属性,任何原型对象也是一个对象,该对象就有proto属性,这样一层一层往上找,就形成了一条链,我们称此为原型链; 12345当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。如果没有就查找它的原型（也就是 __proto__指向的 prototype 原型对象）。如果还没有就查找原型对象的原型（Object的原型对象）。依此类推一直找到 Object 为止（null）。__proto__对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。 原型对象中this指向构造函数中的this和原型对象的this,都指向我们new出来的实例对象 12345678910111213function Star(uname, age) { this.uname = uname; this.age = age;}var that;Star.prototype.sing = function() { console.log('我会唱歌'); that = this;}var ldh = new Star('刘德华', 18);// 1. 在构造函数中,里面this指向的是对象实例 ldhconsole.log(that === ldh);//true// 2.原型对象函数里面的this 指向的是 实例对象 ldh 通过原型为数组扩展内置方法12345678Array.prototype.sum = function() { var sum = 0; for (var i = 0; i &lt; this.length; i++) { sum += this[i]; } return sum;};//此时数组对象中已经存在sum()方法了 可以始终 数组.sum()进行数据的求 继承call() call()可以调用函数 call()可以修改this的指向,使用call()的时候 参数一是修改后的this指向,参数2,参数3..使用逗号隔开连接 12345678 function fn(x, y) { console.log(this); console.log(x + y);} var o = { name: 'andy' }; fn.call(o, 1, 2);//调用了函数此时的this指向了对象o, 子构造函数继承父构造函数中的属性 先定义一个父构造函数 再定义一个子构造函数 子构造函数继承父构造函数的属性(使用call方法) 123456789101112131415 // 1. 父构造函数 function Father(uname, age) { // this 指向父构造函数的对象实例 this.uname = uname; this.age = age; } // 2 .子构造函数 function Son(uname, age, score) { // this 指向子构造函数的对象实例 3.使用call方式实现子继承父的属性 Father.call(this, uname, age); this.score = score;}var son = new Son('刘德华', 18, 100);console.log(son); 借用原型对象继承方法 先定义一个父构造函数 再定义一个子构造函数 子构造函数继承父构造函数的属性(使用call方法) 1234567891011121314151617181920212223242526// 1. 父构造函数function Father(uname, age) { // this 指向父构造函数的对象实例 this.uname = uname; this.age = age;}Father.prototype.money = function() { console.log(100000); }; // 2 .子构造函数 function Son(uname, age, score) { // this 指向子构造函数的对象实例 Father.call(this, uname, age); this.score = score; }// Son.prototype = Father.prototype; 这样直接赋值会有问题,如果修改了子原型对象,父原型对象也会跟着一起变化 Son.prototype = new Father(); // 如果利用对象的形式修改了原型对象,别忘了利用constructor 指回原来的构造函数 Son.prototype.constructor = Son; // 这个是子构造函数专门的方法 Son.prototype.exam = function() { console.log('孩子要考试'); } var son = new Son('刘德华', 18, 100); console.log(son); 如上代码结果如图: ES5新增方法数组方法forEach遍历数组123456arr.forEach(function(value, index, array) { //参数一是:数组元素 //参数二是:数组元素的索引 //参数三是:当前的数组}) //相当于数组遍历的 for循环 没有返回值 数组方法filter过滤数组12345678var arr = [12, 66, 4, 88, 3, 7];var newArr = arr.filter(function(value, index,array) { //参数一是:数组元素 //参数二是:数组元素的索引 //参数三是:当前的数组 return value &gt;= 20;});console.log(newArr);//[66,88] //返回值是一个新数组 数组方法some123456789some 查找数组中是否有满足条件的元素 var arr = [10, 30, 4]; var flag = arr.some(function(value,index,array) { //参数一是:数组元素 //参数二是:数组元素的索引 //参数三是:当前的数组 return value &lt; 3; });console.log(flag);//false返回值是布尔值,只要查找到满足条件的一个元素就立马终止循环 筛选商品案例 定义数组对象数据 1234567891011121314151617var data = [{ id: 1, pname: '小米', price: 3999 }, { id: 2, pname: 'oppo', price: 999 }, { id: 3, pname: '荣耀', price: 1299 }, { id: 4, pname: '华为', price: 1999 }, ]; 使用forEach遍历数据并渲染到页面中 12345data.forEach(function(value) { var tr = document.createElement('tr'); tr.innerHTML = '&lt;td&gt;' + value.id + '&lt;/td&gt;&lt;td&gt;' + value.pname + '&lt;/td&gt;&lt;td&gt;' + value.price + '&lt;/td&gt;'; tbody.appendChild(tr); }); 根据价格筛选数据 获取到搜索按钮并为其绑定点击事件 12search_price.addEventListener('click', function() {}); 使用filter将用户输入的价格信息筛选出来 12345678search_price.addEventListener('click', function() { var newDate = data.filter(function(value) { //start.value是开始区间 //end.value是结束的区间 return value.price &gt;= start.value &amp;&amp; value.price &lt;= end.value; }); console.log(newDate); }); 将筛选出来的数据重新渲染到表格中 将渲染数据的逻辑封装到一个函数中 123456789function setDate(mydata) { // 先清空原来tbody 里面的数据 tbody.innerHTML = ''; mydata.forEach(function(value) { var tr = document.createElement('tr'); tr.innerHTML = '&lt;td&gt;' + value.id + '&lt;/td&gt;&lt;td&gt;' + value.pname + '&lt;/td&gt;&lt;td&gt;' + value.price + '&lt;/td&gt;'; tbody.appendChild(tr); }); } 将筛选之后的数据重新渲染 12345678 search_price.addEventListener('click', function() { var newDate = data.filter(function(value) { return value.price &gt;= start.value &amp;&amp; value.price &lt;= end.value; }); console.log(newDate); // 把筛选完之后的对象渲染到页面中 setDate(newDate);}); 根据商品名称筛选 获取用户输入的商品名称 为查询按钮绑定点击事件,将输入的商品名称与这个数据进行筛选 123456789101112 search_pro.addEventListener('click', function() { var arr = []; data.some(function(value) { if (value.pname === product.value) { // console.log(value); arr.push(value); return true; // return 后面必须写true } }); // 把拿到的数据渲染到页面中 setDate(arr);}) some和forEach区别 如果查询数组中唯一的元素, 用some方法更合适,在some 里面 遇到 return true 就是终止遍历 迭代效率更高 在forEach 里面 return 不会终止迭代 trim方法去除字符串两端的空格1234var str = ' hello 'console.log(str.trim()） //hello 去除两端空格var str1 = ' he l l o 'console.log(str.trim()） //he l l o 去除两端空格 获取对象的属性名Object.keys(对象) 获取到当前对象中的属性名 ，返回值是一个数组 12345678 var obj = { id: 1, pname: '小米', price: 1999, num: 2000};var result = Object.keys(obj)console.log(result)//[id，pname,price,num] Object.definePropertyObject.defineProperty设置或修改对象中的属性 123456Object.defineProperty(对象，修改或新增的属性名，{ value:修改或新增的属性的值, writable:true/false,//如果值为false 不允许修改这个属性值 enumerable: false,//enumerable 如果值为false 则不允许遍历 configurable: false //configurable 如果为false 则不允许删除这个属性 属性是否可以被删除或是否可以再次修改特性})","link":"/前端笔记/javascript高级-day02/"},{"title":"JavaScript高级-Day03","text":"第03阶段.JavaScript高级.this指向和闭包 函数的定义和调用函数的定义方式 方式1 函数声明方式 function 关键字 (命名函数) 1function fn(){} 方式2 函数表达式(匿名函数) 1var fn = function(){} 方式3 new Function() 12345678910var f = new Function('a', 'b', 'console.log(a + b)');f(1, 2);var fn = new Function('参数1','参数2'..., '函数体')注意/*Function 里面参数都必须是字符串格式第三种方式执行效率低，也不方便书写，因此较少使用所有函数都是 Function 的实例(对象) 函数也属于对象*/ 函数的调用1234567891011121314151617181920212223/* 1. 普通函数 */function fn() { console.log('人生的巅峰');} fn(); /* 2. 对象的方法 */var o = { sayHi: function() { console.log('人生的巅峰'); }}o.sayHi();/* 3. 构造函数*/function Star() {};new Star();/* 4. 绑定事件函数*/ btn.onclick = function() {}; // 点击了按钮就可以调用这个函数/* 5. 定时器函数*/setInterval(function() {}, 1000); 这个函数是定时器自动1秒钟调用一次/* 6. 立即执行函数(自调用函数)*/(function() { console.log('人生的巅峰');})(); this函数内部的this指向这些 this 的指向，是当我们调用函数的时候确定的。调用方式的不同决定了this 的指向不同 一般指向我们的调用者. 改变函数内部 this 指向call方法call()方法调用一个对象。简单理解为调用函数的方式，但是它可以改变函数的 this 指向 应用场景: 经常做继承. 123456789var o = { name: 'andy'} function fn(a, b) { console.log(this); console.log(a+b)};fn(1,2)// 此时的this指向的是window 运行结果为3fn.call(o,1,2)//此时的this指向的是对象o,参数使用逗号隔开,运行结果为3 以上代码运行结果为: apply方法apply() 方法调用一个函数。简单理解为调用函数的方式，但是它可以改变函数的 this 指向。 应用场景: 经常跟数组有关系 123456789var o = { name: 'andy'} function fn(a, b) { console.log(this); console.log(a+b)};fn()// 此时的this指向的是window 运行结果为3fn.apply(o,[1,2])//此时的this指向的是对象o,参数使用数组传递 运行结果为3 bind方法bind() 方法不会调用函数,但是能改变函数内部this 指向,返回的是原函数改变this之后产生的新函数 如果只是想改变 this 指向，并且不想调用这个函数的时候，可以使用bind 应用场景:不调用函数,但是还想改变this指向 12345678910 var o = { name: 'andy' };function fn(a, b) { console.log(this); console.log(a + b);};var f = fn.bind(o, 1, 2); //此处的f是bind返回的新函数f();//调用新函数 this指向的是对象o 参数使用逗号隔开 call、apply、bind三者的异同 共同点 : 都可以改变this指向 不同点: call 和 apply 会调用函数, 并且改变函数内部this指向. call 和 apply传递的参数不一样,call传递参数使用逗号隔开,apply使用数组传递 bind 不会调用函数, 可以改变函数内部this指向. 应用场景 call 经常做继承. apply经常跟数组有关系. 比如借助于数学对象实现数组最大值最小值 bind 不调用函数,但是还想改变this指向. 比如改变定时器内部的this指向. 严格模式什么是严格模式JavaScript 除了提供正常模式外，还提供了严格模式（strict mode）。ES5 的严格模式是采用具有限制性 JavaScript变体的一种方式，即在严格的条件下运行 JS 代码。 严格模式在 IE10 以上版本的浏览器中才会被支持，旧版本浏览器中会被忽略。 严格模式对正常的 JavaScript 语义做了一些更改： 1.消除了 Javascript 语法的一些不合理、不严谨之处，减少了一些怪异行为。 2.消除代码运行的一些不安全之处，保证代码运行的安全。 3.提高编译器效率，增加运行速度。 4.禁用了在 ECMAScript 的未来版本中可能会定义的一些语法，为未来新版本的 Javascript 做好铺垫。比如一些保留字如：class,enum,export, extends, import, super 不能做变量名 开启严格模式严格模式可以应用到整个脚本或个别函数中。因此在使用时，我们可以将严格模式分为为脚本开启严格模式和为函数开启严格模式两种情况。 情况一 :为脚本开启严格模式 有的 script 脚本是严格模式，有的 script 脚本是正常模式，这样不利于文件合并，所以可以将整个脚本文件放在一个立即执行的匿名函数之中。这样独立创建一个作用域而不影响其他script 脚本文件。 12345678910111213(function (){ //在当前的这个自调用函数中有开启严格模式，当前函数之外还是普通模式 \"use strict\"; var num = 10; function fn() {}})();//或者 &lt;script&gt; \"use strict\"; //当前script标签开启了严格模式&lt;/script&gt;&lt;script&gt; //当前script标签未开启严格模式&lt;/script&gt; 情况二: 为函数开启严格模式 要给某个函数开启严格模式，需要把“use strict”; (或 ‘use strict’; ) 声明放在函数体所有语句之前。 12345function fn(){ \"use strict\"; return \"123\";} //当前fn函数开启了严格模式 严格模式中的变化严格模式对 Javascript 的语法和行为，都做了一些改变。 12345678910111213141516171819202122'use strict'num = 10 console.log(num)//严格模式后使用未声明的变量--------------------------------------------------------------------------------var num2 = 1;delete num2;//严格模式不允许删除变量--------------------------------------------------------------------------------function fn() { console.log(this); // 严格模式下全局作用域中函数中的 this 是 undefined}fn(); ---------------------------------------------------------------------------------function Star() { this.sex = '男';}// Star();严格模式下,如果 构造函数不加new调用, this 指向的是undefined 如果给他赋值则 会报错.var ldh = new Star();console.log(ldh.sex);----------------------------------------------------------------------------------setTimeout(function() { console.log(this); //严格模式下，定时器 this 还是指向 window}, 2000); 更多严格模式要求参考 高阶函数高阶函数是对其他函数进行操作的函数，它接收函数作为参数或将函数作为返回值输出。 此时fn 就是一个高阶函数 函数也是一种数据类型，同样可以作为参数，传递给另外一个参数使用。最典型的就是作为回调函数。 同理函数也可以作为返回值传递回来 闭包变量的作用域复习变量根据作用域的不同分为两种：全局变量和局部变量。 函数内部可以使用全局变量。 函数外部不可以使用局部变量。 当函数执行完毕，本作用域内的局部变量会销毁。 什么是闭包闭包（closure）指有权访问另一个函数作用域中变量的函数。简单理解就是 ，一个作用域可以访问另外一个函数内部的局部变量。 闭包的作用作用：延伸变量的作用范围。 123456789 function fn() { var num = 10; function fun() { console.log(num); } return fun; }var f = fn();f(); 闭包的案例 利用闭包的方式得到当前li 的索引号 123456789for (var i = 0; i &lt; lis.length; i++) {// 利用for循环创建了4个立即执行函数// 立即执行函数也成为小闭包因为立即执行函数里面的任何一个函数都可以使用它的i这变量(function(i) { lis[i].onclick = function() { console.log(i); } })(i);} 闭包应用-3秒钟之后,打印所有li元素的内容 1234567 for (var i = 0; i &lt; lis.length; i++) { (function(i) { setTimeout(function() { console.log(lis[i].innerHTML); }, 3000) })(i);} 闭包应用-计算打车价格 12345678910111213141516171819202122232425/*需求分析打车起步价13(3公里内), 之后每多一公里增加 5块钱. 用户输入公里数就可以计算打车价格如果有拥堵情况,总价格多收取10块钱拥堵费*/ var car = (function() { var start = 13; // 起步价 局部变量 var total = 0; // 总价 局部变量 return { // 正常的总价 price: function(n) { if (n &lt;= 3) { total = start; } else { total = start + (n - 3) * 5 } return total; }, // 拥堵之后的费用 yd: function(flag) { return flag ? total + 10 : total; } } })();console.log(car.price(5)); // 23console.log(car.yd(true)); // 33 案例12345678910111213141516171819202122 var name = \"The Window\"; var object = { name: \"My Object\", getNameFunc: function() { return function() { return this.name; }; } };console.log(object.getNameFunc()())-----------------------------------------------------------------------------------var name = \"The Window\"; var object = { name: \"My Object\", getNameFunc: function() { var that = this; return function() { return that.name; }; }};console.log(object.getNameFunc()()) 递归什么是递归递归：如果一个函数在内部可以调用其本身，那么这个函数就是递归函数。简单理解:函数内部自己调用自己, 这个函数就是递归函数 注意：递归函数的作用和循环效果一样，由于递归很容易发生“栈溢出”错误（stack overflow），所以必须要加退出条件return。 利用递归求1~n的阶乘12345678//利用递归函数求1~n的阶乘 1 * 2 * 3 * 4 * ..n function fn(n) { if (n == 1) { //结束条件 return 1; } return n * fn(n - 1); } console.log(fn(3)); 利用递归求斐波那契数列12345678910// 利用递归函数求斐波那契数列(兔子序列) 1、1、2、3、5、8、13、21...// 用户输入一个数字 n 就可以求出 这个数字对应的兔子序列值// 我们只需要知道用户输入的n 的前面两项(n-1 n-2)就可以计算出n 对应的序列值function fb(n) { if (n === 1 || n === 2) { return 1; } return fb(n - 1) + fb(n - 2);}console.log(fb(3)); 利用递归遍历数据123456789101112131415161718192021222324252627282930313233343536373839404142// 我们想要做输入id号,就可以返回的数据对象 var data = [{ id: 1, name: '家电', goods: [{ id: 11, gname: '冰箱', goods: [{ id: 111, gname: '海尔' }, { id: 112, gname: '美的' }, ] }, { id: 12, gname: '洗衣机' }] }, { id: 2, name: '服饰'}];//1.利用 forEach 去遍历里面的每一个对象 function getID(json, id) { var o = {}; json.forEach(function(item) { // console.log(item); // 2个数组元素 if (item.id == id) { // console.log(item); o = item; return o; // 2. 我们想要得里层的数据 11 12 可以利用递归函数 // 里面应该有goods这个数组并且数组的长度不为 0 } else if (item.goods &amp;&amp; item.goods.length &gt; 0) { o = getID(item.goods, id); } }); return o;}","link":"/前端笔记/javascript高级-day03/"},{"title":"JavaScript高级-Day04","text":"第03阶段.JavaScript高级.正则表达式 正则表达式概述什么是正则表达式正则表达式（ Regular Expression ）是用于匹配字符串中字符组合的模式。在JavaScript中，正则表达式也是对象。 正则表通常被用来检索、替换那些符合某个模式（规则）的文本，例如验证表单：用户名表单只能输入英文字母、数字或者下划线， 昵称输入框中可以输入中文(匹配)。此外，正则表达式还常用于过滤掉页面内容中的一些敏感词(替换)，或从字符串中获取我们想要的特定部分(提取)等 。 其他语言也会使用正则表达式，本阶段我们主要是利用JavaScript 正则表达式完成表单验证。 正则表达式的特点 灵活性、逻辑性和功能性非常的强。 可以迅速地用极简单的方式达到字符串的复杂控制。 对于刚接触的人来说，比较晦涩难懂。比如：^\\w+([-+.]\\w+)@\\w+([-.]\\w+)*.\\w+([-.]\\w+)$ 实际开发,一般都是直接复制写好的正则表达式. 但是要求会使用正则表达式并且根据实际情况修改正则表达式. 比如用户名: /^[a-z0-9_-]{3,16}$/正则表达式在js中的使用 正则表达式的创建在 JavaScript 中，可以通过两种方式创建一个正则表达式。 方式一：通过调用RegExp对象的构造函数创建 12var regexp = new RegExp(/123/);console.log(regexp); 方式二：利用字面量创建 正则表达式 1var rg = /123/; 测试正则表达式test() 正则对象方法，用于检测字符串是否符合该规则，该对象会返回 true 或 false，其参数是测试字符串。 123var rg = /123/;console.log(rg.test(123));//匹配字符中是否出现123 出现结果为trueconsole.log(rg.test('abc'));//匹配字符中是否出现123 未出现结果为false 正则表达式中的特殊字符正则表达式的组成一个正则表达式可以由简单的字符构成，比如 /abc/，也可以是简单和特殊字符的组合，比如 /ab*c/ 。其中特殊字符也被称为元字符，在正则表达式中是具有特殊意义的专用符号，如 ^ 、$ 、+ 等。 特殊字符非常多，可以参考： MDN jQuery 手册：正则表达式部分 正则测试工具 边界符正则表达式中的边界符（位置符）用来提示字符所处的位置，主要有两个字符 边界符 说明 ^ 表示匹配行首的文本（以谁开始） $ 表示匹配行尾的文本（以谁结束） 如果 ^和 $ 在一起，表示必须是精确匹配。 12345678910111213141516var rg = /abc/; // 正则表达式里面不需要加引号 不管是数字型还是字符串型// /abc/ 只要包含有abc这个字符串返回的都是trueconsole.log(rg.test('abc'));console.log(rg.test('abcd'));console.log(rg.test('aabcd'));console.log('---------------------------');var reg = /^abc/;console.log(reg.test('abc')); // trueconsole.log(reg.test('abcd')); // trueconsole.log(reg.test('aabcd')); // falseconsole.log('---------------------------');var reg1 = /^abc$/; // 精确匹配 要求必须是 abc字符串才符合规范console.log(reg1.test('abc')); // trueconsole.log(reg1.test('abcd')); // falseconsole.log(reg1.test('aabcd')); // falseconsole.log(reg1.test('abcabc')); // false 字符类字符类表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内。 [] 方括号表示有一系列字符可供选择，只要匹配其中一个就可以了 1234567891011121314151617181920212223242526var rg = /[abc]/; // 只要包含有a 或者 包含有b 或者包含有c 都返回为trueconsole.log(rg.test('andy'));//trueconsole.log(rg.test('baby'));//trueconsole.log(rg.test('color'));//trueconsole.log(rg.test('red'));//falsevar rg1 = /^[abc]$/; // 三选一 只有是a 或者是 b 或者是c 这三个字母才返回 trueconsole.log(rg1.test('aa'));//falseconsole.log(rg1.test('a'));//trueconsole.log(rg1.test('b'));//trueconsole.log(rg1.test('c'));//trueconsole.log(rg1.test('abc'));//true----------------------------------------------------------------------------------var reg = /^[a-z]$/ //26个英文字母任何一个字母返回 true - 表示的是a 到z 的范围 console.log(reg.test('a'));//trueconsole.log(reg.test('z'));//trueconsole.log(reg.test('A'));//false-----------------------------------------------------------------------------------//字符组合var reg1 = /^[a-zA-Z0-9]$/; // 26个英文字母(大写和小写都可以)任何一个字母返回 true ------------------------------------------------------------------------------------//取反 方括号内部加上 ^ 表示取反，只要包含方括号内的字符，都返回 false 。var reg2 = /^[^a-zA-Z0-9]$/;console.log(reg2.test('a'));//falseconsole.log(reg2.test('B'));//falseconsole.log(reg2.test(8));//falseconsole.log(reg2.test('!'));//true 量词符量词符用来设定某个模式出现的次数。 量词 说明 * 重复0次或更多次 + 重复1次或更多次 ? 重复0次或1次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 用户名表单验证功能需求: 如果用户名输入合法, 则后面提示信息为: 用户名合法,并且颜色为绿色 如果用户名输入不合法, 则后面提示信息为: 用户名不符合规范, 并且颜色为红色 分析: 用户名只能为英文字母,数字,下划线或者短横线组成, 并且用户名长度为6~16位. 首先准备好这种正则表达式模式/$[a-zA-Z0-9-_]{6,16}^/ 当表单失去焦点就开始验证. 如果符合正则规范, 则让后面的span标签添加 right类. 如果不符合正则规范, 则让后面的span标签添加 wrong类. 123456789101112131415161718&lt;input type=\"text\" class=\"uname\"&gt; &lt;span&gt;请输入用户名&lt;/span&gt; &lt;script&gt; // 量词是设定某个模式出现的次数 var reg = /^[a-zA-Z0-9_-]{6,16}$/; // 这个模式用户只能输入英文字母 数字 下划线 中划线 var uname = document.querySelector('.uname'); var span = document.querySelector('span'); uname.onblur = function() { if (reg.test(this.value)) { console.log('正确的'); span.className = 'right'; span.innerHTML = '用户名格式输入正确'; } else { console.log('错误的'); span.className = 'wrong'; span.innerHTML = '用户名格式输入不正确'; } }&lt;/script&gt; 括号总结1.大括号 量词符. 里面表示重复次数 2.中括号 字符集合。匹配方括号中的任意字符. 3.小括号表示优先级 正则表达式在线测试 预定义类预定义类指的是某些常见模式的简写方式. 案例:验证座机号码 12var reg = /^\\d{3}-\\d{8}|\\d{4}-\\d{7}$/;var reg = /^\\d{3,4}-\\d{7,8}$/; 表单验证案例 1234567891011//手机号验证:/^1[3|4|5|7|8][0-9]{9}$/;//验证通过与不通过更换元素的类名与元素中的内容 if (reg.test(this.value)) { // console.log('正确的'); this.nextElementSibling.className = 'success'; this.nextElementSibling.innerHTML = '&lt;i class=\"success_icon\"&gt;&lt;/i&gt; 恭喜您输入正确'; } else { // console.log('不正确'); this.nextElementSibling.className = 'error'; this.nextElementSibling.innerHTML = '&lt;i class=\"error_icon\"&gt;&lt;/i&gt;格式不正确,请从新输入 '; } 12345678910111213141516//QQ号验证: /^[1-9]\\d{4,}$/; //昵称验证:/^[\\u4e00-\\u9fa5]{2,8}$///验证通过与不通过更换元素的类名与元素中的内容 ,将上一步的匹配代码进行封装,多次调用即可 function regexp(ele, reg) { ele.onblur = function() { if (reg.test(this.value)) { // console.log('正确的'); this.nextElementSibling.className = 'success'; this.nextElementSibling.innerHTML = '&lt;i class=\"success_icon\"&gt;&lt;/i&gt; 恭喜您输入正确'; } else { // console.log('不正确'); this.nextElementSibling.className = 'error'; this.nextElementSibling.innerHTML = '&lt;i class=\"error_icon\"&gt;&lt;/i&gt; 格式不正确,请从新输入 '; } } }; 12//密码验证:/^[a-zA-Z0-9_-]{6,16}$///再次输入密码只需匹配与上次输入的密码值 是否一致 正则替换replacereplace() 方法可以实现替换字符串操作，用来替换的参数可以是一个字符串或是一个正则表达式。 12345678910111213141516var str = 'andy和red';var newStr = str.replace('andy', 'baby');console.log(newStr)//baby和red//等同于 此处的andy可以写在正则表达式内var newStr2 = str.replace(/andy/, 'baby');console.log(newStr2)//baby和red//全部替换var str = 'abcabc'var nStr = str.replace(/a/,'哈哈')console.log(nStr) //哈哈bcabc//全部替换gvar nStr = str.replace(/a/a,'哈哈')console.log(nStr) //哈哈bc哈哈bc//忽略大小写ivar str = 'aAbcAba';var newStr = str.replace(/a/gi,'哈哈')//\"哈哈哈哈bc哈哈b哈哈\" 案例:过滤敏感词汇 12345678910&lt;textarea name=\"\" id=\"message\"&gt;&lt;/textarea&gt; &lt;button&gt;提交&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;script&gt; var text = document.querySelector('textarea'); var btn = document.querySelector('button'); var div = document.querySelector('div'); btn.onclick = function() { div.innerHTML = text.value.replace(/激情|gay/g, '**'); }&lt;/script&gt;","link":"/前端笔记/javascript高级-day04/"},{"title":"JavaScript高级-Day05","text":"第03阶段.JavaScript高级.ES6 ES6语法目标 能够说出使用let关键字声明变量的特点 能够使用解构赋值从数组中提取值 能够说出箭头函数拥有的特性 能够使用剩余参数接收剩余的函数参数 能够使用拓展运算符拆分数组 能够说出模板字符串拥有的特性 ES6相关概念（★★） 什么是ES6ES 的全称是 ECMAScript , 它是由 ECMA 国际标准化组织,制定的一项脚本语言的标准化规范。 为什么使用 ES6 ?每一次标准的诞生都意味着语言的完善，功能的加强。JavaScript语言本身也有一些令人不满意的地方。 变量提升特性增加了程序运行时的不可预测性 语法过于松散，实现相同的功能，不同的人可能会写出不同的代码 ES6新增语法let（★★★）ES6中新增了用于声明变量的关键字 let声明的变量只在所处于的块级有效1234 if (true) { let a = 10; }console.log(a) // a is not defined 注意：使用let关键字声明的变量才具有块级作用域，使用var声明的变量不具备块级作用域特性。 不存在变量提升12console.log(a); // a is not defined let a = 20; 暂时性死区利用let声明的变量会绑定在这个块级作用域，不会受外界的影响 12345var tmp = 123;if (true) { tmp = 'abc'; let tmp; } 经典面试题12345678var arr = [];for (var i = 0; i &lt; 2; i++) { arr[i] = function () { console.log(i); }}arr[0]();arr[1](); 经典面试题图解：此题的关键点在于变量i是全局的，函数执行时输出的都是全局作用域下的i值。 12345678let arr = [];for (let i = 0; i &lt; 2; i++) { arr[i] = function () { console.log(i); }}arr[0]();arr[1](); 经典面试题图解：此题的关键点在于每次循环都会产生一个块级作用域，每个块级作用域中的变量都是不同的，函数执行时输出的是自己上一级（循环产生的块级作用域）作用域下的i值. 小结 let关键字就是用来声明变量的 使用let关键字声明的变量具有块级作用域 在一个大括号中 使用let关键字声明的变量才具有块级作用域 var关键字是不具备这个特点的 防止循环变量变成全局变量 使用let关键字声明的变量没有变量提升 使用let关键字声明的变量具有暂时性死区特性 const（★★★）声明常量，常量就是值（内存地址）不能变化的量 具有块级作用域1234 if (true) { const a = 10; }console.log(a) // a is not defined 声明常量时必须赋值1const PI; // Missing initializer in const declaration 常量赋值后，值不能修改12345678const PI = 3.14;PI = 100; // Assignment to constant variable.const ary = [100, 200];ary[0] = 'a';ary[1] = 'b';console.log(ary); // ['a', 'b']; ary = ['a', 'b']; // Assignment to constant variable. 小结 const声明的变量是一个常量 既然是常量不能重新进行赋值，如果是基本数据类型，不能更改值，如果是复杂数据类型，不能更改地址值 声明 const时候必须要给定值 let、const、var 的区别 使用 var 声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象 使用 let 声明的变量，其作用域为该语句所在的代码块内，不存在变量提升 使用 const 声明的是常量，在后面出现的代码中不能再修改该常量的值 解构赋值（★★★）ES6中允许从数组中提取值，按照对应位置，对变量赋值，对象也可以实现解构 数组解构12345 let [a, b, c] = [1, 2, 3]; console.log(a)//1 console.log(b)//2 console.log(c)//3//如果解构不成功，变量的值为undefined 对象解构12345678let person = { name: 'zhangsan', age: 20 }; let { name, age } = person;console.log(name); // 'zhangsan' console.log(age); // 20let {name: myName, age: myAge} = person; // myName myAge 属于别名console.log(myName); // 'zhangsan' console.log(myAge); // 20 小结 解构赋值就是把数据结构分解，然后给变量进行赋值 如果结构不成功，变量跟数值个数不匹配的时候，变量的值为undefined 数组解构用中括号包裹，多个变量用逗号隔开，对象解构用花括号包裹，多个变量用逗号隔开 利用解构赋值能够让我们方便的去取对象中的属性跟方法 箭头函数（★★★）ES6中新增的定义函数的方式。 12() =&gt; {} //()：代表是函数； =&gt;：必须要的符号，指向哪一个代码块；{}：函数体const fn = () =&gt; {}//代表把一个函数赋值给fn 函数体中只有一句代码，且代码的执行结果就是返回值，可以省略大括号 12345function sum(num1, num2) { return num1 + num2; }//es6写法const sum = (num1, num2) =&gt; num1 + num2; 如果形参只有一个，可以省略小括号 12345 function fn (v) { return v; } //es6写法 const fn = v =&gt; v; 箭头函数不绑定this关键字，箭头函数中的this，指向的是函数定义位置的上下文this 123456789const obj = { name: '张三'} function fn () { console.log(this);//this 指向 是obj对象 return () =&gt; { console.log(this);//this 指向 的是箭头函数定义的位置，那么这个箭头函数定义在fn里面，而这个fn指向是的obj对象，所以这个this也指向是obj对象 } } const resFn = fn.call(obj); resFn(); 小结 箭头函数中不绑定this，箭头函数中的this指向是它所定义的位置，可以简单理解成，定义箭头函数中的作用域的this指向谁，它就指向谁 箭头函数的优点在于解决了this执行环境所造成的一些问题。比如：解决了匿名函数this指向的问题（匿名函数的执行环境具有全局性），包括setTimeout和setInterval中使用this所造成的问题 面试题12345678910var age = 100;var obj = { age: 20, say: () =&gt; { alert(this.age) }}obj.say();//箭头函数this指向的是被声明的作用域里面，而对象没有作用域的，所以箭头函数虽然在对象中被定义，但是this指向的是全局作用域 剩余参数（★★）剩余参数语法允许我们将一个不定数量的参数表示为一个数组，不定参数定义方式，这种方式很方便的去声明不知道参数情况下的一个函数 12345function sum (first, ...args) { console.log(first); // 10 console.log(args); // [20, 30] } sum(10, 20, 30) 剩余参数和解构配合使用1234let students = ['wangwu', 'zhangsan', 'lisi'];let [s1, ...s2] = students; console.log(s1); // 'wangwu' console.log(s2); // ['zhangsan', 'lisi'] ES6 的内置对象扩展Array 的扩展方法（★★）扩展运算符（展开语法）扩展运算符可以将数组或者对象转为用逗号分隔的参数序列 1234let ary = [1, 2, 3];...ary // 1, 2, 3console.log(...ary); // 1 2 3,相当于下面的代码console.log(1,2,3); 扩展运算符可以应用于合并数组123456// 方法一 let ary1 = [1, 2, 3]; let ary2 = [3, 4, 5]; let ary3 = [...ary1, ...ary2]; // 方法二 ary1.push(...ary2); 将类数组或可遍历对象转换为真正的数组12let oDivs = document.getElementsByTagName('div'); oDivs = [...oDivs]; 构造函数方法：Array.from()将伪数组或可遍历对象转换为真正的数组 123456789//定义一个集合let arrayLike = { '0': 'a', '1': 'b', '2': 'c', length: 3}; //转成数组let arr2 = Array.from(arrayLike); // ['a', 'b', 'c'] 方法还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组 123456let arrayLike = { \"0\": 1, \"1\": 2, \"length\": 2}let newAry = Array.from(arrayLike, item =&gt; item *2)//[2,4] 注意：如果是对象，那么属性需要写对应的索引 实例方法：find()用于找出第一个符合条件的数组成员，如果没有找到返回undefined 12345678let ary = [{ id: 1, name: '张三' }, { id: 2, name: '李四' }]; let target = ary.find((item, index) =&gt; item.id == 2);//找数组里面符合条件的值，当数组中元素id等于2的查找出来，注意，只会匹配第一个 实例方法：findIndex()用于找出第一个符合条件的数组成员的位置，如果没有找到返回-1 123let ary = [1, 5, 10, 15];let index = ary.findIndex((value, index) =&gt; value &gt; 9); console.log(index); // 2 实例方法：includes()判断某个数组是否包含给定的值，返回布尔值。 12[1, 2, 3].includes(2) // true [1, 2, 3].includes(4) // false String 的扩展方法模板字符串（★★★）ES6新增的创建字符串的方式，使用反引号定义 1let name = `zhangsan`; 模板字符串中可以解析变量12let name = '张三'; let sayHello = `hello,my name is ${name}`; // hello, my name is zhangsan 模板字符串中可以换行12345678910let result = { name: 'zhangsan', age: 20, sex: '男' } let html = ` &lt;div&gt; &lt;span&gt;${result.name}&lt;/span&gt; &lt;span&gt;${result.age}&lt;/span&gt; &lt;span&gt;${result.sex}&lt;/span&gt;&lt;/div&gt; `; 在模板字符串中可以调用函数12345const sayHello = function () { return '哈哈哈哈 追不到我吧 我就是这么强大'; }; let greet = `${sayHello()} 哈哈哈哈`; console.log(greet); // 哈哈哈哈 追不到我吧 我就是这么强大 哈哈哈哈 实例方法：startsWith() 和 endsWith() startsWith()：表示参数字符串是否在原字符串的头部，返回布尔值 endsWith()：表示参数字符串是否在原字符串的尾部，返回布尔值 123let str = 'Hello world!';str.startsWith('Hello') // true str.endsWith('!') // true 实例方法：repeat()repeat方法表示将原字符串重复n次，返回一个新字符串 12'x'.repeat(3) // \"xxx\" 'hello'.repeat(2) // \"hellohello\" Set 数据结构（★★）ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 Set本身是一个构造函数，用来生成 Set 数据结构 1const s = new Set(); Set函数可以接受一个数组作为参数，用来初始化。 1const set = new Set([1, 2, 3, 4, 4]);//{1, 2, 3, 4} 实例方法 add(value)：添加某个值，返回 Set 结构本身 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功 has(value)：返回一个布尔值，表示该值是否为 Set 的成员 clear()：清除所有成员，没有返回值 123456const s = new Set();s.add(1).add(2).add(3); // 向 set 结构中添加值 s.delete(2) // 删除 set 结构中的2值 s.has(1) // 表示 set 结构中是否有1这个值 返回布尔值 s.clear() // 清除 set 结构中的所有值//注意：删除的是元素的值，不是代表的索引 遍历Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。 1s.forEach(value =&gt; console.log(value))","link":"/前端笔记/javascript高级-day05/"},{"title":"Node.js-Day02","text":"第04阶段.前后端交互.模块加载及第三方包 目标 能够使用模块导入导出方法 能够使用基本的系统模块 能够使用常用的第三方包 能够说出模块的加载机制 能够知道package.json文件的作用 Node.js模块化开发JavaScript开发弊端JavaScript在使用时存在两大问题，文件依赖和命名冲突。 生活中的模块化开发) 软件中的模块化开发一个功能就是一个模块，多个模块可以组成完整应用，抽离一个模块不会影响其他功能的运行。 Node.js中模块化开发规范Node.js规定一个JavaScript文件就是一个模块，模块内部定义的变量和函数默认情况下在外部无法得到 模块内部可以使用exports对象进行成员导出， 使用require方法导入其他模块。 模块成员导出 模块成员的导入 模块成员导出的另一种方式 模块导出两种方式的联系与区别 系统模块什么是系统模块Node运行环境提供的API. 因为这些API都是以模块化的方式进行开发的, 所以我们又称Node运行环境提供的API为系统模块 系统模块fs 文件操作f：file 文件 ，s：system 系统，文件操作系统。 1const fs = require(&apos;fs&apos;); 读取文件内容 1fs.reaFile(&apos;文件路径/文件名称&apos;[,&apos;文件编码&apos;], callback); 写入文件内容 1fs.writeFile(&apos;文件路径/文件名称&apos;, &apos;数据&apos;, callback); 12345678const content = &apos;&lt;h3&gt;正在使用fs.writeFile写入文件内容&lt;/h3&gt;&apos;; fs.writeFile(&apos;../index.html&apos;, content, err =&gt; { if (err != null) { console.log(err); return; } console.log(&apos;文件写入成功&apos;); }); 系统模块path 路径操作为什么要进行路径拼接 不同操作系统的路径分隔符不统一 /public/uploads/avatar Windows 上是 \\ / Linux 上是 / 路径拼接语法 1path.join(&apos;路径&apos;, &apos;路径&apos;, ...) 123456 // 导入path模块const path = require(&apos;path&apos;); // 路径拼接let finialPath = path.join(&apos;itcast&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c.css&apos;); // 输出结果 itcast\\a\\b\\c.cssconsole.log(finialPath); 相对路径VS绝对路径 大多数情况下使用绝对路径，因为相对路径有时候相对的是命令行工具的当前工作目录 在读取文件或者设置文件路径时都会选择绝对路径 使用__dirname获取当前文件所在的绝对路径 第三方模块什么是第三方模块 别人写好的、具有特定功能的、我们能直接使用的模块即第三方模块，由于第三方模块通常都是由多个文件组成并且被放置在一个文件夹中，所以又名包。 第三方模块有两种存在形式： 以js文件的形式存在，提供实现项目具体功能的API接口。 以命令行工具形式存在，辅助项目开发 获取第三方模块npmjs.com：第三方模块的存储和分发仓库 npm (node package manager) ： node的第三方模块管理工具 下载：npm install 模块名称 卸载：npm unintall package 模块名称 全局安装与本地安装 命令行工具：全局安装 库文件：本地安装 nodemonnodemon是一个命令行工具，用以辅助项目开发。在Node.js中，每次修改文件都要在命令行工具中重新执行该文件，非常繁琐。 使用步骤 使用npm install nodemon –g 下载它 在命令行工具中用nodemon命令替代node命令执行文件 nrmnrm ( npm registry manager )：npm下载地址切换工具npm默认的下载地址在国外，国内下载速度慢 使用步骤 使用npm install nrm –g 下载它 查询可用下载地址列表 nrm ls 切换npm下载地址 nrm use 下载地址名称 Gulp基于node平台开发的前端构建工具将机械化操作编写成任务, 想要执行机械化操作时执行一个命令行命令任务就能自动执行了用机器代替手工，提高开发效率。 Gulp能做什么 项目上线，HTML、CSS、JS文件压缩合并 语法转换（es6、less …） 公共文件抽离 修改文件浏览器自动刷新 Gulp使用 使用npm install gulp下载gulp库文件 在项目根目录下建立gulpfile.js文件 重构项目的文件夹结构 src目录放置源代码文件 dist目录放置构建后文件 在gulpfile.js文件中编写任务 在命令行工具中执行gulp任务 Gulp中提供的方法 gulp.src()：获取任务要处理的文件 gulp.dest()：输出文件 gulp.task()：建立gulp任务 gulp.watch()：监控文件的变化 12345678const gulp = require(&apos;gulp&apos;); // 使用gulp.task()方法建立任务gulp.task(&apos;first&apos;, () =&gt; { // 获取要处理的文件 gulp.src(&apos;./src/css/base.css&apos;) // 将处理后的文件输出到dist目录 .pipe(gulp.dest(&apos;./dist/css&apos;));}); Gulp插件 gulp-htmlmin ：html文件压缩 gulp-csso ：压缩css gulp-babel ：JavaScript语法转化 gulp-less: less语法转化 gulp-uglify ：压缩混淆JavaScript gulp-file-include 公共文件包含 browsersync 浏览器实时同步 package.json文件node_modules文件夹的问题 文件夹以及文件过多过碎，当我们将项目整体拷贝给别人的时候,，传输速度会很慢很慢. 复杂的模块依赖关系需要被记录，确保模块的版本和当前保持一致，否则会导致当前项目运行报错 package.json文件的作用项目描述文件，记录了当前项目信息，例如项目名称、版本、作者、github地址、当前项目依赖了哪些第三方模块等。使用npm init -y命令生成。 项目依赖 在项目的开发阶段和线上运营阶段，都需要依赖的第三方包，称为项目依赖 使用npm install 包名命令下载的文件会默认被添加到 package.json 文件的 dependencies 字段中 开发依赖 在项目的开发阶段需要依赖，线上运营阶段不需要依赖的第三方包，称为开发依赖 使用npm install 包名 –save-dev命令将包添加到package.json文件的devDependencies字段中 package-lock.json文件的作用 锁定包的版本，确保再次下载时不会因为包版本不同而产生问题 加快下载速度，因为该文件中已经记录了项目所依赖第三方包的树状结构和包的下载地址，重新安装时只需下载即可，不需要做额外的工作 Node.js中模块的加载机制模块查找规则-当模块拥有路径但没有后缀时 模块查找规则-当模块没有路径且没有后缀时","link":"/前端笔记/node-js-day02/"},{"title":"Node.js-Day03","text":"第04阶段.前后端交互.请求响应原理及HTTP协议 目标 能够知道B/S软件体系结构 能够搭建Web服务器 能够使用获取GET、POST参数的方式获取参数 能够掌握如何制作路由 能够知道同步异步的概念 能够知道回调函数的概念 服务器端基础概念网站的组成 网站应用程序主要分为两大部分：客户端和服务器端。 客户端：在浏览器中运行的部分，就是用户看到并与之交互的界面程序。使用HTML、CSS、JavaScript构建。 服务器端：在服务器中运行的部分，负责存储数据和处理应用逻辑。 Node网站服务器能够提供网站访问服务的机器就是网站服务器，它能够接收客户端的请求，能够对请求做出响应。 IP地址互联网中设备的唯一标识。IP是Internet Protocol Address的简写，代表互联网协议地址. 域名由于IP地址难于记忆，所以产生了域名的概念，所谓域名就是平时上网所使用的网址。https://www.itfool.cn虽然在地址栏中输入的是网址, 但是最终还是会将域名转换为ip才能访问到指定的网站服务器。 端口端口是计算机与外界通讯交流的出口，用来区分服务器电脑中提供的不同的服务。 URL统一资源定位符，又叫URL（Uniform Resource Locator），是专为标识Internet网上资源位置而设的一种编址方式，我们平时所说的网页地址指的即是URL。 URL的组成 传输协议: //服务器IP或域名:端口/资源所在位置标识 http://www.itfool.cn/前端笔记/node-js-day03/ http：超文本传输协议，提供了一种发布和接收HTML页面的方法。 开发过程中客户端和服务器端说明在开发阶段，客户端和服务器端使用同一台电脑，即开发人员电脑。 创建web服务器123456789101112 // 引用系统模块const http = require(&apos;http&apos;); // 创建web服务器const app = http.createServer(); // 当客户端发送请求的时候app.on(&apos;request&apos;, (req, res) =&gt; { // 响应 res.end(&apos;&lt;h1&gt;hi, user&lt;/h1&gt;&apos;);}); // 监听3000端口app.listen(3000);console.log(&apos;服务器已启动，监听3000端口，请访问 localhost:3000&apos;) HTTP协议HTTP协议的概念超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）规定了如何从网站服务器传输超文本到本地浏览器，它基于客户端服务器架构工作，是客户端（用户）和服务器端（网站）请求和应答的标准。 报文在HTTP请求和响应的过程中传递的数据块就叫报文，包括要传送的数据和一些附加信息，并且要遵守规定好的格式。 请求报文1. 请求方式 （Request Method） GET 请求数据 POST 发送数据 2. 请求地址 （Request URL） 12345app.on(&apos;request&apos;, (req, res) =&gt; { req.headers // 获取请求报文 req.url // 获取请求地址 req.method // 获取请求方法}); 响应报文 1. HTTP状态码 200 请求成功 404 请求的资源没有被找到 500 服务器端错误 400 客户端请求有语法错误 2.内容类型 200 请求成功 404 请求的资源没有被找到 500 服务器端错误 400 客户端请求有语法错误 HTTP请求与响应处理请求参数客户端向服务器端发送请求时，有时需要携带一些客户信息，客户信息需要通过请求参数的形式传递到服务器端，比如登录操作。 GET请求参数 参数被放置在浏览器地址栏中，例如：http://localhost:3000/?name=zhangsan&amp;age=20 参数获取需要借助系统模块url，url模块用来处理url地址 1234567891011const http = require(&apos;http&apos;);// 导入url系统模块 用于处理url地址const url = require(&apos;url&apos;);const app = http.createServer();app.on(&apos;request&apos;, (req, res) =&gt; { // 将url路径的各个部分解析出来并返回对象 // true 代表将参数解析为对象格式 let {query} = url.parse(req.url, true); console.log(query);});app.listen(3000); POST请求参数 参数被放置在请求体中进行传输 获取POST参数需要使用data事件和end事件 使用querystring系统模块将参数转换为对象格式 1234567891011// 导入系统模块querystring 用于将HTTP参数转换为对象格式const querystring = require(&apos;querystring&apos;);app.on(&apos;request&apos;, (req, res) =&gt; { let postData = &apos;&apos;; // 监听参数传输事件 req.on(&apos;data&apos;, (chunk) =&gt; postData += chunk;); // 监听参数传输完毕事件 req.on(&apos;end&apos;, () =&gt; { console.log(querystring.parse(postData)); }); }); 路由http://localhost:3000/indexhttp://localhost:3000/login路由是指客户端请求地址与服务器端程序代码的对应关系。简单的说，就是请求什么响应什么。 123456789101112// 当客户端发来请求的时候app.on(&apos;request&apos;, (req, res) =&gt; { // 获取客户端的请求路径 let { pathname } = url.parse(req.url); if (pathname == &apos;/&apos; || pathname == &apos;/index&apos;) { res.end(&apos;欢迎来到首页&apos;); } else if (pathname == &apos;/list&apos;) { res.end(&apos;欢迎来到列表页页&apos;); } else { res.end(&apos;抱歉, 您访问的页面出游了&apos;); }}); 静态资源服务器端不需要处理，可以直接响应给客户端的资源就是静态资源，例如CSS、JavaScript、image文件。 动态资源相同的请求地址不同的响应资源，这种资源就是动态资源。 https://itfool.cn/archives/ https://itfool.cn/categories/ 客户端请求途径 Node.js异步编程同步API, 异步API12345678// 路径拼接const public = path.join(__dirname, &apos;public&apos;);// 请求地址解析const urlObj = url.parse(req.url);// 读取文件fs.readFile(&apos;./demo.txt&apos;, &apos;utf8&apos;, (err, result) =&gt; { console.log(result);}); 同步API：只有当前API执行完成后，才能继续执行下一个API 12console.log(&apos;before&apos;); console.log(&apos;after&apos;); 异步API：当前API的执行不会阻塞后续代码的执行 12345console.log(&apos;before&apos;);setTimeout( () =&gt; { console.log(&apos;last&apos;);}, 2000);console.log(&apos;after&apos;); 同步API, 异步API的区别（ 获取返回值 ）同步API可以从返回值中拿到API执行的结果, 但是异步API是不可以的 12345 // 同步function sum (n1, n2) { return n1 + n2;} const result = sum (10, 20); 1234567 // 异步function getMsg () { setTimeout(function () { return { msg: &apos;Hello Node.js&apos; } }, 2000);}const msg = getMsg (); 回调函数自己定义函数让别人去调用。 1234 // getData函数定义function getData (callback) {} // getData函数调用getData (() =&gt; {}); 使用回调函数获取异步API执行结果12345678function getMsg (callback) { setTimeout(function () { callback ({ msg: &apos;Hello Node.js&apos; }) }, 2000);}getMsg (function (msg) { console.log(msg);}); 同步API, 异步API的区别（代码执行顺序）同步API从上到下依次执行，前面代码会阻塞后面代码的执行 1234for (var i = 0; i &lt; 100000; i++) { console.log(i);}console.log(&apos;for循环后面的代码&apos;); 异步API不会等待API执行完成后再向下执行代码 1234console.log(&apos;代码开始执行&apos;); setTimeout(() =&gt; { console.log(&apos;2秒后执行的代码&apos;)}, 2000);setTimeout(() =&gt; { console.log(&apos;&quot;0秒&quot;后执行的代码&apos;)}, 0); console.log(&apos;代码结束执行&apos;); Node.js中的异步API1fs.readFile(&apos;./demo.txt&apos;, (err, result) =&gt; {}); 12var server = http.createServer();server.on(&apos;request&apos;, (req, res) =&gt; {}); 如果异步API后面代码的执行依赖当前异步API的执行结果，但实际上后续代码在执行的时候异步API还没有返回结果，这个问题要怎么解决呢？ 12fs.readFile(&apos;./demo.txt&apos;, (err, result) =&gt; {});console.log(&apos;文件读取结果&apos;); 需求：依次读取A文件、B文件、C文件 PromisePromise出现的目的是解决Node.js异步编程中回调地狱的问题。 1234567891011let promise = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { if (true) { resolve({name: &apos;张三&apos;}) }else { reject(&apos;失败了&apos;) } }, 2000);});promise.then(result =&gt; console.log(result); // {name: &apos;张三&apos;}) .catch(error =&gt; console.log(error); // 失败了) 异步函数异步函数是异步编程语法的终极解决方案，它可以让我们将异步代码写成同步的形式，让代码不再有回调函数嵌套，使代码变得清晰明了。 1const fn = async () =&gt; {}; 1async function fn () {} async关键字 普通函数定义前加async关键字 普通函数变成异步函数 异步函数默认返回promise对象 在异步函数内部使用return关键字进行结果返回 结果会被包裹的promise对象中 return关键字代替了resolve方法 在异步函数内部使用throw关键字抛出程序异常 调用异步函数再链式调用then方法获取异步函数执行结果 调用异步函数再链式调用catch方法获取异步函数执行的错误信息 await关键字 await关键字只能出现在异步函数中 await promise await后面只能写promise对象 写其他类型的API是不不可以的 await关键字可是暂停异步函数向下执行 直到promise返回结果","link":"/前端笔记/node-js-day03/"},{"title":"Node.js-Day06","text":"第04阶段.前后端交互.Express框架 目标 能够使用Express创建web服务器 能够使用Express处理请求参数 能够使用Express处理静态资源 能够使用中间件处理请求 能够在Express中集成art-template模板引擎 Express框架简介及初体验Express框架是什么Express是一个基于Node平台的web应用开发框架，它提供了一系列的强大特性，帮助你创建各种Web应用。我们可以使用 npm install express 命令进行下载。 Express框架特性 提供了方便简洁的路由定义方式 对获取HTTP请求参数进行了简化处理 对模板引擎支持程度高，方便渲染动态HTML页面 提供了中间件机制有效控制HTTP请求 拥有大量第三方中间件对功能进行扩展 原生Node.js与Express框架对比之路由1234567891011121314app.on(&apos;request&apos;, (req, res) =&gt; { // 获取客户端的请求路径 let { pathname } = url.parse(req.url); // 对请求路径进行判断 不同的路径地址响应不同的内容 if (pathname == &apos;/&apos; || pathname == &apos;index&apos;) { res.end(&apos;欢迎来到首页&apos;); } else if (pathname == &apos;/list&apos;) { res.end(&apos;欢迎来到列表页页&apos;); } else if (pathname == &apos;/about&apos;) { res.end(&apos;欢迎来到关于我们页面&apos;) } else { res.end(&apos;抱歉, 您访问的页面出游了&apos;); }}); 12345678910// 当客户端以get方式访问/时app.get(&apos;/&apos;, (req, res) =&gt; { // 对客户端做出响应 res.send(&apos;Hello Express&apos;);});// 当客户端以post方式访问/add路由时app.post(&apos;/add&apos;, (req, res) =&gt; { res.send(&apos;使用post方式请求了/add路由&apos;);}); 原生Node.js与Express框架对比之获取请求参数123456789101112app.on(&apos;request&apos;, (req, res) =&gt; { // 获取GET参数 let {query} = url.parse(req.url, true); // 获取POST参数 let postData = &apos;&apos;; req.on(&apos;data&apos;, (chunk) =&gt; { postData += chunk; }); req.on(&apos;end&apos;, () =&gt; { console.log(querystring.parse(postData) })); }); 123456789app.get(&apos;/&apos;, (req, res) =&gt; { // 获取GET参数 console.log(req.query);});app.post(&apos;/&apos;, (req, res) =&gt; { // 获取POST参数 console.log(req.body);}) Express初体验使用Express框架创建web服务器及其简单，调用express模块返回的函数即可。 1234567891011// 引入Express框架const express = require(&apos;express&apos;);// 使用框架创建web服务器const app = express();// 当客户端以get方式访问/路由时app.get(&apos;/&apos;, (req, res) =&gt; { // 对客户端做出响应 send方法会根据内容的类型自动设置请求头 res.send(&apos;Hello Express&apos;); // &lt;h2&gt;Hello Express&lt;/h2&gt; {say: &apos;hello&apos;}});// 程序监听3000端口app.listen(3000); Express中间件什么是中间件中间件就是一堆方法，可以接收客户端发来的请求、可以对请求做出响应，也可以将请求继续交给下一个中间件继续处理。 中间件主要由两部分构成，中间件方法以及请求处理函数。中间件方法由Express提供，负责拦截请求，请求处理函数由开发人员提供，负责处理请求。 12app.get(&apos;请求路径&apos;, &apos;处理函数&apos;) // 接收并处理get请求app.post(&apos;请求路径&apos;, &apos;处理函数&apos;) // 接收并处理post请求 可以针对同一个请求设置多个中间件，对同一个请求进行多次处理。默认情况下，请求从上到下依次匹配中间件，一旦匹配成功，终止匹配。可以调用next方法将请求的控制权交给下一个中间件，直到遇到结束请求的中间件。 1234567app.get(&apos;/request&apos;, (req, res, next) =&gt; { req.name = &quot;张三&quot;; next();});app.get(&apos;/request&apos;, (req, res) =&gt; { res.send(req.name);}); app.use中间件用法app.use 匹配所有的请求方式，可以直接传入请求处理函数，代表接收所有的请求。 1234app.use((req, res, next) =&gt; { console.log(req.url); next();}); app.use 第一个参数也可以传入请求地址，代表不论什么请求方式，只要是这个请求地址就接收这个请求。 1234app.use(&apos;/admin&apos;, (req, res, next) =&gt; { console.log(req.url); next();}); 中间件应用 路由保护，客户端在访问需要登录的页面时，可以先使用中间件判断用户登录状态，用户如果未登录，则拦截请求，直接响应，禁止用户进入需要登录的页面。 网站维护公告，在所有路由的最上面定义接收所有请求的中间件，直接为客户端做出响应，网站正在维护中。 自定义404页面 错误处理中间件在程序执行的过程中，不可避免的会出现一些无法预料的错误，比如文件读取失败，数据库连接失败。错误处理中间件是一个集中处理错误的地方。 123app.use((err, req, res, next) =&gt; { res.status(500).send(&apos;服务器发生未知错误&apos;);}) 当程序出现错误时，调用next()方法，并且将错误信息通过参数的形式传递给next()方法，即可触发错误处理中间件。 1234567 app.get(&quot;/&quot;, (req, res, next) =&gt; { fs.readFile(&quot;/file-does-not-exist&quot;, (err, data) =&gt; { if (err) { next(err); } });}); 捕获错误在node.js中，异步API的错误信息都是通过回调函数获取的，支持Promise对象的异步API发生错误可以通过catch方法捕获。异步函数执行如果发生错误要如何捕获错误呢？ try catch 可以捕获异步函数以及其他同步代码在执行过程中发生的错误，但是不能其他类型的API发生的错误。 1234567app.get(&quot;/&quot;, async (req, res, next) =&gt; { try { await User.find({name: &apos;张三&apos;}) }catch(ex) { next(ex); }}); Express框架请求处理构建模块化路由12345678910const express = require(&apos;express&apos;) // 创建路由对象const home = express.Router();// 将路由和请求路径进行匹配app.use(&apos;/home&apos;, home); // 在home路由下继续创建路由home.get(&apos;/index&apos;, () =&gt; { // /home/index res.send(&apos;欢迎来到博客展示页面&apos;);}); 构建模块化路由123456// home.jsconst home = express.Router(); home.get(&apos;/index&apos;, () =&gt; { res.send(&apos;欢迎来到博客展示页面&apos;);});module.exports = home; 123456// admin.jsconst admin = express.Router();admin.get(&apos;/index&apos;, () =&gt; { res.send(&apos;欢迎来到博客管理页面&apos;);});module.exports = admin; 12345// app.jsconst home = require(&apos;./route/home.js&apos;);const admin = require(&apos;./route/admin.js&apos;);app.use(&apos;/home&apos;, home);app.use(&apos;/admin&apos;, admin); GET参数的获取Express框架中使用req.query即可获取GET参数，框架内部会将GET参数转换为对象并返回。 12345// 接收地址栏中问号后面的参数// 例如: http://localhost:3000/?name=zhangsan&amp;age=30app.get(&apos;/&apos;, (req, res) =&gt; { console.log(req.query); // {&quot;name&quot;: &quot;zhangsan&quot;, &quot;age&quot;: &quot;30&quot;}}); POST参数的获取Express中接收post请求参数需要借助第三方包 body-parser。 123456789// 引入body-parser模块const bodyParser = require(&apos;body-parser&apos;);// 配置body-parser模块app.use(bodyParser.urlencoded({ extended: false }));// 接收请求app.post(&apos;/add&apos;, (req, res) =&gt; { // 接收请求参数 console.log(req.body);}) Express路由参数123app.get(&apos;/find/:id&apos;, (req, res) =&gt; { console.log(req.params); // {id: 123} }); 1localhost:3000/find/123 静态资源的处理通过Express内置的express.static可以方便地托管静态文件，例如img、CSS、JavaScript 文件等。 1app.use(express.static(&apos;public&apos;)); 现在，public 目录下面的文件就可以访问了。 http://localhost:3000/images/kitten.jpg http://localhost:3000/css/style.css http://localhost:3000/js/app.js http://localhost:3000/images/bg.png http://localhost:3000/hello.html express-art-template模板引擎模板引擎 为了使art-template模板引擎能够更好的和Express框架配合，模板引擎官方在原art-template模板引擎的基础上封装了express-art-template。 使用npm install art-template express-art-template命令进行安装。 12345678910 // 当渲染后缀为art的模板时 使用express-art-templateapp.engine(&apos;art&apos;, require(&apos;express-art-template&apos;)); // 设置模板存放目录app.set(&apos;views&apos;, path.join(__dirname, &apos;views&apos;)); // 渲染模板时不写后缀 默认拼接art后缀app.set(&apos;view engine&apos;, &apos;art&apos;);app.get(&apos;/&apos;, (req, res) =&gt; { // 渲染模板 res.render(&apos;index&apos;);}); app.locals 对象将变量设置到app.locals对象下面，这个数据在所有的模板中都可以获取到。 1234567 app.locals.users = [{ name: &apos;张三&apos;, age: 20 },{ name: &apos;李四&apos;, age: 20}]","link":"/前端笔记/node-js-day06/"},{"title":"WebAPIs-Day02","text":"第03阶段.JavaScript基础.排他思想 学习目标： 能够说出排他操作的一般实现步骤 能够使用html5中的dataset方式操作自定义属性 能够根据提示完成百度换肤的案例 能够根据提示完成全选案例 能够根据提示完成tab栏切换案例 能够区分元素节点、文本节点、属性节点 能够获取指定元素的父元素 能够获取指定元素的所有子元素 能够说出childNodes和children的区别 能够使用createElement创建页面元素 排他操作排他思想 如果有同一组元素，我们想要某一个元素实现某种样式， 需要用到循环的排他思想算法： 所有元素全部清除样式（干掉其他人） 给当前元素设置样式 （留下我自己） 注意顺序不能颠倒，首先干掉其他人，再设置自己 123456789101112131415161718192021&lt;button&gt;按钮1&lt;/button&gt;&lt;button&gt;按钮2&lt;/button&gt;&lt;button&gt;按钮3&lt;/button&gt;&lt;button&gt;按钮4&lt;/button&gt;&lt;button&gt;按钮5&lt;/button&gt;&lt;script&gt; // 1. 获取所有按钮元素 var btns = document.getElementsByTagName('button'); // btns得到的是伪数组 里面的每一个元素 btns[i] for (var i = 0; i &lt; btns.length; i++) { btns[i].onclick = function() { // (1) 我们先把所有的按钮背景颜色去掉 干掉所有人 for (var i = 0; i &lt; btns.length; i++) { btns[i].style.backgroundColor = ''; } // (2) 然后才让当前的元素背景颜色为pink 留下我自己 this.style.backgroundColor = 'pink'; } }&lt;/script&gt; 案例：百度换肤 12345678910111213141516171819202122&lt;body&gt; &lt;ul class=\"baidu\"&gt; &lt;li&gt;&lt;img src=\"images/1.jpg\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/2.jpg\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/3.jpg\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/4.jpg\"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // 1. 获取元素 var imgs = document.querySelector('.baidu').querySelectorAll('img'); // console.log(imgs); // 2. 循环注册事件 for (var i = 0; i &lt; imgs.length; i++) { imgs[i].onclick = function() { // this.src 就是我们点击图片的路径 images/2.jpg // console.log(this.src); // 把这个路径 this.src 给body 就可以了 document.body.style.backgroundImage = 'url(' + this.src + ')'; } } &lt;/script&gt;&lt;/body&gt; 案例：表格隔行变色 12345678910111213141516&lt;script&gt; // 1.获取元素 获取的是 tbody 里面所有的行 var trs = document.querySelector('tbody').querySelectorAll('tr'); // 2. 利用循环绑定注册事件 for (var i = 0; i &lt; trs.length; i++) { // 3. 鼠标经过事件 onmouseover trs[i].onmouseover = function() { // console.log(11); this.className = 'bg'; } // 4. 鼠标离开事件 onmouseout trs[i].onmouseout = function() { this.className = ''; } }&lt;/script&gt; 案例：全选 12345678910111213141516171819202122232425262728293031&lt;script&gt; // 1. 全选和取消全选做法： 让下面所有复选框的checked属性（选中状态） 跟随 全选按钮即可 // 获取元素 var j_cbAll = document.getElementById('j_cbAll'); var j_tbs = document.getElementById('j_tb').getElementsByTagName('input'); // 全选按钮注册事件 j_cbAll.onclick = function() { // this.checked 当前复选框的选中状态 console.log(this.checked); for (var i = 0; i &lt; j_tbs.length; i++) { j_tbs[i].checked = this.checked; } } // 给所有的子复选框注册单击事件 for (var i = 0; i &lt; j_tbs.length; i++) { j_tbs[i].onclick = function() { // flag 控制全选按钮是否选中 var flag = true; // 每次点击下面的复选框都要循环检查者4个小按钮是否全被选中 for (var i = 0; i &lt; j_tbs.length; i++) { if (!j_tbs[i].checked) { flag = false; break; } } // 设置全选按钮的状态 j_cbAll.checked = flag; } }&lt;/script&gt; 自定义属性操作获取属性值 12345678910 &lt;div id=\"demo\" index=\"1\" class=\"nav\"&gt;&lt;/div&gt; &lt;script&gt; var div = document.querySelector('div'); // 1. 获取元素的属性值 // (1) element.属性 console.log(div.id); //(2) element.getAttribute('属性') get得到获取 attribute 属性的意思 我们程序员自己添加的属性我们称为自定义属性 index console.log(div.getAttribute('id')); console.log(div.getAttribute('index'));&lt;/script&gt; 设置属性值 1234567// 2. 设置元素属性值// (1) element.属性= '值'div.id = 'test';div.className = 'navs';// (2) element.setAttribute('属性', '值'); 主要针对于自定义属性div.setAttribute('index', 2);div.setAttribute('class', 'footer'); // class 特殊 这里面写的就是 移出属性 123// class 不是className // 3 移除属性 removeAttribute(属性) div.removeAttribute('index'); 案例：tab栏 1234567891011121314151617181920212223242526272829&lt;script&gt; // 获取元素 var tab_list = document.querySelector('.tab_list'); var lis = tab_list.querySelectorAll('li'); var items = document.querySelectorAll('.item'); // for循环，给选项卡绑定点击事件 for (var i = 0; i &lt; lis.length; i++) { // 开始给5个小li 设置索引号 lis[i].setAttribute('index', i); lis[i].onclick = function() { // 1. 上的模块选项卡，当前这一个底色会是红色，其余不变（排他思想） // 干掉所有人 其余的li清除 class 这个类 for (var i = 0; i &lt; lis.length; i++) { lis[i].className = ''; } // 留下我自己 this.className = 'current'; // 2. 下面的显示内容模块 var index = this.getAttribute('index'); console.log(index); // 干掉所有人 让其余的item 这些div 隐藏 for (var i = 0; i &lt; items.length; i++) { items[i].style.display = 'none'; } // 留下我自己 让对应的item 显示出来 items[index].style.display = 'block'; } }&lt;/script&gt; H5自定义属性自定义属性目的：是为了保存并使用数据。有些数据可以保存到页面中而不用保存到数据库中。 自定义属性获取是通过getAttribute(‘属性’) 获取。 但是有些自定义属性很容易引起歧义，不容易判断是元素的内置属性还是自定义属性。 H5给我们新增了自定义属性： 1234567891011121314151617&lt;div getTime=\"20\" data-index=\"2\" data-list-name=\"andy\"&gt;&lt;/div&gt;&lt;script&gt; var div = document.querySelector('div'); // console.log(div.getTime); console.log(div.getAttribute('getTime')); div.setAttribute('data-time', 20); console.log(div.getAttribute('data-index')); console.log(div.getAttribute('data-list-name')); // h5新增的获取自定义属性的方法 它只能获取data-开头的 // dataset 是一个集合里面存放了所有以data开头的自定义属性 console.log(div.dataset); console.log(div.dataset.index); console.log(div.dataset['index']); // 如果自定义属性里面有多个-链接的单词，我们获取的时候采取 驼峰命名法 console.log(div.dataset.listName); console.log(div.dataset['listName']);&lt;/script&gt; 节点操作节点概述​ 网页中的所有内容都是节点（标签、属性、文本、注释等），在DOM 中，节点使用 node 来表示。 ​ HTML DOM 树中的所有节点均可通过 JavaScript 进行访问，所有 HTML 元素（节点）均可被修改，也可以创建或删除。 ​ 一般地，节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个基本属性。 节点层级​ 利用 DOM 树可以把节点划分为不同的层级关系，常见的是父子兄层级关系。 ​ 父级节点 123456789101112&lt;div class=\"demo\"&gt; &lt;div class=\"box\"&gt; &lt;span class=\"erweima\"&gt;×&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; // 1. 父节点 parentNode var erweima = document.querySelector('.erweima'); // var box = document.querySelector('.box'); // 得到的是离元素最近的父级节点(亲爸爸) 如果找不到父节点就返回为 null console.log(erweima.parentNode);&lt;/script&gt; 子节点所有子节点 子元素节点 1234567891011121314151617&lt;ul&gt; &lt;li&gt;我是li&lt;/li&gt; &lt;li&gt;我是li&lt;/li&gt; &lt;li&gt;我是li&lt;/li&gt; &lt;li&gt;我是li&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; // DOM 提供的方法（API）获取 var ul = document.querySelector('ul'); var lis = ul.querySelectorAll('li'); // 1. 子节点 childNodes 所有的子节点 包含 元素节点 文本节点等等 console.log(ul.childNodes); console.log(ul.childNodes[0].nodeType); console.log(ul.childNodes[1].nodeType); // 2. children 获取所有的子元素节点 也是我们实际开发常用的 console.log(ul.children);&lt;/script&gt; 第1个子节点 最后1个子节点 第1个子元素节点 最后1个子元素节点 ​ 实际开发中，firstChild 和 lastChild 包含其他节点，操作不方便，而 firstElementChild 和 lastElementChild 又有兼容性问题，那么我们如何获取第一个子元素节点或最后一个子元素节点呢？ 12345678910111213141516171819&lt;ol&gt; &lt;li&gt;我是li1&lt;/li&gt; &lt;li&gt;我是li2&lt;/li&gt; &lt;li&gt;我是li3&lt;/li&gt; &lt;li&gt;我是li4&lt;/li&gt; &lt;li&gt;我是li5&lt;/li&gt;&lt;/ol&gt;&lt;script&gt; var ol = document.querySelector('ol'); // 1. firstChild 第一个子节点 不管是文本节点还是元素节点 console.log(ol.firstChild); console.log(ol.lastChild); // 2. firstElementChild 返回第一个子元素节点 ie9才支持 console.log(ol.firstElementChild); console.log(ol.lastElementChild); // 3. 实际开发的写法 既没有兼容性问题又返回第一个子元素 console.log(ol.children[0]); console.log(ol.children[ol.children.length - 1]);&lt;/script&gt; 案例：新浪下拉菜单 1234567891011121314&lt;script&gt; // 1. 获取元素 var nav = document.querySelector('.nav'); var lis = nav.children; // 得到4个小li // 2.循环注册事件 for (var i = 0; i &lt; lis.length; i++) { lis[i].onmouseover = function() { this.children[1].style.display = 'block'; } lis[i].onmouseout = function() { this.children[1].style.display = 'none'; } }&lt;/script&gt; 兄弟节点下一个兄弟节点 上一个兄弟节点 1234567891011&lt;div&gt;我是div&lt;/div&gt;&lt;span&gt;我是span&lt;/span&gt;&lt;script&gt; var div = document.querySelector('div'); // 1.nextSibling 下一个兄弟节点 包含元素节点或者 文本节点等等 console.log(div.nextSibling); console.log(div.previousSibling); // 2. nextElementSibling 得到下一个兄弟元素节点 console.log(div.nextElementSibling); console.log(div.previousElementSibling);&lt;/script&gt; 下一个兄弟元素节点（有兼容性问题） 上一个兄弟元素节点（有兼容性问题） 123456789function getNextElementSibling(element) { var el = element; while (el = el.nextSibling) { if (el.nodeType === 1) { return el; } } return null; } 创建节点 添加节点 1234567891011121314&lt;ul&gt; &lt;li&gt;123&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; // 1. 创建节点元素节点 var li = document.createElement('li'); // 2. 添加节点 node.appendChild(child) node 父级 child 是子级 后面追加元素 var ul = document.querySelector('ul'); ul.appendChild(li); // 3. 添加节点 node.insertBefore(child, 指定元素); var lili = document.createElement('li'); ul.insertBefore(lili, ul.children[0]); // 4. 我们想要页面添加一个新的元素 ： 1. 创建元素 2. 添加元素&lt;/script&gt; 案例：简单版发布留言 1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;textarea name=\"\" id=\"\"&gt;&lt;/textarea&gt; &lt;button&gt;发布&lt;/button&gt; &lt;ul&gt; &lt;/ul&gt; &lt;script&gt; // 1. 获取元素 var btn = document.querySelector('button'); var text = document.querySelector('textarea'); var ul = document.querySelector('ul'); // 2. 注册事件 btn.onclick = function() { if (text.value == '') { alert('您没有输入内容'); return false; } else { // console.log(text.value); // (1) 创建元素 var li = document.createElement('li'); // 先有li 才能赋值 li.innerHTML = text.value; // (2) 添加元素 // ul.appendChild(li); ul.insertBefore(li, ul.children[0]); } } &lt;/script&gt;&lt;/body&gt;","link":"/前端笔记/webapis-day02/"},{"title":"WebAPIs-Day05","text":"第03阶段.JavaScript基础.偏移 学习目标: 能够说出常见 offset 系列属性的作用 能够说出常见 client 系列属性的作用 能够说出常见 scroll 系列属性的作用 能够封装简单动画函数 元素偏移量 offset 系列offset 概述offset 翻译过来就是偏移量， 我们使用 offset系列相关属性可以动态的得到该元素的位置（偏移）、大小等。 获得元素距离带有定位父元素的位置 获得元素自身的大小（宽度高度） 注意：返回的数值都不带单位 offset 与 style 区别offset offset 可以得到任意样式表中的样式值 offset 系列获得的数值是没有单位的 offsetWidth 包含padding+border+width offsetWidth 等属性是只读属性，只能获取不能赋值 所以，我们想要获取元素大小位置，用offset更合适 style style 只能得到行内样式表中的样式值 style.width 获得的是带有单位的字符串 style.width 获得不包含padding和border 的值 style.width 是可读写属性，可以获取也可以赋值 所以，我们想要给元素更改值，则需要用style改变 因为平时我们都是给元素注册触摸事件，所以重点记住 targetTocuhes 案例：获取鼠标在盒子内的坐标 我们在盒子内点击，想要得到鼠标距离盒子左右的距离。 首先得到鼠标在页面中的坐标（e.pageX, e.pageY） 其次得到盒子在页面中的距离 ( box.offsetLeft, box.offsetTop) 用鼠标距离页面的坐标减去盒子在页面中的距离，得到 鼠标在盒子内的坐标 如果想要移动一下鼠标，就要获取最新的坐标，使用鼠标移动 123456var box = document.querySelector('.box');box.addEventListener('mousemove', function(e) {var x = e.pageX - this.offsetLeft;var y = e.pageY - this.offsetTop;this.innerHTML = 'x坐标是' + x + ' y坐标是' + y;}) 案例：模态框拖拽弹出框，我们也称为模态框。 ​ 1.点击弹出层，会弹出模态框， 并且显示灰色半透明的遮挡层。 ​ 2.点击关闭按钮，可以关闭模态框，并且同时关闭灰色半透明遮挡层。 ​ 3.鼠标放到模态框最上面一行，可以按住鼠标拖拽模态框在页面中移动。 ​ 4.鼠标松开，可以停止拖动模态框移动 案例分析: 点击弹出层， 模态框和遮挡层就会显示出来 display:block; 点击关闭按钮，模态框和遮挡层就会隐藏起来 display:none; 在页面中拖拽的原理：鼠标按下并且移动， 之后松开鼠标 触发事件是鼠标按下mousedown，鼠标移动mousemove 鼠标松开 mouseup 拖拽过程: 鼠标移动过程中，获得最新的值赋值给模态框的left和top值，这样模态框可以跟着鼠标走了 鼠标按下触发的事件源是最上面一行，就是 id 为 title 鼠标的坐标减去 鼠标在盒子内的坐标， 才是模态框真正的位置。 鼠标按下，我们要得到鼠标在盒子的坐标。 鼠标移动，就让模态框的坐标 设置为 ：鼠标坐标 减去盒子坐标即可，注意移动事件写到按下事件里面。 鼠标松开，就停止拖拽，就是可以让鼠标移动事件解除 123456789101112131415161718192021222324252627282930313233// 1. 获取元素 var login = document.querySelector('.login'); var mask = document.querySelector('.login-bg'); var link = document.querySelector('#link'); var closeBtn = document.querySelector('#closeBtn'); var title = document.querySelector('#title'); // 2. 点击弹出层这个链接 link 让mask 和login 显示出来 link.addEventListener('click', function() { mask.style.display = 'block'; login.style.display = 'block'; }) // 3. 点击 closeBtn 就隐藏 mask 和 login closeBtn.addEventListener('click', function() { mask.style.display = 'none'; login.style.display = 'none'; }) // 4. 开始拖拽 // (1) 当我们鼠标按下， 就获得鼠标在盒子内的坐标 title.addEventListener('mousedown', function(e) { var x = e.pageX - login.offsetLeft; var y = e.pageY - login.offsetTop; // (2) 鼠标移动的时候，把鼠标在页面中的坐标，减去 鼠标在盒子内的坐标就是模态框的left和top值 document.addEventListener('mousemove', move) function move(e) { login.style.left = e.pageX - x + 'px'; login.style.top = e.pageY - y + 'px'; } // (3) 鼠标弹起，就让鼠标移动事件移除 document.addEventListener('mouseup', function() { document.removeEventListener('mousemove', move); }) }) 案例：仿京东放大镜 整个案例可以分为三个功能模块 鼠标经过小图片盒子， 黄色的遮挡层 和 大图片盒子显示，离开隐藏2个盒子功能 黄色的遮挡层跟随鼠标功能。 移动黄色遮挡层，大图片跟随移动功能。 案例分析: 黄色的遮挡层跟随鼠标功能。 把鼠标坐标给遮挡层不合适。因为遮挡层坐标以父盒子为准。 首先是获得鼠标在盒子的坐标。 之后把数值给遮挡层做为left 和top值。 此时用到鼠标移动事件，但是还是在小图片盒子内移动。 发现，遮挡层位置不对，需要再减去盒子自身高度和宽度的一半。 遮挡层不能超出小图片盒子范围。 如果小于零，就把坐标设置为0 如果大于遮挡层最大的移动距离，就把坐标设置为最大的移动距离 遮挡层的最大移动距离：小图片盒子宽度 减去 遮挡层盒子宽度 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152window.addEventListener('load', function() { var preview_img = document.querySelector('.preview_img'); var mask = document.querySelector('.mask'); var big = document.querySelector('.big'); // 1. 当我们鼠标经过 preview_img 就显示和隐藏 mask 遮挡层 和 big 大盒子 preview_img.addEventListener('mouseover', function() { mask.style.display = 'block'; big.style.display = 'block'; }) preview_img.addEventListener('mouseout', function() { mask.style.display = 'none'; big.style.display = 'none'; }) // 2. 鼠标移动的时候，让黄色的盒子跟着鼠标来走 preview_img.addEventListener('mousemove', function(e) { // (1). 先计算出鼠标在盒子内的坐标 var x = e.pageX - this.offsetLeft; var y = e.pageY - this.offsetTop; // console.log(x, y); // (2) 减去盒子高度 300的一半 是 150 就是我们mask 的最终 left 和top值了 // (3) 我们mask 移动的距离 var maskX = x - mask.offsetWidth / 2; var maskY = y - mask.offsetHeight / 2; // (4) 如果x 坐标小于了0 就让他停在0 的位置 // 遮挡层的最大移动距离 var maskMax = preview_img.offsetWidth - mask.offsetWidth; if (maskX &lt;= 0) { maskX = 0; } else if (maskX &gt;= maskMax) { maskX = maskMax; } if (maskY &lt;= 0) { maskY = 0; } else if (maskY &gt;= maskMax) { maskY = maskMax; } mask.style.left = maskX + 'px'; mask.style.top = maskY + 'px'; // 3. 大图片的移动距离 = 遮挡层移动距离 * 大图片最大移动距离 / 遮挡层的最大移动距离 // 大图 var bigIMg = document.querySelector('.bigImg'); // 大图片最大移动距离 var bigMax = bigIMg.offsetWidth - big.offsetWidth; // 大图片的移动距离 X Y var bigX = maskX * bigMax / maskMax; var bigY = maskY * bigMax / maskMax; bigIMg.style.left = -bigX + 'px'; bigIMg.style.top = -bigY + 'px'; })}) 元素可视区 client 系列client概述client 翻译过来就是客户端，我们使用 client 系列的相关属性来获取元素可视区的相关信息。通过 client系列的相关属性可以动态的得到该元素的边框大小、元素大小等。 淘宝 flexible.js 源码分析立即执行函数 (function(){})() 或者 (function(){}()) 主要作用： 创建一个独立的作用域。 避免了命名冲突问题 下面三种情况都会刷新页面都会触发 load 事件。 1.a标签的超链接 2.F5或者刷新按钮（强制刷新） 3.前进后退按钮 但是 火狐中，有个特点，有个“往返缓存”，这个缓存中不仅保存着页面数据，还保存了DOM和JavaScript的状态；实际上是将整个页面都保存在了内存里。 所以此时后退按钮不能刷新页面。 此时可以使用 pageshow事件来触发。，这个事件在页面显示时触发，无论页面是否来自缓存。在重新加载页面中，pageshow会在load事件触发后触发；根据事件对象中的persisted来判断是否是缓存中的页面触发的pageshow事件 注意这个事件给window添加。 元素滚动 scroll 系列scroll 概述scroll 翻译过来就是滚动的，我们使用 scroll 系列的相关属性可以动态的得到该元素的大小、滚动距离等。 页面被卷去的头部如果浏览器的高（或宽）度不足以显示整个页面时，会自动出现滚动条。当滚动条向下滚动时，页面上面被隐藏掉的高度，我们就称为页面被卷去的头部。滚动条在滚动时会触发 onscroll事件。 案例：仿淘宝固定右侧侧边栏 原先侧边栏是绝对定位 当页面滚动到一定位置，侧边栏改为固定定位 页面继续滚动，会让 返回顶部显示出来 案例分析: 需要用到页面滚动事件 scroll 因为是页面滚动，所以事件源是document 滚动到某个位置，就是判断页面被卷去的上部值。 页面被卷去的头部：可以通过window.pageYOffset 获得 如果是被卷去的左侧window.pageXOffset 注意，元素被卷去的头部是element.scrollTop , 如果是页面被卷去的头部 则是 window.pageYOffset 其实这个值 可以通过盒子的 offsetTop可以得到，如果大于等于这个值，就可以让盒子固定定位了 1234567891011121314151617181920212223242526272829303132//1. 获取元素 var sliderbar = document.querySelector('.slider-bar'); var banner = document.querySelector('.banner'); // banner.offestTop 就是被卷去头部的大小 一定要写到滚动的外面 var bannerTop = banner.offsetTop // 当我们侧边栏固定定位之后应该变化的数值 var sliderbarTop = sliderbar.offsetTop - bannerTop; // 获取main 主体元素 var main = document.querySelector('.main'); var goBack = document.querySelector('.goBack'); var mainTop = main.offsetTop; // 2. 页面滚动事件 scroll document.addEventListener('scroll', function() { // console.log(11); // window.pageYOffset 页面被卷去的头部 // console.log(window.pageYOffset); // 3 .当我们页面被卷去的头部大于等于了 172 此时 侧边栏就要改为固定定位 if (window.pageYOffset &gt;= bannerTop) { sliderbar.style.position = 'fixed'; sliderbar.style.top = sliderbarTop + 'px'; } else { sliderbar.style.position = 'absolute'; sliderbar.style.top = '300px'; } // 4. 当我们页面滚动到main盒子，就显示 goback模块 if (window.pageYOffset &gt;= mainTop) { goBack.style.display = 'block'; } else { goBack.style.display = 'none'; } }) 页面被卷去的头部兼容性解决方案需要注意的是，页面被卷去的头部，有兼容性问题，因此被卷去的头部通常有如下几种写法： 声明了 DTD，使用 document.documentElement.scrollTop 未声明 DTD，使用 document.body.scrollTop 新方法 window.pageYOffset和 window.pageXOffset，IE9 开始支持 1234567function getScroll() { return { left: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft||0, top: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0 }; } 使用的时候 getScroll().left 三大系列总结 他们主要用法： 1.offset系列 经常用于获得元素位置 offsetLeft offsetTop 2.client经常用于获取元素大小 clientWidth clientHeight 3.scroll 经常用于获取滚动距离 scrollTop scrollLeft 4.注意页面滚动的距离通过 window.pageXOffset 获得 mouseenter 和mouseover的区别 当鼠标移动到元素上时就会触发mouseenter 事件 类似 mouseover，它们两者之间的差别是 mouseover 鼠标经过自身盒子会触发，经过子盒子还会触发。mouseenter 只会经过自身盒子触发 之所以这样，就是因为mouseenter不会冒泡 跟mouseenter搭配鼠标离开 mouseleave 同样不会冒泡 动画函数封装动画实现原理 核心原理：通过定时器 setInterval() 不断移动盒子位置。 实现步骤： 获得盒子当前位置 让盒子在当前位置加上1个移动距离 利用定时器不断重复这个操作 加一个结束定时器的条件 注意此元素需要添加定位，才能使用element.style.left 动画函数给不同元素记录不同定时器如果多个元素都使用这个动画函数，每次都要var 声明定时器。我们可以给不同的元素使用不同的定时器（自己专门用自己的定时器）。 核心原理：利用 JS 是一门动态语言，可以很方便的给当前对象添加属性。 1234567891011121314function animate(obj, target) { // 当我们不断的点击按钮，这个元素的速度会越来越快，因为开启了太多的定时器 // 解决方案就是 让我们元素只有一个定时器执行 // 先清除以前的定时器，只保留当前的一个定时器执行 clearInterval(obj.timer); obj.timer = setInterval(function() { if (obj.offsetLeft &gt;= target) { // 停止动画 本质是停止定时器 clearInterval(obj.timer); } obj.style.left = obj.offsetLeft + 1 + 'px'; }, 30); }","link":"/前端笔记/webapis-day05/"},{"title":"WebAPIs-Day06","text":"第03阶段.JavaScript基础.函数封装 学习目标: 能够封装简单动画函数 能够理解缓动动画的封装 能够使用动画函数 能够写出网页轮播图案例 能够写出移动端触屏事件 动画函数封装缓动效果原理缓动动画就是让元素运动速度有所变化，最常见的是让速度慢慢停下来 思路： 让盒子每次移动的距离慢慢变小，速度就会慢慢落下来。 核心算法： (目标值 - 现在的位置) / 10 做为每次移动的距离步长 停止的条件是： 让当前盒子位置等于目标位置就停止定时器 注意步长值需要取整 动画函数多个目标值之间移动可以让动画函数从 800 移动到 500。 当我们点击按钮时候，判断步长是正值还是负值 ​ 1.如果是正值，则步长往大了取整 ​ 2.如果是负值，则步长 向小了取整 动函数添加回调函数回调函数原理：函数可以作为一个参数。将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数，这个过程就叫做回调。 回调函数写的位置：定时器结束的位置。 动画完整版代码:1234567891011121314151617181920212223242526function animate(obj, target, callback) { // console.log(callback); callback = function() {} 调用的时候 callback() // 先清除以前的定时器，只保留当前的一个定时器执行 clearInterval(obj.timer); obj.timer = setInterval(function() { // 步长值写到定时器的里面 // 把我们步长值改为整数 不要出现小数的问题 // var step = Math.ceil((target - obj.offsetLeft) / 10); var step = (target - obj.offsetLeft) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); if (obj.offsetLeft == target) { // 停止动画 本质是停止定时器 clearInterval(obj.timer); // 回调函数写到定时器结束里面 // if (callback) { // // 调用函数 // callback(); // } callback &amp;&amp; callback(); } // 把每次加1 这个步长值改为一个慢慢变小的值 步长公式：(目标值 - 现在的位置) / 10 obj.style.left = obj.offsetLeft + step + 'px'; }, 15);} 常见网页特效案例案例：网页轮播图轮播图也称为焦点图，是网页中比较常见的网页特效。 功能需求： ​ 1.鼠标经过轮播图模块，左右按钮显示，离开隐藏左右按钮。 ​ 2.点击右侧按钮一次，图片往左播放一张，以此类推，左侧按钮同理。 ​ 3.图片播放的同时，下面小圆圈模块跟随一起变化。 ​ 4.点击小圆圈，可以播放相应图片。 ​ 5.鼠标不经过轮播图，轮播图也会自动播放图片。 ​ 6.鼠标经过，轮播图模块， 自动播放停止。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129window.addEventListener(&apos;load&apos;, function() { // 1. 获取元素 var arrow_l = document.querySelector(&apos;.arrow-l&apos;); var arrow_r = document.querySelector(&apos;.arrow-r&apos;); var focus = document.querySelector(&apos;.focus&apos;); var focusWidth = focus.offsetWidth; // 2. 鼠标经过focus 就显示隐藏左右按钮 focus.addEventListener(&apos;mouseenter&apos;, function() { arrow_l.style.display = &apos;block&apos;; arrow_r.style.display = &apos;block&apos;; clearInterval(timer); timer = null; // 清除定时器变量 }); focus.addEventListener(&apos;mouseleave&apos;, function() { arrow_l.style.display = &apos;none&apos;; arrow_r.style.display = &apos;none&apos;; timer = setInterval(function() { //手动调用点击事件 arrow_r.click(); }, 2000); }); // 3. 动态生成小圆圈 有几张图片，我就生成几个小圆圈 var ul = focus.querySelector(&apos;ul&apos;); var ol = focus.querySelector(&apos;.circle&apos;); // console.log(ul.children.length); for (var i = 0; i &lt; ul.children.length; i++) { // 创建一个小li var li = document.createElement(&apos;li&apos;); // 记录当前小圆圈的索引号 通过自定义属性来做 li.setAttribute(&apos;index&apos;, i); // 把小li插入到ol 里面 ol.appendChild(li); // 4. 小圆圈的排他思想 我们可以直接在生成小圆圈的同时直接绑定点击事件 li.addEventListener(&apos;click&apos;, function() { // 干掉所有人 把所有的小li 清除 current 类名 for (var i = 0; i &lt; ol.children.length; i++) { ol.children[i].className = &apos;&apos;; } // 留下我自己 当前的小li 设置current 类名 this.className = &apos;current&apos;; // 5. 点击小圆圈，移动图片 当然移动的是 ul // ul 的移动距离 小圆圈的索引号 乘以 图片的宽度 注意是负值 // 当我们点击了某个小li 就拿到当前小li 的索引号 var index = this.getAttribute(&apos;index&apos;); // 当我们点击了某个小li 就要把这个li 的索引号给 num num = index; // 当我们点击了某个小li 就要把这个li 的索引号给 circle circle = index; // num = circle = index; console.log(focusWidth); console.log(index); animate(ul, -index * focusWidth); }) } // 把ol里面的第一个小li设置类名为 current ol.children[0].className = &apos;current&apos;; // 6. 克隆第一张图片(li)放到ul 最后面 var first = ul.children[0].cloneNode(true); ul.appendChild(first); // 7. 点击右侧按钮， 图片滚动一张 var num = 0; // circle 控制小圆圈的播放 var circle = 0; // flag 节流阀 var flag = true; arrow_r.addEventListener(&apos;click&apos;, function() { if (flag) { flag = false; // 关闭节流阀 // 如果走到了最后复制的一张图片，此时 我们的ul 要快速复原 left 改为 0 if (num == ul.children.length - 1) { ul.style.left = 0; num = 0; } num++; animate(ul, -num * focusWidth, function() { flag = true; // 打开节流阀 }); // 8. 点击右侧按钮，小圆圈跟随一起变化 可以再声明一个变量控制小圆圈的播放 circle++; // 如果circle == 4 说明走到最后我们克隆的这张图片了 我们就复原 if (circle == ol.children.length) { circle = 0; } // 调用函数 circleChange(); } }); // 9. 左侧按钮做法 arrow_l.addEventListener(&apos;click&apos;, function() { if (flag) { flag = false; if (num == 0) { num = ul.children.length - 1; ul.style.left = -num * focusWidth + &apos;px&apos;; } num--; animate(ul, -num * focusWidth, function() { flag = true; }); // 点击左侧按钮，小圆圈跟随一起变化 可以再声明一个变量控制小圆圈的播放 circle--; // 如果circle &lt; 0 说明第一张图片，则小圆圈要改为第4个小圆圈（3） // if (circle &lt; 0) { // circle = ol.children.length - 1; // } circle = circle &lt; 0 ? ol.children.length - 1 : circle; // 调用函数 circleChange(); } }); function circleChange() { // 先清除其余小圆圈的current类名 for (var i = 0; i &lt; ol.children.length; i++) { ol.children[i].className = &apos;&apos;; } // 留下当前的小圆圈的current类名 ol.children[circle].className = &apos;current&apos;; } // 10. 自动播放轮播图 var timer = setInterval(function() { //手动调用点击事件 arrow_r.click(); }, 2000);}) 节流阀防止轮播图按钮连续点击造成播放过快。 节流阀目的：当上一个函数动画内容执行完毕，再去执行下一个函数动画，让事件无法连续触发。 核心实现思路：利用回调函数，添加一个变量来控制，锁住函数和解锁函数。 开始设置一个变量var flag= true; If(flag){flag = false; do something} 关闭水龙头 利用回调函数动画执行完毕， flag = true 打开水龙头 案例：返回顶部 带有动画的返回顶部 此时可以继续使用我们封装的动画函数 只需要把所有的left 相关的值改为 跟 页面垂直滚动距离相关就可以了 页面滚动了多少，可以通过 window.pageYOffset 得到 最后是页面滚动，使用 window.scroll(x,y) 123456789101112131415161718192021222324252627282930313233343536373839//1. 获取元素 var sliderbar = document.querySelector('.slider-bar'); var banner = document.querySelector('.banner'); // banner.offestTop 就是被卷去头部的大小 一定要写到滚动的外面 var bannerTop = banner.offsetTop // 当我们侧边栏固定定位之后应该变化的数值 var sliderbarTop = sliderbar.offsetTop - bannerTop; // 获取main 主体元素 var main = document.querySelector('.main'); var goBack = document.querySelector('.goBack'); var mainTop = main.offsetTop; // 2. 页面滚动事件 scroll document.addEventListener('scroll', function() { // console.log(11); // window.pageYOffset 页面被卷去的头部 // console.log(window.pageYOffset); // 3 .当我们页面被卷去的头部大于等于了 172 此时 侧边栏就要改为固定定位 if (window.pageYOffset &gt;= bannerTop) { sliderbar.style.position = 'fixed'; sliderbar.style.top = sliderbarTop + 'px'; } else { sliderbar.style.position = 'absolute'; sliderbar.style.top = '300px'; } // 4. 当我们页面滚动到main盒子，就显示 goback模块 if (window.pageYOffset &gt;= mainTop) { goBack.style.display = 'block'; } else { goBack.style.display = 'none'; } }) // 3. 当我们点击了返回顶部模块，就让窗口滚动的页面的最上方 goBack.addEventListener('click', function() { // 里面的x和y 不跟单位的 直接写数字即可 // window.scroll(0, 0); // 因为是窗口滚动 所以对象是window animate(window, 0); }); 案例：筋头云案例 利用动画函数做动画效果 原先筋斗云的起始位置是0 鼠标经过某个小li，把当前小li的offsetLeft 位置做为目标值即可 鼠标离开某个小li，就把目标值设为 0 如果点击了某个小li， 就把li当前的位置存储起来，做为筋斗云的起始位置 1234567891011121314151617181920212223window.addEventListener('load', function() { // 1. 获取元素 var cloud = document.querySelector('.cloud'); var c_nav = document.querySelector('.c-nav'); var lis = c_nav.querySelectorAll('li'); // 2. 给所有的小li绑定事件 // 这个current 做为筋斗云的起始位置 var current = 0; for (var i = 0; i &lt; lis.length; i++) { // (1) 鼠标经过把当前小li 的位置做为目标值 lis[i].addEventListener('mouseenter', function() { animate(cloud, this.offsetLeft); }); // (2) 鼠标离开就回到起始的位置 lis[i].addEventListener('mouseleave', function() { animate(cloud, current); }); // (3) 当我们鼠标点击，就把当前位置做为目标值 lis[i].addEventListener('click', function() { current = this.offsetLeft; }); } }) 触屏事件触屏事件概述移动端浏览器兼容性较好，我们不需要考虑以前 JS 的兼容性问题，可以放心的使用原生 JS 书写效果，但是移动端也有自己独特的地方。比如触屏事件 touch（也称触摸事件），Android和 IOS 都有。 touch 对象代表一个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。触屏事件可响应用户手指（或触控笔）对屏幕或者触控板操作。 常见的触屏事件如下： 触摸事件对象（TouchEvent）TouchEvent 是一类描述手指在触摸平面（触摸屏、触摸板等）的状态变化的事件。这类事件用于描述一个或多个触点，使开发者可以检测触点的移动，触点的增加和减少，等等 touchstart、touchmove、touchend 三个事件都会各自有事件对象。 触摸事件对象重点我们看三个常见对象列表： 因为平时我们都是给元素注册触摸事件，所以重点记住 targetTocuhes 案例：移动端拖动元素 touchstart、touchmove、touchend可以实现拖动元素 但是拖动元素需要当前手指的坐标值 我们可以使用 targetTouches[0] 里面的pageX 和 pageY 移动端拖动的原理： 手指移动中，计算出手指移动的距离。然后用盒子原来的位置 + 手指移动的距离 手指移动的距离： 手指滑动中的位置 减去 手指刚开始触摸的位置 拖动元素三步曲： （1） 触摸元素 touchstart： 获取手指初始坐标，同时获得盒子原来的位置 （2） 移动手指 touchmove： 计算手指的滑动距离，并且移动盒子 （3） 离开手指 touchend: 注意： 手指移动也会触发滚动屏幕所以这里要阻止默认的屏幕滚动 e.preventDefault();","link":"/前端笔记/webapis-day06/"},{"title":"WebAPIs-Day07","text":"第03阶段.JavaScript基础.移动端特效 学习目标: 能够写出移动端触屏事件能够写出常见的移动端特效能够使用移动端开发插件开发移动端特效能够使用移动端开发框架开发移动端特效能够写出 sessionStorage 数据的存储以及获取能够写出 localStorage 数据的存储以及获取能够说出它们两者的区别 触屏事件触屏事件概述移动端浏览器兼容性较好，我们不需要考虑以前 JS 的兼容性问题，可以放心的使用原生 JS 书写效果，但是移动端也有自己独特的地方。比如触屏事件 touch（也称触摸事件），Android 和 IOS 都有。touch 对象代表一个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。触屏事件可响应用户手指（或触控笔）对屏幕或者触控板操作。 常见的触屏事件如下： 触摸事件对象（TouchEvent）TouchEvent 是一类描述手指在触摸平面（触摸屏、触摸板等）的状态变化的事件。这类事件用于描述一个或多个触点，使开发者可以检测触点的移动，触点的增加和减少，等等 touchstart、touchmove、touchend 三个事件都会各自有事件对象。 触摸事件对象重点我们看三个常见对象列表： 因为平时我们都是给元素注册触摸事件，所以重点记住 targetTocuhes 移动端拖动元素 touchstart、touchmove、touchend 可以实现拖动元素 但是拖动元素需要当前手指的坐标值 我们可以使用 targetTouches[0] 里面的pageX 和 pageY 移动端拖动的原理： 手指移动中，计算出手指移动的距离。然后用盒子原来的位置 + 手指移动的距离 手指移动的距离： 手指滑动中的位置 减去 手指刚开始触摸的位置 拖动元素三步曲： （1） 触摸元素 touchstart： 获取手指初始坐标，同时获得盒子原来的位置 （2） 移动手指 touchmove： 计算手指的滑动距离，并且移动盒子 （3） 离开手指 touchend: 注意： 手指移动也会触发滚动屏幕所以这里要阻止默认的屏幕滚动 e.preventDefault(); 移动端常见特效案例: 移动轮播图移动端轮播图功能和基本PC端一致。 可以自动播放图片 手指可以拖动播放轮播图 案例分析: 自动播放功能 开启定时器 移动端移动，可以使用translate 移动 想要图片优雅的移动，请添加过渡效果 自动播放功能-无缝滚动 注意，我们判断条件是要等到图片滚动完毕再去判断，就是过渡完成后判断 此时需要添加检测过渡完成事件 transitionend 判断条件：如果索引号等于 3 说明走到最后一张图片，此时 索引号要复原为 0 此时图片，去掉过渡效果，然后移动 如果索引号小于0， 说明是倒着走， 索引号等于2 此时图片，去掉过渡效果，然后移动 classList 属性classList属性是HTML5新增的一个属性，返回元素的类名。但是ie10以上版本支持。 该属性用于在元素中添加，移除及切换 CSS 类。有以下方法 添加类： element.classList.add（’类名’）； 1focus.classList.add('current'); 移除类： element.classList.remove（’类名’）; 1focus.classList.remove('current'); 切换类： element.classList.toggle（’类名’）; 1focus.classList.toggle('current'); 注意:以上方法里面，所有类名都不带点 案例分析 小圆点跟随变化效果 把ol里面li带有current类名的选出来去掉类名 remove 让当前索引号的小li 加上 current add 但是，是等着过渡结束之后变化，所以这个写到 transitionend 事件里面 手指滑动轮播图 本质就是ul跟随手指移动，简单说就是移动端拖动元素 触摸元素touchstart： 获取手指初始坐标 移动手指touchmove： 计算手指的滑动距离，并且移动盒子 离开手指touchend: 根据滑动的距离分不同的情况 如果移动距离小于某个像素 就回弹原来位置 如果移动距离大于某个像素就上一张下一张滑动。 滑动也分为左滑动和右滑动判断的标准是 移动距离正负 如果是负值就是左滑 反之右滑 如果是左滑就播放下一张 （index++） 如果是右滑就播放上一张 (index–) 案例：返回顶部当页面滚动某个地方，就显示，否则隐藏 点击可以返回顶部 案例分析 滚动某个地方显示 事件：scroll页面滚动事件 如果被卷去的头部（window.pageYOffset ）大于某个数值 点击，window.scroll(0,0) 返回顶部 click 延时解决方案移动端 click 事件会有 300ms 的延时，原因是移动端屏幕双击会缩放(double tap to zoom) 页面。 解决方案： ​ 1. 禁用缩放。 浏览器禁用默认的双击缩放行为并且去掉300ms 的点击延迟。 1&lt;meta name=\"viewport\" content=\"user-scalable=no\"&gt; ​ 2.利用touch事件自己封装这个事件解决300ms 延迟。 ​ 原理就是： 当我们手指触摸屏幕，记录当前触摸时间 当我们手指离开屏幕， 用离开的时间减去触摸的时间 如果时间小于150ms，并且没有滑动过屏幕， 那么我们就定义为点击 代码如下: 1234567891011121314151617181920//封装tap，解决click 300ms 延时function tap (obj, callback) { var isMove = false; var startTime = 0; // 记录触摸时候的时间变量 obj.addEventListener('touchstart', function (e) { startTime = Date.now(); // 记录触摸时间 }); obj.addEventListener('touchmove', function (e) { isMove = true; // 看看是否有滑动，有滑动算拖拽，不算点击 }); obj.addEventListener('touchend', function (e) { if (!isMove &amp;&amp; (Date.now() - startTime) &lt; 150) { // 如果手指触摸和离开时间小于150ms 算点击 callback &amp;&amp; callback(); // 执行回调函数 } isMove = false; // 取反 重置 startTime = 0; });}//调用 tap(div, function(){ // 执行代码 }); 使用插件。fastclick 插件解决300ms 延迟。 移动端常用开发插件什么是插件移动端要求的是快速开发，所以我们经常会借助于一些插件来帮我完成操作，那么什么是插件呢？ JS 插件是 js 文件，它遵循一定规范编写，方便程序展示效果，拥有特定功能且方便调用。如轮播图和瀑布流插件。 特点：它一般是为了解决某个问题而专门存在，其功能单一，并且比较小。 我们以前写的animate.js 也算一个最简单的插件 fastclick 插件解决 300ms 延迟。 使用延时 GitHub官网地址： https://github.com/ftlabs/fastclick 插件的使用 引入 js 插件文件。 按照规定语法使用。 fastclick 插件解决 300ms 延迟。 使用延时 GitHub官网地址： https://github.com/ftlabs/fastclick 12345if ('addEventListener' in document) { document.addEventListener('DOMContentLoaded', function() { FastClick.attach(document.body); }, false);} Swiper 插件的使用中文官网地址： https://www.swiper.com.cn/ 引入插件相关文件。 按照规定语法使用 其他移动端常见插件lsuperslide： http://www.superslide2.com/ l iscroll： https://github.com/cubiq/iscroll 插件的使用总结1.确认插件实现的功能 2.去官网查看使用说明 3.下载插件 4.打开demo实例文件，查看需要引入的相关文件，并且引入 5.复制demo实例文件中的结构html，样式css以及js代码 移动端视频插件 zy.media.jsH5 给我们提供了 video 标签，但是浏览器的支持情况不同。 不同的视频格式文件，我们可以通过source解决。 但是外观样式，还有暂停，播放，全屏等功能我们只能自己写代码解决。 这个时候我们可以使用插件方式来制作。 我们可以通过 JS 修改元素的大小、颜色、位置等样式。 移动端常用开发框架移动端视频插件 zy.media.js框架，顾名思义就是一套架构，它会基于自身的特点向用户提供一套较为完整的解决方案。框架的控制权在框架本身，使用者要按照框架所规定的某种规范进行开发。 插件一般是为了解决某个问题而专门存在，其功能单一，并且比较小。 前端常用的框架有 Bootstrap、Vue、Angular、React 等。既能开发PC端，也能开发移动端 前端常用的移动端插件有 swiper、superslide、iscroll等。 框架： 大而全，一整套解决方案 插件： 小而专一，某个功能的解决方案 BootstrapBootstrap 是一个简洁、直观、强悍的前端开发框架，它让 web 开发更迅速、简单。 它能开发PC端，也能开发移动端 Bootstrap JS插件使用步骤： 1.引入相关js 文件 2.复制HTML 结构 3.修改对应样式 4.修改相应JS 参数 本地存储随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，HTML5规范提出了相关解决方案。 本地存储特性1、数据存储在用户浏览器中 2、设置、读取方便、甚至页面刷新不丢失数据 3、容量较大，sessionStorage约5M、localStorage约20M 4、只能存储字符串，可以将对象JSON.stringify() 编码后存储 window.sessionStorage1、生命周期为关闭浏览器窗口 2、在同一个窗口(页面)下数据可以共享 3、以键值对的形式存储使用 存储数据： 1sessionStorage.setItem(key, value) 获取数据： 1sessionStorage.getItem(key) 删除数据： 1sessionStorage.removeItem(key) 清空数据：(所有都清除掉) 1sessionStorage.clear() window.localStorage1、声明周期永久生效，除非手动删除 否则关闭页面也会存在 2、可以多窗口（页面）共享（同一浏览器可以共享） 以键值对的形式存储使用 存储数据： 1localStorage.setItem(key, value) 获取数据： 1localStorage.getItem(key) 删除数据： 1localStorage.removeItem(key) 清空数据：(所有都清除掉) 1localStorage.clear() 案例：记住用户名如果勾选记住用户名， 下次用户打开浏览器，就在文本框里面自动显示上次登录的用户名 案例分析 把数据存起来，用到本地存储 关闭页面，也可以显示用户名，所以用到localStorage 打开页面，先判断是否有这个用户名，如果有，就在表单里面显示用户名，并且勾选复选框 当复选框发生改变的时候change事件 如果勾选，就存储，否则就移除","link":"/前端笔记/webapis-day07/"},{"title":"jQuery-Day02","text":"第03阶段.jQuery基础.jQuery操作元素 学习目标： 能够操作 jQuery 属性能够操作 jQuery 元素能够操作 jQuery 元素尺寸、位置 jQuery 属性操作​ jQuery 常用属性操作有三种：prop() / attr() / data() ; 元素固有属性值 prop()​ 所谓元素固有属性就是元素本身自带的属性，比如 元素里面的 href ，比如 元素里面的 type。 语法 ​ 注意：prop() 除了普通属性操作，更适合操作表单属性：disabled / checked / selected 等。 元素自定义属性值 attr()​ 用户自己给元素添加的属性，我们称为自定义属性。 比如给 div 添加 index =“1”。 语法 ​ 注意：attr() 除了普通属性操作，更适合操作自定义属性。（该方法也可以获取 H5 自定义属性） 数据缓存 data()​ data() 方法可以在指定的元素上存取数据，并不会修改 DOM 元素结构。一旦页面刷新，之前存放的数据都将被移除。 语法 ​ 注意：同时，还可以读取 HTML5 自定义属性 data-index ，得到的是数字型。 演示代码 1234567891011121314151617181920212223242526&lt;body&gt; &lt;a href=\"http://www.itcast.cn\" title=\"都挺好\"&gt;都挺好&lt;/a&gt; &lt;input type=\"checkbox\" name=\"\" id=\"\" checked&gt; &lt;div index=\"1\" data-index=\"2\"&gt;我是div&lt;/div&gt; &lt;span&gt;123&lt;/span&gt; &lt;script&gt; $(function() { //1. element.prop(\"属性名\") 获取元素固有的属性值 console.log($(\"a\").prop(\"href\")); $(\"a\").prop(\"title\", \"我们都挺好\"); $(\"input\").change(function() { console.log($(this).prop(\"checked\")); }); // console.log($(\"div\").prop(\"index\")); // 2. 元素的自定义属性 我们通过 attr() console.log($(\"div\").attr(\"index\")); $(\"div\").attr(\"index\", 4); console.log($(\"div\").attr(\"data-index\")); // 3. 数据缓存 data() 这个里面的数据是存放在元素的内存里面 $(\"span\").data(\"uname\", \"andy\"); console.log($(\"span\").data(\"uname\")); // 这个方法获取data-index h5自定义属性 第一个 不用写data- 而且返回的是数字型 console.log($(\"div\").data(\"index\")); }) &lt;/script&gt;&lt;/body&gt; 案例：购物车案例模块-全选 1.全选思路：里面3个小的复选框按钮（j-checkbox）选中状态（checked）跟着全选按钮（checkall）走。2.因为checked 是复选框的固有属性，此时我们需要利用prop()方法获取和设置该属性。3.把全选按钮状态赋值给3小复选框就可以了。4.当我们每次点击小的复选框按钮，就来判断：5.如果小复选框被选中的个数等于3 就应该把全选按钮选上，否则全选按钮不选。6.:checked 选择器 :checked 查找被选中的表单元素。 ​ 代码实现略。(详情参考源代码) jQuery 文本属性值​ jQuery的文本属性值常见操作有三种：html() / text() / val() ; 分别对应JS中的 innerHTML 、innerText 和 value 属性。 jQuery内容文本值​ 常见操作有三种：html() / text() / val() ; 分别对应JS中的 innerHTML 、innerText 和 value 属性，主要针对元素的内容还有表单的值操作。 语法 ​ 注意：html() 可识别标签，text() 不识别标签。 演示代码 1234567891011121314151617&lt;body&gt; &lt;div&gt; &lt;span&gt;我是内容&lt;/span&gt; &lt;/div&gt; &lt;input type=\"text\" value=\"请输入内容\"&gt; &lt;script&gt; // 1. 获取设置元素内容 html() console.log($(\"div\").html()); // $(\"div\").html(\"123\"); // 2. 获取设置元素文本内容 text() console.log($(\"div\").text()); $(\"div\").text(\"123\"); // 3. 获取设置表单值 val() console.log($(\"input\").val()); $(\"input\").val(\"123\"); &lt;/script&gt;&lt;/body&gt; 案例：购物车案例模块-增减商品数量 1.核心思路：首先声明一个变量，当我们点击+号（increment），就让这个值++，然后赋值给文本框。2.注意1： 只能增加本商品的数量， 就是当前+号的兄弟文本框（itxt）的值。3.修改表单的值是val() 方法4.注意2： 这个变量初始值应该是这个文本框的值，在这个值的基础上++。要获取表单的值5.减号（decrement）思路同理，但是如果文本框的值是1，就不能再减了。 ​ 代码实现略。(详情参考源代码) 案例：购物车案例模块-修改商品小计 1.核心思路：每次点击+号或者-号，根据文本框的值 乘以 当前商品的价格 就是 商品的小计2.注意1： 只能增加本商品的小计， 就是当前商品的小计模块（p-sum）3.修改普通元素的内容是text() 方法4.注意2： 当前商品的价格，要把￥符号去掉再相乘 截取字符串 substr(1)5.parents(‘选择器’) 可以返回指定祖先元素6.最后计算的结果如果想要保留2位小数 通过 toFixed(2) 方法7.用户也可以直接修改表单里面的值，同样要计算小计。 用表单change事件8.用最新的表单内的值 乘以 单价即可 但是还是当前商品小计 ​ 代码实现略。(详情参考源代码) jQuery 元素操作​ jQuery 元素操作主要讲的是用jQuery方法，操作标签的遍历、创建、添加、删除等操作。 遍历元素​ jQuery 隐式迭代是对同一类元素做了同样的操作。 如果想要给同一类元素做不同操作，就需要用到遍历。 语法1 ​ 注意：此方法用于遍历 jQuery 对象中的每一项，回调函数中元素为 DOM 对象，想要使用 jQuery 方法需要转换。 语法2 ​ 注意：此方法用于遍历 jQuery 对象中的每一项，回调函数中元素为 DOM 对象，想要使用 jQuery 方法需要转换。 演示代码 1234567891011121314151617181920212223242526272829303132333435363738&lt;body&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;script&gt; $(function() { // 如果针对于同一类元素做不同操作，需要用到遍历元素（类似for，但是比for强大） var sum = 0; var arr = [\"red\", \"green\", \"blue\"]; // 1. each() 方法遍历元素 $(\"div\").each(function(i, domEle) { // 回调函数第一个参数一定是索引号 可以自己指定索引号号名称 // console.log(i); // 回调函数第二个参数一定是 dom 元素对象，也是自己命名 // console.log(domEle); // 使用jQuery方法需要转换 $(domEle) $(domEle).css(\"color\", arr[i]); sum += parseInt($(domEle).text()); }) console.log(sum); // 2. $.each() 方法遍历元素 主要用于遍历数据，处理数据 // $.each($(\"div\"), function(i, ele) { // console.log(i); // console.log(ele); // }); // $.each(arr, function(i, ele) { // console.log(i); // console.log(ele); // }) $.each({ name: \"andy\", age: 18 }, function(i, ele) { console.log(i); // 输出的是 name age 属性名 console.log(ele); // 输出的是 andy 18 属性值 }) }) &lt;/script&gt;&lt;/body&gt; 案例：购物车案例模块-计算总计和总额 1.把所有文本框中的值相加就是总额数量，总计同理。2.文本框里面的值不同，如果想要相加需要用 each() 遍历，声明一个变量做计数器，累加即可。 ​ 代码实现略。(详情参考源代码) 创建、添加、删除​ jQuery方法操作元素的创建、添加、删除方法很多，则重点使用部分，如下： 语法总和 ​ 注意：以上只是元素的创建、添加、删除方法的常用方法，其他方法请参详API。 案例代码 1234567891011121314151617181920212223242526&lt;body&gt; &lt;ul&gt; &lt;li&gt;原先的li&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"test\"&gt;我是原先的div&lt;/div&gt; &lt;script&gt; $(function() { // 1. 创建元素 var li = $(\"&lt;li&gt;我是后来创建的li&lt;/li&gt;\"); // 2. 添加元素 // 2.1 内部添加 // $(\"ul\").append(li); 内部添加并且放到内容的最后面 $(\"ul\").prepend(li); // 内部添加并且放到内容的最前面 // 2.2 外部添加 var div = $(\"&lt;div&gt;我是后妈生的&lt;/div&gt;\"); // $(\".test\").after(div); $(\".test\").before(div); // 3. 删除元素 // $(\"ul\").remove(); 可以删除匹配的元素 自杀 // $(\"ul\").empty(); // 可以删除匹配的元素里面的子节点 孩子 $(\"ul\").html(\"\"); // 可以删除匹配的元素里面的子节点 孩子 }) &lt;/script&gt;&lt;/body&gt; 案例：购物车案例模块-删除商品模块 1.核心思路：把商品remove() 删除元素即可2.有三个地方需要删除： 1. 商品后面的删除按钮 2. 删除选中的商品 3. 清理购物车3.商品后面的删除按钮： 一定是删除当前的商品，所以从 $(this) 出发4.删除选中的商品： 先判断小的复选框按钮是否选中状态，如果是选中，则删除对应的商品5.清理购物车： 则是把所有的商品全部删掉 ​ 代码实现略。(详情参考源代码) 案例：购物车案例模块-选中商品添加背景 1.核心思路：选中的商品添加背景，不选中移除背景即可2.全选按钮点击：如果全选是选中的，则所有的商品添加背景，否则移除背景3.小的复选框点击： 如果是选中状态，则当前商品添加背景，否则移除背景4.这个背景，可以通过类名修改，添加类和删除类 ​ 代码实现略。(详情参考源代码) jQuery 尺寸、位置操作​ jQuery中分别为我们提供了两套快速获取和设置元素尺寸和位置的API，方便易用，内容如下。 jQuery 尺寸操作​ jQuery 尺寸操作包括元素宽高的获取和设置，且不一样的API对应不一样的盒子模型。 语法 代码演示 12345678910111213141516171819&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() { // 1. width() / height() 获取设置元素 width和height大小 console.log($(\"div\").width()); // $(\"div\").width(300); // 2. innerWidth() / innerHeight() 获取设置元素 width和height + padding 大小 console.log($(\"div\").innerWidth()); // 3. outerWidth() / outerHeight() 获取设置元素 width和height + padding + border 大小 console.log($(\"div\").outerWidth()); // 4. outerWidth(true) / outerHeight(true) 获取设置 width和height + padding + border + margin console.log($(\"div\").outerWidth(true)); }) &lt;/script&gt;&lt;/body&gt; ​ 注意：有了这套 API 我们将可以快速获取和子的宽高，至于其他属性想要获取和设置，还要使用 css() 等方法配合。 jQuery 位置操作​ jQuery的位置操作主要有三个： offset()、position()、scrollTop()/scrollLeft() , 具体介绍如下: 语法 代码演示 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;body&gt; &lt;div class=\"father\"&gt; &lt;div class=\"son\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"back\"&gt;返回顶部&lt;/div&gt; &lt;div class=\"container\"&gt;&lt;/div&gt; &lt;script&gt; $(function() { // 1. 获取设置距离文档的位置（偏移） offset console.log($(\".son\").offset()); console.log($(\".son\").offset().top); // $(\".son\").offset({ // top: 200, // left: 200 // }); // 2. 获取距离带有定位父级位置（偏移） position 如果没有带有定位的父级，则以文档为准 // 这个方法只能获取不能设置偏移 console.log($(\".son\").position()); // $(\".son\").position({ // top: 200, // left: 200 // }); // 3. 被卷去的头部 $(document).scrollTop(100); // 被卷去的头部 scrollTop() / 被卷去的左侧 scrollLeft() // 页面滚动事件 var boxTop = $(\".container\").offset().top; $(window).scroll(function() { // console.log(11); console.log($(document).scrollTop()); if ($(document).scrollTop() &gt;= boxTop) { $(\".back\").fadeIn(); } else { $(\".back\").fadeOut(); } }); // 返回顶部 $(\".back\").click(function() { // $(document).scrollTop(0); $(\"body, html\").stop().animate({ scrollTop: 0 }); // $(document).stop().animate({ // scrollTop: 0 // }); 不能是文档而是 html和body元素做动画 }) }) &lt;/script&gt;&lt;/body&gt; 案例：带有动画的返回顶部 1.核心原理： 使用animate动画返回顶部。2.animate动画函数里面有个scrollTop 属性，可以设置位置3.但是是元素做动画，因此 $(“body,html”).animate({scrollTop: 0}) ​ 代码实现略。(详情参考源代码) 案例： 品优购电梯导航（上） 1.当我们滚动到 今日推荐 模块，就让电梯导航显示出来2.点击电梯导航页面可以滚动到相应内容区域3.核心算法：因为电梯导航模块和内容区模块一一对应的4.当我们点击电梯导航某个小模块，就可以拿到当前小模块的索引号5.就可以把animate要移动的距离求出来：当前索引号内容区模块它的offset().top6.然后执行动画即可 ​ 代码实现略。(详情参考源代码) 案例：品优购电梯导航（下） 1.当我们点击电梯导航某个小li， 当前小li 添加current类，兄弟移除类名2.当我们页面滚动到内容区域某个模块， 左侧电梯导航，相对应的小li模块，也会添加current类， 兄弟移除current类。3.触发的事件是页面滚动，因此这个功能要写到页面滚动事件里面。4.需要用到each，遍历内容区域大模块。 each里面能拿到内容区域每一个模块元素和索引号5.判断的条件： 被卷去的头部 大于等于 内容区域里面每个模块的offset().top6.就利用这个索引号找到相应的电梯导航小li添加类。 ​ 代码实现略。(详情参考源代码)","link":"/前端笔记/jquery-day02/"},{"title":"rem布局","text":"第02阶段.移动Web网页开发.rem布局 移动web开发之rem布局rem基础rem单位rem (root em)是一个相对单位，类似于em，em是父元素字体大小。 不同的是rem的基准是相对于html元素的字体大小。 比如，根元素（html）设置font-size=12px; 非根元素设置width:2rem; 则换成px表示就是24px。 12345678/* 根html 为 12px */html { font-size: 12px;}/* 此时 div 的字体大小就是 24px */ div { font-size: 2rem;} rem的优势：父元素文字大小可能不一致， 但是整个页面只有一个html，可以很好来控制整个页面的元素大小。 媒体查询什么是媒体查询媒体查询（Media Query）是CSS3新语法。 使用 @media查询，可以针对不同的媒体类型定义不同的样式 @media 可以针对不同的屏幕尺寸设置不同的样式 当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面 目前针对很多苹果手机、Android手机，平板等设备都用得到多媒体查询 媒体查询语法规范 用 @media开头 注意@符号 mediatype 媒体类型 关键字 and not only media feature 媒体特性必须有小括号包含 123@media mediatype and|not|only (media feature) { CSS-Code;} mediatype 查询类型 ​ 将不同的终端设备划分成不同的类型，称为媒体类型 关键字 ​ 关键字将媒体类型或多个媒体特性连接到一起做为媒体查询的条件。 and：可以将多个媒体特性连接到一起，相当于“且”的意思。 not：排除某个媒体类型，相当于“非”的意思，可以省略。 only：指定某个特定的媒体类型，可以省略。 媒体特性 每种媒体类型都具体各自不同的特性，根据不同媒体类型的媒体特性设置不同的展示风格。我们暂且了解三个。 注意他们要加小括号包含 媒体查询书写规则 注意： 为了防止混乱，媒体查询我们要按照从小到大或者从大到小的顺序来写,但是我们最喜欢的还是从小到大来写，这样代码更简洁 less 基础维护css弊端CSS 是一门非程序式语言，没有变量、函数、SCOPE（作用域）等概念。 CSS 需要书写大量看似没有逻辑的代码，CSS 冗余度是比较高的。 不方便维护及扩展，不利于复用。 CSS 没有很好的计算能力 非前端开发工程师来讲，往往会因为缺少 CSS 编写经验而很难写出组织良好且易于维护的 CSS 代码项目。 Less 介绍Less（LeanerStyle Sheets 的缩写）是一门 CSS扩展语言，也成为CSS预处理器。 做为 CSS的一种形式的扩展，它并没有减少CSS的功能，而是在现有的CSS语法上，为CSS加入程序式语言的特性。 它在CSS 的语法基础之上，引入了变量，Mixin（混入），运算以及函数等功能，大大简化了 CSS 的编写，并且降低了 CSS的维护成本，就像它的名称所说的那样，Less可以让我们用更少的代码做更多的事情。 Less中文网址：http://lesscss.cn/ 常见的CSS预处理器：Sass、Less、Stylus 一句话：Less是一门 CSS 预处理语言，它扩展了CSS的动态特性。 Less安装 ①安装nodejs，可选择版本(8.0)，网址：http://nodejs.cn/download/ ②检查是否安装成功，使用cmd命令（win10是window+r 打开运行输入cmd） —输入“node –v”查看版本即可 ③基于nodejs在线安装Less，使用cmd命令“npm install -g less”即可 ④检查是否安装成功，使用cmd命令“ lessc -v ”查看版本即可 Less 使用之变量 变量是指没有固定的值，可以改变的。因为我们CSS中的一些颜色和数值等经常使用。 1@变量名:值; 必须有@为前缀 不能包含特殊字符 不能以数字开头 大小写敏感 1@color: pink; Less 编译 vocode Less 插件 Easy LESS 插件用来把less文件编译为css文件 安装完毕插件，重新加载下 vscode。 只要保存一下Less文件，会自动生成CSS文件。 Less 嵌套 12345678910// 将css改为less#header .logo { width: 300px;}#header { .logo { width: 300px; }} 如果遇见 （交集|伪类|伪元素选择器） ，利用&amp;进行连接 12345678a:hover{ color:red;}a{ &amp;:hover{ color:red; }} Less 运算 任何数字、颜色或者变量都可以参与运算。就是Less提供了加（+）、减（-）、乘（*）、除（/）算术运算。 1234567891011/*Less 里面写*/@witdh: 10px + 5;div { border: @witdh solid red;}/*生成的css*/div { border: 15px solid red;}/*Less 甚至还可以这样 */width: (@width + 5) * 2; 乘号（*）和除号（/）的写法 运算符中间左右有个空格隔开 1px + 5 对于两个不同的单位的值之间的运算，运算结果的值取第一个值的单位 如果两个值之间只有一个值有单位，则运算结果就取该单位 rem适配方案1.让一些不能等比自适应的元素，达到当设备尺寸发生改变的时候，等比例适配当前设备。 2.使用媒体查询根据不同设备按比例设置html的字体大小，然后页面元素使用rem做尺寸单位，当html字体大小变化元素尺寸也会发生变化，从而达到等比缩放的适配。 技术方案： 1.less+rem+媒体查询 2.lflexible.js+rem 总结： 两种方案现在都存在。 方案2 更简单，现阶段大家无需了解里面的js代码。 rem实际开发适配方案1①假设设计稿是750px ②假设我们把整个屏幕划分为15等份（划分标准不一可以是20份也可以是10等份） ③每一份作为html字体大小，这里就是50px ④那么在320px设备的时候，字体大小为320/15就是 21.33px ⑤用我们页面元素的大小除以不同的 html字体大小会发现他们比例还是相同的 ⑥比如我们以750为标准设计稿 ⑦一个100100像素的页面元素在 750屏幕下， 就是 100/ 50 转换为rem 是 2rem2rem 比例是1比1 ⑧320屏幕下， html字体大小为21.33 则 2rem= 42.66px 此时宽和高都是 42.66 但是宽和高的比例还是 1比1 ⑨但是已经能实现不同屏幕下 页面元素盒子等比例缩放的效果 总结： ①最后的公式：页面元素的rem值 = 页面元素值（px） / （屏幕宽度 / 划分的份数） ②屏幕宽度/划分的份数就是 htmlfont-size 的大小 ③或者：页面元素的rem值 = 页面元素值（px） / html font-size 字体大小 苏宁首页苏宁首页地址 ：苏宁首页 1、 技术选型 方案：我们采取单独制作移动页面方案 技术：布局采取rem适配布局（less + rem + 媒体查询） 设计图： 本设计图采用 750px 设计尺寸 2、搭建文件结构 3、设置视口标签以及引入初始化样式 123&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;css/normalize.css&quot;&gt; 4、设置公共common.less文件 新建common.less 设置好最常见的屏幕尺寸，利用媒体查询设置不同的html字体大小，因为除了首页其他页面也需要 我们关心的尺寸有 320px、360px、375px、384px、400px、414px、424px、480px、540px、720px、750px 划分的份数我们定为 15等份 因为我们pc端也可以打开我们苏宁移动端首页，我们默认html字体大小为 50px，注意这句话写到最上面 rem 适配方案2手机淘宝团队出的简洁高效 移动端适配库 我们再也不需要在写不同屏幕的媒体查询，因为里面js做了处理 它的原理是把当前设备划分为10等份，但是不同设备下，比例还是一致的。 我们要做的，就是确定好我们当前设备的html 文字大小就可以了 比如当前设计稿是 750px， 那么我们只需要把 html 文字大小设置为 75px(750px / 10) 就可以 里面页面元素rem值： 页面元素的px 值 / 75 剩余的，让flexible.js来去算 github地址：https://github.com/amfe/lib-flexible 总结： 因为flexible是默认将屏幕分为10等分 但是当屏幕大于750的时候希望不要再去重置html字体了 所以要自己通过媒体查询设置一下 并且要把权重提到最高 VSCode px 转换rem 插件 cssrem 因为cssrem中css自动转化为rem是参照默认插件的16转换的所以需要自己配置","link":"/前端笔记/rem布局/"},{"title":"CSS-Day02","text":"第01阶段.前端基础.CSS选择器 今天我们围绕一个 导航栏案例进行学习知识点。 CSS复合选择器今日重点： 复合选择器 后代选择器 并集选择器 标签显示模式 CSS背景 背景位置 CSS三大特性 优先级 目标 理解 理解css复合选择器分别的应用场景 应用 使用后代选择器给元素添加样式 使用并集选择器给元素添加样式 使用伪类选择器 为什么要学习css复合选择器 CSS选择器分为 基础选择器 和 复合选择器 ，但是基础选择器不能满足我们实际开发中，快速高效的选择标签。 目的是为了可以选择更准确更精细的目标元素标签。 复合选择器是由两个或多个基础选择器，通过不同的方式组合而成的 后代选择器（重点） 概念： 后代选择器又称为包含选择器 作用： 用来选择元素或元素组的子孙后代 其写法就是把外层标签写在前面，内层标签写在后面，中间用空格分隔，先写父亲爷爷，在写儿子孙子。 1父级 子级{属性:属性值;属性:属性值;} 语法： 1.class h3{color:red;font-size:16px;} 当标签发生嵌套时，内层标签就成为外层标签的后代。 子孙后代都可以这么选择。 或者说，它能选择任何包含在内 的标签。 子元素选择器 作用： 子元素选择器只能选择作为某元素子元素(亲儿子)的元素。 其写法就是把父级标签写在前面，子级标签写在后面，中间跟一个 &gt; 进行连接 语法： 1.class&gt;h3{color:red;font-size:14px;} pink老师一句话说出他们 这里的子 指的是 亲儿子 不包含孙子 重孙子之类。 白话： 1比如： .demo &gt; h3 {color: red;} 说明 h3 一定是demo 亲儿子。 demo 元素包含着h3。 交集选择器 条件 交集选择器由两个选择器构成，找到的标签必须满足：既有标签一的特点，也有标签二的特点。 语法： 其中第一个为标签选择器，第二个为class选择器，两个选择器之间不能有空格，如h3.special。 记忆技巧： 交集选择器 是 并且的意思。 即…又…的意思 1比如： p.one 选择的是： 类名为 .one 的 段落标签。 用的相对来说比较少，不太建议使用。 并集选择器（重点） 应用： 如果某些选择器定义的相同样式，就可以利用并集选择器，可以让代码更简洁。 并集选择器（CSS选择器分组）是各个选择器通过,连接而成的，通常用于集体声明。 语法： 任何形式的选择器（包括标签选择器、class类选择器id选择器等），都可以作为并集选择器的一部分。 记忆技巧： 并集选择器通常用于集体声明 ，逗号隔开的，所有选择器都会执行后面样式，逗号可以理解为 和的意思。 123比如 .one, p , #test {color: #F00;} 表示 .one 和 p 和 #test 这三个选择器都会执行颜色为红色。 通常用于集体声明。 他和他，在一起， 在一起 一起的意思 测试题1234567891011121314 &lt;!-- 主导航栏 --&gt;&lt;div class=\"nav\"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;公司首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;公司简介&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;公司产品&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;联系我们&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;!-- 侧导航栏 --&gt;&lt;div class=\"sitenav\"&gt; &lt;div class=\"site-l\"&gt;左侧侧导航栏&lt;/div&gt; &lt;div class=\"site-r\"&gt;&lt;a href=\"#\"&gt;登录&lt;/a&gt;&lt;/div&gt;&lt;/div&gt; 在不修改以上结构代码的前提下，完成以下任务： 链接 登录 的颜色为红色 主导航栏里面的所有的链接改为橙色 主导航栏和侧导航栏里面文字都是14像素并且是微软雅黑。 链接伪类选择器（重点） 伪类选择器： 为了和我们刚才学的类选择器相区别类选择器是一个点 比如 .demo {}而我们的伪类 用 2个点 就是 冒号 比如 :link{} 伪娘 作用： 用于向某些选择器添加特殊的效果。比如给链接添加特殊效果， 比如可以选择 第1个，第n个元素。 因为伪类选择器很多，比如链接伪类，结构伪类等等。我们这里先给大家讲解链接伪类选择器。 a:link /* 未访问的链接 */ a:visited /* 已访问的链接 */ a:hover /* 鼠标移动到链接上 */ a:active /* 选定的链接 */ 注意 写的时候，他们的顺序尽量不要颠倒 按照 lvha 的顺序。否则可能引起错误。 记忆法 love hate 爱上了讨厌 lv *包包 非常 *hao 因为叫链接伪类，所以都是 利用交集选择器 a:link a:hover 因为a链接浏览器具有默认样式，所以我们实际工作中都需要给链接单独指定样式。 实际工作开发中，我们很少写全四个状态，一般我们写法如下： 12345678a { /* a是标签选择器 所有的链接 */ font-weight: 700; font-size: 16px; color: gray;}a:hover { /* :hover 是链接伪类选择器 鼠标经过 */ color: red; /* 鼠标经过的时候，由原来的 灰色 变成了红色 */} 复合选择器总结 选择器 作用 特征 使用情况 隔开符号及用法 后代选择器 用来选择元素后代 是选择所有的子孙后代 较多 符号是空格 .nav a 子代选择器 选择 最近一级元素 只选亲儿子 较少 符号是&gt; .nav&gt;p 交集选择器 选择两个标签交集的部分 既是 又是 较少 没有符号 p.one 并集选择器 选择某些相同样式的选择器 可以用于集体声明 较多 符号是逗号 .nav, .header 链接伪类选择器 给链接更改状态 较多 重点记住 a{} 和 a:hover 实际开发的写法 标签显示模式（display）重点目标： 理解 标签的三种显示模式 三种显示模式的特点以及区别 理解三种显示模式的相互转化 应用 实现三种显示模式的相互转化 什么是标签显示模式 什么是标签的显示模式？ 标签以什么方式进行显示，比如div 自己占一行， 比如span 一行可以放很多个 作用： 我们网页的标签非常多，再不同地方会用到不同类型的标签，以便更好的完成我们的网页。 标签的类型(分类) HTML标签一般分为块标签和行内标签两种类型，它们也称块元素和行内元素。 块级元素(block-level) 例： 1常见的块元素有&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;等，其中&lt;div&gt;标签是最典型的块元素。 块级元素的特点 （1）比较霸道，自己独占一行 （2）高度，宽度、外边距以及内边距都可以控制。 （3）宽度默认是容器（父级宽度）的100% （4）是一个容器及盒子，里面可以放行内或者块级元素。 注意： 只有 文字才 能组成段落 因此 p 里面不能放块级元素，特别是 p 不能放div 同理还有这些标签h1,h2,h3,h4,h5,h6,dt，他们都是文字类块级标签，里面不能放其他块级元素。 行内元素(inline-level) 例： 1常见的行内元素有&lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt;等，其中&lt;span&gt;标签最典型的行内元素。有的地方也成内联元素 行内元素的特点： （1）相邻行内元素在一行上，一行可以显示多个。 （2）高、宽直接设置是无效的。 （3）默认宽度就是它本身内容的宽度。 （4）行内元素只能容纳文本或则其他行内元素。 注意： 链接里面不能再放链接。 特殊情况a里面可以放块级元素，但是给a转换一下块级模式最安全。 行内块元素（inline-block） 例： 1在行内元素中有几个特殊的标签——&lt;img /&gt;、&lt;input /&gt;、&lt;td&gt;，可以对它们设置宽高和对齐属性，有些资料可能会称它们为行内块元素。 行内块元素的特点： （1）和相邻行内元素（行内块）在一行上,但是之间会有空白缝隙。一行可以显示多个（2）默认宽度就是它本身内容的宽度。（3）高度，行高、外边距以及内边距都可以控制。 三种模式总结区别 元素模式 元素排列 设置样式 默认宽度 包含 块级元素 一行只能放一个块级元素 可以设置宽度高度 容器的100% 容器级可以包含任何标签 行内元素 一行可以放多个行内元素 不可以直接设置宽度高度 它本身内容的宽度 容纳文本或则其他行内元素 行内块元素 一行放多个行内块元素 可以设置宽度和高度 它本身内容的宽度 标签显示模式转换 display 块转行内：display:inline; 行内转块：display:block; 块、行内元素转换为行内块： display: inline-block; 此阶段，我们只需关心这三个，其他的是我们后面的工作。 行高那些事（line-height）目标 理解 能说出 行高 和 高度 三种关系 能简单理解为什么行高等于高度单行文字会垂直居中 应用 使用行高实现单行文字垂直居中 能会测量行高 行高测量行高的测量方法： 单行文本垂直居中 行高我们利用最多的一个地方是： 可以让单行文本在盒子中垂直居中对齐。 文字的行高等于盒子的高度。 这里情况些许复杂，开始学习，我们可以先从简单地方入手学会。 行高 = 上距离 + 内容高度 + 下距离 上距离和下距离总是相等的，因此文字看上去是垂直居中的。 行高和高度的三种关系 如果 行高 等 高度 文字会 垂直居中 如果行高 大于 高度 文字会 偏下 如果行高小于高度 文字会 偏上 CSS 背景(background)目标 理解 背景的作用 css背景图片和插入图片的区别 应用 通过css背景属性，给页面元素添加背景样式 能设置不同的背景图片位置 背景颜色(color) 语法： 1background-color:颜色值; 默认的值是 transparent 透明的 背景图片(image) 语法： 1background-image : none | url (url) 参数 作用 none 无背景图（默认的） url 使用绝对或相对地址指定背景图像 1background-image : url(images/demo.png); 小技巧： 我们提倡 背景图片后面的地址，url不要加引号。 背景平铺（repeat） 语法： 1background-repeat : repeat | no-repeat | repeat-x | repeat-y 参数 作用 repeat 背景图像在纵向和横向上平铺（默认的） no-repeat 背景图像不平铺 repeat-x 背景图像在横向上平铺 repeat-y 背景图像在纵向平铺 背景位置(position) 重点 语法： 123background-position : length || lengthbackground-position : position || position 参数 值 length 百分数 | 由浮点数字和单位标识符组成的长度值 position top | center | bottom | left | center | right 方位名词 注意： 必须先指定background-image属性 position 后面是x坐标和y坐标。 可以使用方位名词或者 精确单位。 如果指定两个值，两个值都是方位名字，则两个值前后顺序无关，比如left top和top left效果一致 如果只指定了一个方位名词，另一个值默认居中对齐。 如果position 后面是精确坐标， 那么第一个，肯定是 x 第二的一定是y 如果只指定一个数值,那该数值一定是x坐标，另一个默认垂直居中 如果指定的两个值是 精确单位和方位名字混合使用，则第一个值是x坐标，第二个值是y坐标 实际工作用的最多的，就是背景图片居中对齐了。 练习1： 背景大图 练习2： 小图片在盒子左侧垂直居中 背景附着 背景附着就是解释背景是滚动的还是固定的 语法： 1background-attachment : scroll | fixed 参数 作用 scroll 背景图像是随对象内容滚动 fixed 背景图像固定 背景简写 background：属性的值的书写顺序官方并没有强制标准的。为了可读性，建议大家如下写： background: 背景颜色 背景图片地址 背景平铺 背景滚动 背景位置; 语法： 1background: transparent url(image.jpg) repeat-y scroll center top ; 案例： 导航栏案例 背景透明(CSS3) 语法： 1background: rgba(0, 0, 0, 0.3); 最后一个参数是alpha 透明度 取值范围 0~1之间 我们习惯把0.3 的 0 省略掉 这样写 background: rgba(0, 0, 0, .3); 注意： 背景半透明是指盒子背景半透明， 盒子里面的内容不受影响 因为是CSS3 ，所以 低于 ie9 的版本是不支持的。 背景总结 属性 作用 值 background-color 背景颜色 预定义的颜色值/十六进制/RGB代码 background-image 背景图片 url(图片路径) background-repeat 是否平铺 repeat/no-repeat/repeat-x/repeat-y background-position 背景位置 length/position 分别是x 和 y坐标， 切记 如果有 精确数值单位，则必须按照先X 后Y 的写法 background-attachment 背景固定还是滚动 scroll/fixed 背景简写 更简单 背景颜色 背景图片地址 背景平铺 背景滚动 背景位置; 他们没有顺序 背景透明 让盒子半透明 background: rgba(0,0,0,0.3); 后面必须是 4个值 CSS 三大特性目标： 理解 能说出css样式冲突采取的原则 能说出那些常见的样式会有继承 应用 能写出CSS优先级的算法 能会计算常见选择器的叠加值 CSS层叠性 概念： 所谓层叠性是指多种CSS样式的叠加。 是浏览器处理冲突的一个能力,如果一个属性通过两个相同选择器设置到同一个元素上，那么这个时候一个属性就会将另一个属性层叠掉 原则： 样式冲突，遵循的原则是就近原则。 那个样式离着结构近，就执行那个样式。 样式不冲突，不会层叠 1CSS层叠性最后的执行口诀： 长江后浪推前浪，前浪死在沙滩上。 5.2 CSS继承性 概念： 子标签会继承父标签的某些样式，如文本颜色和字号。 想要设置一个可继承的属性，只需将它应用于父元素即可。 简单的理解就是： 子承父业。 注意： 恰当地使用继承可以简化代码，降低CSS样式的复杂性。比如有很多子级孩子都需要某个样式，可以给父级指定一个，这些孩子继承过来就好了。 子元素可以继承父元素的样式（text-，font-，line-这些元素开头的可以继承，以及color属性） 1CSS继承性口诀： 龙生龙，凤生凤，老鼠生的孩子会打洞。 CSS优先级（重点） 概念： 定义CSS样式时，经常出现两个或更多规则应用在同一元素上，此时， 选择器相同，则执行层叠性 选择器不同，就会出现优先级的问题。 权重计算公式关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity（特殊性） 标签选择器 计算权重公式 继承或者 * 0,0,0,0 每个元素（标签选择器） 0,0,0,1 每个类，伪类 0,0,1,0 每个ID 0,1,0,0 每个行内样式 style=”” 1,0,0,0 每个!important 重要的 ∞ 无穷大 值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越。 关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity（特殊性） div {color: pink!important; } 权重叠加我们经常用交集选择器，后代选择器等，是有多个基础选择器组合而成，那么此时，就会出现权重叠加。 就是一个简单的加法计算 div ul li ——&gt; 0,0,0,3 .nav ul li ——&gt; 0,0,1,2 a:hover —–—&gt; 0,0,1,1 .nav a ——&gt; 0,0,1,1 注意： 数位之间没有进制 比如说： 0,0,0,5 + 0,0,0,5 =0,0,0,10 而不是 0,0, 1, 0， 所以不会存在10个div能赶上一个类选择器的情况。 继承的权重是0这个不难，但是忽略很容易绕晕。其实，我们修改样式，一定要看该标签有没有被选中。 1） 如果选中了，那么以上面的公式来计权重。谁大听谁的。2） 如果没有选中，那么权重是0，因为继承的权重为0. CSS注释CSS注释规则： 1/* 需要注释的内容 */ 进行注释的，即在需要注释的内容前使用 &quot;/*&quot; 标记开始注释，在内容的结尾使用 &quot;*/&quot;结束。 例如： 1234p { /* 所有的字体是14像素大小*/ font-size: 14px; }","link":"/前端笔记/css-day02/"},{"title":"CSS-Day03","text":"第01阶段.前端基础.盒子模型 盒子模型（CSS重点）css学习三大重点： css 盒子模型 、 浮动 、 定位 主题思路： 目标： 理解： 能说出盒子模型有那四部分组成 能说出内边距的作用以及对盒子的影响 能说出padding设置不同数值个数分别代表的意思 能说出块级盒子居中对齐需要的2个条件 能说出外边距合并的解决方法 应用： 能利用边框复合写法给元素添加边框 能计算盒子的实际大小 能利用盒子模型布局模块案例 看透网页布局的本质网页布局中，我们是如何把里面的文字，图片，按照美工给我们的效果图排列的整齐有序呢？ 看透网页布局的本质： 首先利用CSS设置好盒子的大小，然后摆放盒子的位置。 最后把网页元素比如文字图片等等，放入盒子里面。 以上两步 就是网页布局的本质 我们明白了，盒子是网页布局的关键点，所以我们更应该弄明白 这个盒子有什么特点。 盒子模型（Box Model） 所谓盒子模型： 就是把HTML页面中的布局元素看作是一个矩形的盒子，也就是一个盛装内容的容器。 pink老师总结： 盒子模型有元素的内容、边框（border）、内边距（padding）、和外边距（margin）组成。 盒子里面的文字和图片等元素是 内容区域 盒子的厚度 我们成为 盒子的边框 盒子内容与边框的距离是内边距（类似单元格的 cellpadding) 盒子与盒子之间的距离是外边距（类似单元格的 cellspacing） 标准盒子模型 盒子边框（border）​ 语法： 1border : border-width || border-style || border-color 属性 作用 border-width 定义边框粗细，单位是px border-style 边框的样式 border-color 边框颜色 边框的样式： none：没有边框即忽略所有边框的宽度（默认值） solid：边框为单实线(最为常用的) dashed：边框为虚线 dotted：边框为点线 边框综合设置1border : border-width || border-style || border-color 例如： 1border: 1px solid red; 没有顺序 盒子边框写法总结表很多情况下，我们不需要指定4个边框，我们是可以单独给4个边框分别指定的。 上边框 下边框 左边框 右边框 border-top-style:样式; border-bottom-style:样式; border-left-style:样式; border-right-style:样式; border-top-width:宽度; border- bottom-width:宽度; border-left-width:宽度; border-right-width:宽度; border-top-color:颜色; border- bottom-color:颜色; border-left-color:颜色; border-right-color:颜色; border-top:宽度 样式 颜色; border-bottom:宽度 样式 颜色; border-left:宽度 样式 颜色; border-right:宽度 样式 颜色; 表格的细线边框 通过表格的cellspacing=&quot;0&quot;,将单元格与单元格之间的距离设置为0， 但是两个单元格之间的边框会出现重叠，从而使边框变粗 通过css属性： 1table{ border-collapse:collapse; } collapse 单词是合并的意思 border-collapse:collapse; 表示相邻边框合并在一起。 1234567891011121314&lt;style&gt; table { width: 500px; height: 300px; border: 1px solid red; } td { border: 1px solid red; text-align: center; } table, td { border-collapse: collapse; /*合并相邻边框*/ }&lt;/style&gt; 内边距（padding） 内边距：​ padding属性用于设置内边距。 是指 边框与内容之间的距离。 设置 属性 作用 padding-left 左内边距 padding-right 右内边距 padding-top 上内边距 padding-bottom 下内边距 当我们给盒子指定padding值之后， 发生了2件事情： 内容和边框 有了距离，添加了内边距。 盒子会变大了。 注意： 后面跟几个数值表示的意思是不一样的。 我们分开写有点麻烦，我们可以不可以简写呢？ 值的个数 表达意思 1个值 padding：上下左右内边距; 2个值 padding: 上下内边距 左右内边距 ； 3个值 padding：上内边距 左右内边距 下内边距； 4个值 padding: 上内边距 右内边距 下内边距 左内边距 ； 课堂一练： 请写出如下内边距： 要求盒子有一个左边内边距是 5像素 要求简写的形式写出 一个盒子上下是 25像素 左右是15像素。 要求简写的形式写出 一个盒子 上内边距是 12像素 下内边距是 0 左内边距是 25像素 右内边距是 10像素 课堂案例： 新浪导航新浪导航栏的核心就是因为里面的字数不一样多，所以我们不方便给宽度，还是给padding ，撑开盒子的。 内盒尺寸计算（元素实际大小） 宽度 Element Height = content height + padding + border （Height为内容高度） 高度 Element Width = content width + padding + border （Width为内容宽度） 盒子的实际的大小 = 内容的宽度和高度 + 内边距 + 边框 内边距产生的问题 问题 会撑大原来的盒子 解决： 通过给设置了宽高的盒子，减去相应的内边距的值，维持盒子原有的大小 课堂一练 一个盒子宽度为100， padding为 10， 边框为5像素，问这个盒子实际的宽度的是（） (A) 130 (B) 135 (C) 125 (D) 115 100 + 20 + 10 关于根据下列代码计算 盒子宽高下列说法正确的是（） 123456789101112131415div { width: 200px; height: 200px; border: 1px solid #000000; border-top: 5px solid blue; padding: 50px; padding-left: 100px; } (A) 宽度为200px 高度为200px (B) 宽度为352px 高度为306px (C) 宽度为302px 高度为307px (D) 宽度为302px 高度为252px w 200 + 150 + 2 = 352 h 200 + 100 + 6 = 306 padding不影响盒子大小情况 如果没有给一个盒子指定宽度， 此时，如果给这个盒子指定padding， 则不会撑开盒子。 外边距（margin） 外边距​ margin属性用于设置外边距。 margin就是控制盒子和盒子之间的距离 设置： 属性 作用 margin-left 左外边距 margin-right 右外边距 margin-top 上外边距 margin-bottom 下外边距 margin值的简写 （复合写法）代表意思 跟 padding 完全相同。 块级盒子水平居中 可以让一个块级盒子实现水平居中必须： 盒子必须指定了宽度（width） 然后就给左右的外边距都设置为auto， 实际工作中常用这种方式进行网页布局，示例代码如下： 1.header{ width:960px; margin:0 auto;} 常见的写法，以下下三种都可以。 margin-left: auto; margin-right: auto; margin: auto; margin: 0 auto; 文字居中和盒子居中区别 盒子内的文字水平居中是 text-align: center, 而且还可以让 行内元素和行内块居中对齐 块级盒子水平居中 左右margin 改为 auto 12text-align: center; /* 文字 行内元素 行内块元素水平居中 */margin: 10px auto; /* 块级盒子水平居中 左右margin 改为 auto 就阔以了 上下margin都可以 */ 插入图片和背景图片区别 插入图片 我们用的最多 比如产品展示类 移动位置只能靠盒模型 padding margin 背景图片我们一般用于小图标背景 或者 超大背景图片 背景图片 只能通过 background-position 1234567891011121314img { width: 200px;/* 插入图片更改大小 width 和 height */ height: 210px; margin-top: 30px; /* 插入图片更改位置 可以用margin 或padding 盒模型 */ margin-left: 50px; /* 插入当图片也是一个盒子 */}div { width: 400px; height: 400px; border: 1px solid purple; background: #fff url(images/sun.jpg) no-repeat; background-position: 30px 50px; /* 背景图片更改位置 我用 background-position */} 清除元素的默认内外边距(重要) 为了更灵活方便地控制网页中的元素，制作网页时，我们需要将元素的默认内外边距清除 代码： 1234* { padding:0; /* 清除内边距 */ margin:0; /* 清除外边距 */} 注意： 行内元素为了照顾兼容性， 尽量只设置左右内外边距， 不要设置上下内外边距。 外边距合并使用margin定义块元素的垂直外边距时，可能会出现外边距的合并。 相邻块元素垂直外边距的合并 当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom 下面的元素有上外边距margin-top，则他们之间的垂直间距不是margin-bottom与margin-top之和 取两个值中的较大者这种现象被称为相邻块元素垂直外边距的合并（也称外边距塌陷）。 解决方案：尽量给只给一个盒子添加margin值。 嵌套块元素垂直外边距的合并（塌陷） 对于两个嵌套关系的块元素，如果父元素没有上内边距及边框 父元素的上外边距会与子元素的上外边距发生合并 合并后的外边距为两者中的较大者 解决方案： 可以为父元素定义上边框。 可以为父元素定义上内边距 可以为父元素添加overflow:hidden。 还有其他方法，比如浮动、固定、绝对定位的盒子不会有问题，后面咱们再总结。。。 盒子模型布局稳定性 学习完盒子模型，内边距和外边距，什么情况下用内边距，什么情况下用外边距？ 大部分情况下是可以混用的。 就是说，你用内边距也可以，用外边距也可以。 你觉得哪个方便，就用哪个。 我们根据稳定性来分，建议如下： 按照 优先使用 宽度 （width） 其次 使用内边距（padding） 再次 外边距（margin）。 1width &gt; padding &gt; margin 原因： margin 会有外边距合并 还有 ie6下面margin 加倍的bug（讨厌）所以最后使用。 padding 会影响盒子大小， 需要进行加减计算（麻烦） 其次使用。 width 没有问题（嗨皮）我们经常使用宽度剩余法 高度剩余法来做。 ps基本操作以及常用快捷键：因为网页美工大部分效果图都是利用ps 来做的，所以，以后我们大部分切图工作都是在ps里面完成。 文件–打开 – 可以打开 我们要测量的图片 ctrl+r 可以打开标尺 或者 视图 – 标尺 右击标尺， 把里面的单位改为 像素 ctrl+ 加号 键 可以 放大 视图 ctrl+ 减号 缩小视图 按住空格键， 鼠标可以 变成小手 ，拖动 ps 视图 用选区 拖动 可以 测量 大小 ctrl+ d 可以取消选区 或者旁边空白处点击一下也可以取消选区 综合案例 去掉列表默认的样式无序和有序列表前面默认的列表样式，在不同浏览器显示效果不一样，而且也比较难看，所以，我们一般上来就直接去掉这些列表样式就行了。 代码如下 1li { list-style: none; } 拓展@以下我们讲的CSS3部分新属性， 但是我们遵循的原则是，以下内容，不会影响我们页面布局， 只是样式更好看了而已。 圆角边框(CSS3) 语法： 1border-radius:length; 其中每一个值可以为 数值或百分比的形式。 技巧： 让一个正方形 变成圆圈 1border-radius: 50%; 以上效果图矩形的圆角， 就不要用 百分比了，因为百分比会是表示高度和宽度的一半。 而我们这里矩形就只用 用 高度的一半就好了。精确单位。 盒子阴影(CSS3) 语法: 1box-shadow:水平阴影 垂直阴影 模糊距离（虚实） 阴影尺寸（影子大小） 阴影颜色 内/外阴影； 前两个属性是必须写的。其余的可以省略。 外阴影 (outset) 是默认的 但是不能写 想要内阴影可以写 inset 123456789div { width: 200px; height: 200px; border: 10px solid red; /* box-shadow: 5px 5px 3px 4px rgba(0, 0, 0, .4); */ /* box-shadow:水平位置 垂直位置 模糊距离 阴影尺寸（影子大小） 阴影颜色 内/外阴影； */ box-shadow: 0 15px 30px rgba(0, 0, 0, .4); } CSS书写规范开始就形成良好的书写规范，是你专业的开始。 空格规范【强制】 选择器 与 { 之间必须包含空格。 示例： 12.selector {} 【强制】 属性名 与之后的 : 之间不允许包含空格， : 与 属性值 之间必须包含空格。 示例： 1font-size: 12px; 选择器规范【强制】 并集选择器，每个选择器声明必须独占一行。 示例： 123456789101112/* good */.post,.page,.comment { line-height: 1.5;}/* bad */.post, .page, .comment { line-height: 1.5;} 【建议】 一般情况情况下，选择器的嵌套层级应不大于 3 级，位置靠后的限定条件应尽可能精确。 示例： 1234567/* good */#username input {}.comment .avatar {}/* bad */.page .header .login input {}.comment div * {} 属性规范【强制】 属性定义必须另起一行。 示例： 12345678/* good */.selector { margin: 0; padding: 0;}/* bad */.selector { margin: 0; padding: 0; } 【强制】 属性定义后必须以分号结尾。 示例： 123456789/* good */.selector { margin: 0;}/* bad */.selector { margin: 0}","link":"/前端笔记/css-day03/"},{"title":"HTML-Day03","text":"第01阶段.前端基础.HTML常用标签 学习目标 理解： 相对路径三种形式 应用 排版标签 文本格式化标签 图像标签 链接 相对路径，绝对路径的使用 1. HTML常用标签 首先 HTML和CSS是两种完全不同的语言，我们学的是结构，就只写HTML标签，认识标签就可以了。 不会再给结构标签指定样式了。 HTML标签有很多，这里我们学习最为常用的，后面有些较少用的，我们可以查下手册就可以了。 1.1 排版标签排版标签主要和css搭配使用，显示网页结构的标签，是网页布局最常用的标签。 1）标题标签h (熟记) 单词缩写： head 头部. 标题 title 文档标题 为了使网页更具有语义化，我们经常会在页面中用到标题标签，HTML提供了6个等级的标题，即 标题标签语义： 作为标题使用，并且依据重要性递减 其基本语法格式如下： 123456&lt;h1&gt; 标题文本 &lt;/h1&gt;&lt;h2&gt; 标题文本 &lt;/h2&gt;&lt;h3&gt; 标题文本 &lt;/h3&gt;&lt;h4&gt; 标题文本 &lt;/h4&gt;&lt;h5&gt; 标题文本 &lt;/h5&gt;&lt;h6&gt; 标题文本 &lt;/h6&gt; 显示效果如下： 小结 : 加了标题的文字会变的加粗，字号也会依次变大 一行是只能放一个标题的 1234567传智播客学前端， 前端入门亦简单。 简单知识简单看， 重点勤练写三遍。 标题一共六级选， 具体效果刷新见。 ------pink老师 2）段落标签p ( 熟记)单词缩写： paragraph 段落 [ˈpærəgræf] 无须记这个单词 作用语义： 可以把 HTML 文档分割为若干段落 在网页中要把文字有条理地显示出来，离不开段落标签，就如同我们平常写文章一样，整个网页也可以分为若干个段落，而段落的标签就是 1&lt;p&gt; 文本内容 &lt;/p&gt; 是HTML文档中最常见的标签，默认情况下，文本在一个段落中会根据浏览器窗口的大小自动换行。 3）水平线标签hr(认识)单词缩写： horizontal 横线 [ˌhɔrəˈzɑntl] 同上 在网页中常常看到一些水平线将段落与段落之间隔开，使得文档结构清晰，层次分明。这些水平线可以通过插入图片实现，也可以简单地通过标签来完成，就是创建横跨网页水平线的标签。其基本语法格式如下： 1&lt;hr /&gt;是单标签 在网页中显示默认样式的水平线。 课堂练习:新闻页面 4）换行标签br (熟记)单词缩写： break 打断 ,换行 在HTML中，一个段落中的文字会从左到右依次排列，直到浏览器窗口的右端，然后自动换行。如果希望某段文本强制换行显示，就需要使用换行标签 1&lt;br /&gt; 这时如果还像在word中直接敲回车键换行就不起作用了。 此处有练习题 5）div 和 span标签(重点)div span 是没有语义的 是我们网页布局主要的2个盒子 想必你听过 css+div div 就是 division 的缩写 分割， 分区的意思 其实有很多div 来组合网页。 span 跨度，跨距；范围 语法格式： 1&lt;div&gt; 这是头部 &lt;/div&gt; &lt;span&gt;今日价格&lt;/span&gt; 他们两个都是盒子，用来装我们网页元素的， 只不过他们有区别，现在我们记住 div标签 用来布局的，但是现在一行只能放一个div span标签 用来布局的，一行上可以放好多个span 后面后面讲显示模式的时候，会告诉大家 排版标签总结 标签名 定义 说明 标题标签 作为标题使用，并且依据重要性递减 段落标签 可以把 HTML 文档分割为若干段落 水平线标签 没啥可说的，就是一条线 换行标签 div标签 用来布局的，但是现在一行只能放一个div span标签 用来布局的，一行上可以放好多个span 1.2 文本格式化标签(熟记)在网页中，有时需要为文字设置粗体、斜体或下划线效果，这时就需要用到HTML中的文本格式化标签，使文字以特殊的方式显示。 区别： b 只是加粗 strong 除了可以加粗还有 强调的意思， 语义更强烈。 剩下的同理… 请同学们重点记住 前两组 加粗 和 倾斜 后面两组没记住回来查 1.3 标签属性 所谓属性就是外在特性 比如 手机的颜色 手机的尺寸 ，总结就是手机的。。 手机的颜色是黑色 手机的尺寸是 8寸 水平线的长度是 200 图片的宽度 是 300 使用HTML制作网页时，如果想让HTML标签提供更多的信息，可以使用HTML标签的属性加以设置。其基本语法格式如下： 12&lt;标签名 属性1=\"属性值1\" 属性2=\"属性值2\" …&gt; 内容 &lt;/标签名&gt;&lt;手机 颜色=\"红色\" 大小=\"5寸\"&gt; &lt;/手机&gt; 提倡： 尽量不使用 样式属性。 1.4 图像标签img (重点)单词缩写： image 图像 要想在网页中显示图像就需要使用图像标签，接下来将详细介绍图像标签以及和他相关的属性。（它是一个单身狗） 语法如下： 1&lt;img src=\"图像URL\" /&gt; 该语法中src属性用于指定图像文件的路径和文件名，他是img标签的必需属性。 border 后面我们会用css来做，这里童鞋们就记住这个border 单词就好了 *注意: * 标签可以拥有多个属性，必须写在开始标签中，位于标签名后面。 属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。 任何标签的属性都有默认值，省略该属性则取默认值。 采取 键值对 的格式 key=”value” 的格式 比如: 12345678正常的&lt;br /&gt; &lt;img src=\"cz.jpg\" width=\"300\" height=\"300\" /&gt;&lt;br /&gt; 带有边框的&lt;br /&gt; &lt;img src=\"cz.jpg\" width=\"300\" height=\"300\" border=\"3\" /&gt;&lt;br /&gt;有提示文本的&lt;br /&gt;&lt;img src=\"cz.jpg\" width=\"300\" height=\"300\" border=\"3\" title=\"这是个小蒲公英\" /&gt;&lt;br /&gt;有替换文本的&lt;br /&gt;&lt;img src=\"cz.jpg\" width=\"300\" height=\"300\" border=\"3\" alt=\"图片不存在\" /&gt; 此处有练习题 重点掌握点： 请说出 图像标签那个属性是必须要写的？ img src 图片的路径 请说出 图像标签中 alt 和 title 属性区别？ alt 图片显示不出，文字就显示 title 鼠标经过图片的时候显示文字 1.5 链接标签(重点)单词缩写： anchor 的缩写 [ˈæŋkə(r)] 。基本解释 锚, 铁锚 的 在HTML中创建超链接非常简单，只需用标签把文字包括起来就好。 语法格式： 1&lt;a href=\"跳转目标\" target=\"目标窗口的弹出方式\"&gt;文本或图像&lt;/a&gt; 属性 作用 href 用于指定链接目标的url地址，（必须属性）当为标签应用href属性时，它就具有了超链接的功能 target 用于指定链接页面的打开方式，其取值有_self和_blank两种，其中_self为默认值，_blank为在新窗口中打开方式。 注意： 外部链接 需要添加 http:// www.baidu.com 内部链接 直接链接内部页面名称即可 比如 &lt; a href=”index.html”&gt; 首页 如果当时没有确定链接目标时，通常将链接标签的href属性值定义为“#”(即href=”#”)，表示该链接暂时为一个空链接。 不仅可以创建文本超链接，在网页中各种网页元素，如图像、表格、音频、视频等都可以添加超链接。 重点掌握点： 请说出 链接标签那个属性是必须要写的？ href 请说出 如何新窗口打开这个一个链接网页的？ target=“_blank” 1.6 注释标签在HTML中还有一种特殊的标签——注释标签。如果需要在HTML文档中添加一些便于阅读和理解但又不需要显示在页面中的注释文字，就需要使用注释标签。 简单解释： 注释内容不会显示在浏览器窗口中，但是作为HTML文档内容的一部分，也会被下载到用户的计算机上，查看源代码时就可以看到。 语法格式： 1&lt;!-- 注释语句 --&gt; 快捷键是： ctrl + / 或者 ctrl +shift + / 注释重要性： pink老师 一句话说出他们: 注释是给人看的，目的是为了更好的解释这部分代码是干啥的， 程序是不执行这个代码的 团队约定一般用于简单的描述，如某些状态描述、属性描述等 注释内容前后各一个空格字符，注释位于要注释代码的上面，单独占一行 推荐： 12&lt;!-- Comment Text --&gt;&lt;div&gt;...&lt;/div&gt; 不推荐： 12345&lt;div&gt;...&lt;/div&gt;&lt;!-- Comment Text --&gt; &lt;div&gt;&lt;!-- Comment Text --&gt; ...&lt;/div&gt; 2. 路径(重点、难点) 实际工作中，我们的文件不能随便乱放，否则用起来很难快速的找到他们，因此我们需要一个文件夹来管理他们。 *目录文件夹： * 就是普通文件夹，里面只不过存放了我们做页面所需要的 相关素材，比如 html文件， 图片 等等。 *根目录 * 打开目录文件夹的第一层 就是 根目录 页面中的图片会非常多， 通常我们再新建一个文件夹专门用于存放图像文件（images），这时再插入图像，就需要采用“路径”的方式来指定图像文件的位置。路径可以分为： 相对路径和绝对路径 相对路径以引用文件之网页所在位置为参考基础，而建立出的目录路径。因此，当保存于不同目录的网页引用同一个文件时，所使用的路径将不相同，故称之为相对路径。 路径分类 符号 说明 同一级路径 只需输入图像文件的名称即可，如&lt;img src=”baidu.gif” /&gt;。 下一级路径 “/” 图像文件位于HTML文件同级文件夹下（例如文件夹名称为：images） 如&lt;img src=”images/baidu.gif” /&gt;。 上一级路径 “../” 在文件名之前加入“../” ，如果是上两级，则需要使用 “../ ../”，以此类推， 如&lt;img src=”../baidu.gif” /&gt;。 *pink老师 一句话说出他们: * 相对路径，是从代码所在的这个文件出发， 去寻找我们的目标文件的，而 我们所说的 上一级 下一级 同一级 简单说，就是 图片 位于 HTML 页面的位置 绝对路径绝对路径以Web站点根目录为参考基础的目录路径。之所以称为绝对，意指当所有网页引用同一个文件时，所使用的路径都是一样的。 “D:\\web\\img\\logo.gif”，或完整的网络地址，例如“http://www.itcast.cn/images/logo.gif”。 注意： 绝对路径用的较少，我们理解下就可以了。 但是要注意，它的写法 特别是符号 \\ 并不是 相对路径的 / 3. 今日总结 每一天都有一个主题 我们HTML第一天的主题就是 &lt;认识标签&gt; 能用常用标签，写出最简单的页面 学HTML 之前 觉得 很神秘 等你学完之后忽然发现 5. @拓展阅读5.1 锚点定位 （难点）通过创建锚点链接，用户能够快速定位到目标内容。 创建锚点链接分为两步： 123451. 使用相应的id名标注跳转目标的位置。 (找目标) &lt;h3 id=\"two\"&gt;第2集&lt;/h3&gt; 2. 使用&lt;a href=\"#id名\"&gt;链接文本&lt;/a&gt;创建链接文本（被点击的） （拉关系） 我也有一个姓毕的姥爷.. &lt;a href=\"#two\"&gt; 快速记忆法： 好比找个人办事， 首先找到他，然后拉关系，最后看效果。 5.2 base 标签语法： 1&lt;base target=\"_blank\" /&gt; *总结： * base 可以设置整体链接的打开状态 base 写到 之间 把所有的连接 都默认添加 target=”_blank” pink老师 一句话说出他们: 全体链接~ 到 ~ 全体集合 所有链接 以新窗口打开页面 ~ 是 5.3 预格式化文本pre标签 标签可定义预格式化的文本。 被包围在 标签 元素中的文本通常会保留空格和换行符。而文本也会呈现为等宽字体。 123456789&lt;pre&gt; 此例演示如何使用 pre 标签 对空行和 空格 进行控制&lt;/pre&gt; **pink老师 一句话说出他们:** > 所谓的预格式化文本就是 ，按照我们预先写好的文字格式来显示页面， 保留空格和换行等。 有了这个标签，里面的文字，会按照我们书写的模式显示，不需要段落和换行标签了。但是，比较少用，因为不好整体控制。 #### 5.4 特殊字符 （理解） 一些特殊的符号，我们再html 里面很难或者 不方便直接 使用， 我们此时可以使用下面的替代代码。 ![](HTML-Day03/zifu.png) **虽然有很多，但是我们平时用的比较较少， 大家重点记住 空格 大于号 小于号 就可以了，剩下的回来查阅。** **总结：** 1. 是以**运算符**`&`开头,以**分号运算符**`;`结尾。 2. 他们不是标签，而是符号。 3. HTML 中不能使用小于号 “”特殊字符，浏览器会将它们作为标签解析，若要正确显示，在 HTML 源代码中使用字符实体 **团队约定** *推荐：* 1&lt;a href=&quot;#&quot;&gt;more &amp;gt;&amp;gt;&lt;/a&gt; *不推荐：* 1&lt;a href=&quot;#&quot;&gt;more &gt;&gt; &lt;/a&gt; #### 5.5 html5发展之路 ![](HTML-Day03/html5.png) #### 5.6 什么是XHTML XHTML 是更严格更纯净的 HTML 代码。 - XHTML 指**可扩展超文本标签语言**（EXtensible HyperText Markup Language）。 - XHTML 的目标是取代 HTML。 - XHTML 与 HTML 4.01 几乎是相同的。 - XHTML 是更严格更纯净的 HTML 版本。 - XHTML 是作为一种 XML 应用被重新定义的 HTML。 - XHTML 是一个 W3C 标准。 #### 5.7 HTML和 XHTML之间有什么区别? - XHTML 指的是可扩展超文本标记语言 - XHTML 与 HTML 4.01 几乎是相同的 - XHTML 是更严格更纯净的 HTML 版本 - XHTML 是以 XML 应用的方式定义的 HTML - XHTML 是 2001 年 1 月发布的 W3C 推荐标准 - XHTML 得到所有主流浏览器的支持 - XHTML 元素是以 XML 格式编写的 HTML 元素。XHTML是严格版本的HTML，例如它要求标签必须小写，标签必须被正确关闭，标签顺序必须正确排列，对于属性都必须使用双引号等。 # 6. @深入阅读 [HTML5的崛起之路](http://www.chinaz.com/manage/2015/0720/424831.shtml) # 7. 预习内容 - 表格标签 - 能够通过表格标签能够写出一个简版表格数据展示 例如： ![](HTML-Day03/qq.png) 可以把你今天学习的内容放在表格内，再次作为总结","link":"/前端笔记/html-day03/"},{"title":"javascript-Day01","text":"第03阶段.JavaScript基础.变量 JavaScript基础第01天编程语言编程 编程： 就是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并最终得到结果的过程。 计算机程序： 就是计算机所执行的一系列的指令集合，而程序全部都是用我们所掌握的语言来编写的，所以人们要控制计算机一定要通过计算机语言向计算机发出命令。 计算机语言 计算机语言指用于人与计算机之间通讯的语言，它是人与计算机之间传递信息的媒介。 计算机语言的种类非常的多，总的来说可以分成机器语言，汇编语言和高级语言三大类。 实际上计算机最终所执行的都是 机器语言，它是由“0”和“1”组成的二进制数，二进制是计算机语言的基础。 编程语言12编程语言： 可以通过类似于人类语言的“语言”来控制计算机，让计算机为我们做事情，这样的语言就叫做编程语言（Programming Language）。编程语言是用来控制计算机的一系列指令，它有固定的格式和词汇（不同编程语言的格式和词汇不一样），必须遵守。如今通用的编程语言有两种形式：汇编语言和高级语言。 语言类型 说明 汇编语言 汇编语言和机器语言实质是相同的，都是直接对硬件操作，只不过指令采用了英文缩写的标识符，容易识别和记忆。 高级语言 高级语言主要是相对于低级语言而言，它并不是特指某一种具体的语言，而是包括了很多编程语言，常用的有C语言、C++、Java、C#、Python、PHP、JavaScript、Go语言、Objective-C、Swift等。 翻译器高级语言所编制的程序不能直接被计算机识别，必须经过转换才能被执行，为此，我们需要一个翻译器。翻译器可以将我们所编写的源代码转换为机器语言，这也被称为二进制化。 编程语言和标记语言区别 语言 说明 编程语言 编程语言有很强的逻辑和行为能力。在编程语言里, 你会看到很多 if else 、for 、while等具有逻辑性和行为能力的指令，这是主动的。 标记语言 标记语言（html）不用于向计算机发出指令，常用于格式化和链接。标记语言的存在是用来被读取的, 他是被动的。 总结 计算机可以帮助人类解决某些问题 程序员利用编程语言编写程序发出指令控制计算机来实现这些任务 编程语言有机器语言、汇编语言、高级语言 高级语言需要一个翻译器转换为计算机识别的机器语言 编程语言是主动的有很强的逻辑性 计算机基础计算机组成 数据存储 计算机内部使用二进制 0 和 1来表示数据。 所有数据，包括文件、图片等最终都是以二进制数据（0 和 1）的形式存放在硬盘中的。 所有程序，包括操作系统，本质都是各种数据，也以二进制数据的形式存放在硬盘中。平时我们所说的安装软件，其实就是把程序文件复制到硬盘中。 硬盘、内存都是保存的二进制数据。 数据存储单位1大小关系：bit &lt; byte &lt; kb &lt; GB &lt; TB&lt;..... 位(bit)： 1bit 可以保存一个 0 或者 1 （最小的存储单位） 字节(Byte)：1B = 8b 千字节(KB)：1KB = 1024B 兆字节(MB)：1MB = 1024KB 吉字节(GB): 1GB = 1024MB 太字节(TB): 1TB = 1024GB 程序运行 计算机运行软件的过程： 1. 打开某个程序时，先从硬盘中把程序的代码加载到内存中 2. CPU执行内存中的代码 注意：之所以要内存的一个重要原因，是因为 cpu运行太快了，如果只从硬盘中读数据，会浪费cpu性能，所以，才使用存取速度更快的内存来保存运行时的数据。（内存是电，硬盘是机械）初始JavaScriptJavaScript 是什么 JavaScript 是世界上最流行的语言之一，是一种运行在客户端的脚本语言 （Script 是脚本的意思） 脚本语言：不需要编译，运行过程中由 js 解释器( js 引擎）逐行来进行解释并执行 现在也可以基于 Node.js 技术进行服务器端编程 JavaScript的作用 表单动态校验（密码强度检测） （ JS 产生最初的目的 ） 网页特效 服务端开发(Node.js) 桌面程序(Electron) App(Cordova) 控制硬件-物联网(Ruff) 游戏开发(cocos2d-js) HTML/CSS/JS 的关系 浏览器执行 JS 简介浏览器分成两部分：渲染引擎和 JS 引擎 浏览器本身并不会执行JS代码，而是通过内置 JavaScript 引擎(解释器) 来执行 JS 代码 。JS 引擎执行代码时逐行解释每一句源码（转换为机器语言），然后由计算机去执行，所以 JavaScript 语言归为脚本语言，会逐行解释执行。 JS 的组成 ECMAScript​ ECMAScript 是由ECMA 国际（ 原欧洲计算机制造商协会）进行标准化的一门编程语言，这种语言在万维网上应用广泛，它往往被称为 JavaScript或 JScript，但实际上后两者是 ECMAScript 语言的实现和扩展。 ​ ECMAScript：规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准。 更多参看MDN: MDN手册 DOM——文档对象模型​ 文档对象模型（DocumentObject Model，简称DOM），是W3C组织推荐的处理可扩展标记语言的标准编程接口。通过 DOM 提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色等） BOM——浏览器对象模型​ 浏览器对象模型(Browser Object Model，简称BOM) 是指浏览器对象模型，它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。 JS 初体验JS 有3种书写位置，分别为行内、内嵌和外部。 行内式 1&lt;input type=\"button\" value=\"点我试试\" onclick=\"alert('Hello World')\" /&gt; 可以将单行或少量 JS 代码写在HTML标签的事件属性中（以 on 开头的属性），如：onclick 注意单双引号的使用：在HTML中我们推荐使用双引号, JS 中我们推荐使用单引号 可读性差， 在html中编写JS大量代码时，不方便阅读； 引号易错，引号多层嵌套匹配时，非常容易弄混； 特殊情况下使用 内嵌式 123&lt;script&gt; alert('Hello World~!');&lt;/script&gt; 可以将多行JS代码写到 script 标签中 内嵌 JS 是学习时常用的方式 外部JS文件 1&lt;script src=\"my.js\"&gt;&lt;/script&gt; 利于HTML页面代码结构化，把大段 JS代码独立到 HTML 页面之外，既美观，也方便文件级别的复用 引用外部 JS文件的 script 标签中间不可以写代码 适合于JS 代码量比较大的情况 JavaScript注释 flex子项目占的份数 align-self控制子项自己在侧轴的排列方式 order属性定义子项的排列顺序（前后顺序） 单行注释为了提高代码的可读性，JS与CSS一样，也提供了注释功能。 JS中的注释主要有两种，分别是 单行注释 和 多行注释。单行注释的注释方式如下： 1// 我是一行文字，不想被 JS引擎 执行，所以 注释起来 // 用来注释单行文字（ 快捷键 ctrl + / ）多行注释多行注释的注释方式如下： 1234/* 获取用户年龄和姓名 并通过提示框显示出来*/ 1/* */ 用来注释多行文字（ 默认快捷键 alt + shift + a ） 快捷键修改为： ctrl + shift + / vscode → 首选项按钮 → 键盘快捷方式 → 查找 原来的快捷键 → 修改为新的快捷键 → 回车确认 JavaScript输入输出语句为了方便信息的输入输出，JS中提供了一些输入输出语句，其常用的语句如下： 方法 说明 归属 alert(msg) 浏览器弹出警示框 浏览器 console.log(msg) 浏览器控制台打印输出信息 浏览器 prompt(info) 浏览器弹出输入框，用户可以输入 浏览器 注意：alert() 主要用来显示消息给用户，console.log() 用来给程序员自己看运行时的消息。 变量的概念什么是变量白话：变量就是一个装东西的盒子。 通俗：变量是用于存放数据的容器。 我们通过 变量名 获取数据，甚至数据可以修改。 变量在内存中的存储本质：变量是程序在内存中申请的一块用来存放数据的空间。类似我们酒店的房间，一个房间就可以看做是一个变量。 变量的使用 变量的声明 变量的赋值 声明变量12// 声明变量 var age; // 声明一个 名称为age 的变量 var 是一个 JS关键字，用来声明变量( variable 变量的意思 )。使用该关键字声明变量后，计算机会自动为变量分配内存空间，不需要程序员管 age 是程序员定义的变量名，我们要通过变量名来访问内存中分配的空间 赋值1age = 10; // 给 age 这个变量赋值为 10 = 用来把右边的值赋给左边的变量空间中 此处代表赋值的意思 变量值是程序员保存到变量空间里的值 变量的初始化12var age = 18; // 声明变量同时赋值为 18// 声明一个变量并赋值， 我们称之为变量的初始化。 变量语法扩展 更新变量 ​ 一个变量被重新复赋值后，它原有的值就会被覆盖，变量值将以最后一次赋的值为准。 123var age = 18;age = 81; // 最后的结果就是81因为18 被覆盖掉了 同时声明多个变量 ​ 同时声明多个变量时，只需要写一个 var， 多个变量名之间使用英文逗号隔开。 1var age = 10, name = 'zs', sex = 2; 声明变量特殊情况 情况 说明 结果 var age ; console.log (age); 只声明 不赋值 undefined console.log(age) 不声明 不赋值 直接使用 报错 age = 10; console.log (age); 不声明 只赋值 10 变量命名规范规则： 由字母(A-Za-z)、数字(0-9)、下划线(_)、美元符号( $ )组成，如：usrAge, num01, _name 严格区分大小写。var app; 和 var App; 是两个变量 不能 以数字开头。 18age 是错误的 不能 是关键字、保留字。例如：var、for、while 变量名必须有意义。 MMD BBD nl → age 遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。myFirstName 推荐翻译网站： 有道 爱词霸 数据类型数据类型简介 为什么需要数据类型 ​ 在计算机中，不同的数据所需占用的存储空间是不同的，为了便于把数据分成所需内存大小不同的数据，充分利用存储空间，于是定义了不同的数据类型。 简单来说，数据类型就是数据的类别型号。比如姓名“张三”，年龄18，这些数据的类型是不一样的。 变量的数据类型 ​ 变量是用来存储值的所在处，它们有名字和数据类型。变量的数据类型决定了如何将代表这些值的位存储到计算机的内存中。JavaScript 是一种弱类型或者说动态语言。这意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定： 12var age = 10; // 这是一个数字型var areYouOk = '是的'; // 这是一个字符串 ​ 在代码运行时，变量的数据类型是由 JS引擎 根据 = 右边变量值的数据类型来判断 的，运行完毕之后， 变量就确定了数据类型。JavaScript 拥有动态类型，同时也意味着相同的变量可用作不同的类型： 12var x = 6; // x 为数字var x = \"Bill\"; // x 为字符串 数据类型的分类 JS 把数据类型分为两类： 简单数据类型 （Number,String,Boolean,Undefined,Null） 复杂数据类型 （object) 简单数据类型简单数据类型（基本数据类型） JavaScript 中的简单数据类型及其说明如下： 数字型 Number ​ JavaScript 数字类型既可以保存整数，也可以保存小数(浮点数）。 12var age = 21; // 整数var Age = 21.3747; // 小数 数字型进制 最常见的进制有二进制、八进制、十进制、十六进制。 123456 // 1.八进制数字序列范围：0~7var num1 = 07; // 对应十进制的7var num2 = 019; // 对应十进制的19var num3 = 08; // 对应十进制的8 // 2.十六进制数字序列范围：0~9以及A~Fvar num = 0xA; 现阶段我们只需要记住，在JS中八进制前面加0，十六进制前面加 0x 数字型范围 JavaScript中数值的最大和最小值 最大值：Number.MAX_VALUE，这个值为： 1.7976931348623157e+308 最小值：Number.MIN_VALUE，这个值为：5e-32 数字型三个特殊值 Infinity ，代表无穷大，大于任何数值 -Infinity ，代表无穷小，小于任何数值 NaN ，Not a number，代表一个非数值 isNaN 用来判断一个变量是否为非数字的类型，返回 true 或者 false 12345 var usrAge = 21;var isOk = isNaN(userAge); console.log(isNum); // false ，21 不是一个非数字var usrName = \"andy\"; console.log(isNaN(userName));// true ，\"andy\"是一个非数字 字符串型 String ​ 字符串型可以是引号中的任意文本，其语法为 双引号 “” 和 单引号’’ 1234var strMsg = \"我爱北京天安门~\"; // 使用双引号表示字符串var strMsg2 = '我爱吃猪蹄~'; // 使用单引号表示字符串// 常见错误var strMsg3 = 我爱大肘子; // 报错，没使用引号，会被认为是js代码，但js没有这些语法 ​ 因为 HTML 标签里面的属性使用的是双引号，JS 这里我们更推荐使用单引号。 字符串引号嵌套 ​ JS 可以用单引号嵌套双引号 ，或者用双引号嵌套单引号 (外双内单，外单内双) 1234var strMsg = '我是\"高帅富\"程序猿'; // 可以用''包含\"\"var strMsg2 = \"我是'高帅富'程序猿\"; // 也可以用\"\" 包含''// 常见错误var badQuotes = 'What on earth?\"; // 报错，不能 单双引号搭配 字符串转义符 ​ 类似HTML里面的特殊字符，字符串中也有特殊字符，我们称之为转义符。 ​ 转义符都是 \\ 开头的，常用的转义符及其说明如下： 转义符 解释说明 \\n 换行符，n 是 newline 的意思 \\ \\ 斜杠 \\ ' ‘ 单引号 &quot; ”双引号 \\t tab 缩进 \\b 空格 ，b 是 blank 的意思 字符串长度 ​ 字符串是由若干字符组成的，这些字符的数量就是字符串的长度。通过字符串的 length 属性可以获取整个字符串的长度。 12var strMsg = \"我是帅气多金的程序猿！\";alert(strMsg.length); // 显示 11 字符串拼接 多个字符串之间可以使用 + 进行拼接，其拼接方式为 字符串 + 任何类型 = 拼接之后的新字符串 拼接前会把与字符串相加的任何类型转成字符串，再拼接成一个新的字符串 123456//1.1 字符串 \"相加\"alert('hello' + ' ' + 'world'); // hello world//1.2 数值字符串 \"相加\"alert('100' + '100'); // 100100//1.3 数值字符串 + 数值alert('11' + 12); // 1112 + 号总结口诀：数值相加 ，字符相连 字符串拼接加强 12345console.log('pink老师' + 18); // 只要有字符就会相连 var age = 18;console.log('pink老师age岁啦'); // 这样不行哦console.log('pink老师' + age); // pink老师18console.log('pink老师' + age + '岁啦'); // pink老师18岁啦 经常会将字符串和变量来拼接，变量可以很方便地修改里面的值 变量是不能添加引号的，因为加引号的变量会变成字符串 如果变量两侧都有字符串拼接，口诀“引引加加 ”，删掉数字，变量写加中间 布尔型Boolean ​ 布尔类型有两个值：true 和 false ，其中 true 表示真（对），而 false 表示假（错）。 ​ 布尔型和数字型相加的时候， true 的值为 1 ，false 的值为 0。 12console.log(true + 1); // 2console.log(false + 1); // 1 Undefined和 Null ​ 一个声明后没有被赋值的变量会有一个默认值undefined ( 如果进行相连或者相加时，注意结果） 12345var variable;console.log(variable); // undefinedconsole.log('你好' + variable); // 你好undefinedconsole.log(11 + variable); // NaNconsole.log(true + variable); // NaN ​ 一个声明变量给 null 值，里面存的值为空（学习对象时，我们继续研究null) 1234var vari = null;console.log('你好' + vari); // 你好nullconsole.log(11 + vari); // 11console.log(true + vari); // 1 获取变量数据类型 获取检测变量的数据类型 ​ typeof 可用来获取检测变量的数据类型 12var num = 18;console.log(typeof num) // 结果 number ​ 不同类型的返回值 字面量 ​ 字面量是在源代码中一个固定值的表示法，通俗来说，就是字面量表示如何表达这个值。 数字字面量：8, 9, 10 字符串字面量：’黑马程序员’, “大前端” 布尔字面量：true，false 数据类型转换​ 什么是数据类型转换？ ​ 使用表单、prompt 获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算，而需要转换变量的数据类型。通俗来说，就是把一种数据类型的变量转换成另一种数据类型，通常会实现3种方式的转换： 123转换为字符串类型转换为数字型转换为布尔型 转换为字符串 toString() 和 String() 使用方式不一样。 三种转换方式，更多第三种加号拼接字符串转换方式， 这一种方式也称之为隐式转换。 转换为数字型（重点） 注意 parseInt 和 parseFloat 单词的大小写，这2个是重点 隐式转换是我们在进行算数运算的时候，JS 自动转换了数据类型 转换为布尔型 代表空、否定的值会被转换为 false ，如 ‘’、0、NaN、null、undefined 其余值都会被转换为 true 1234567console.log(Boolean('')); // falseconsole.log(Boolean(0)); // falseconsole.log(Boolean(NaN)); // falseconsole.log(Boolean(null)); // falseconsole.log(Boolean(undefined)); // falseconsole.log(Boolean('小白')); // trueconsole.log(Boolean(12)); // true 解释型语言和编译型语言概述计算机不能直接理解任何除机器语言以外的语言，所以必须要把程序员所写的程序语言翻译成机器语言才能执行程序。程序语言翻译成机器语言的工具，被称为翻译器。 翻译器翻译的方式有两种：一个是编译，另外一个是解释。两种方式之间的区别在于翻译的时间点不同 编译器是在代码执行之前进行编译，生成中间代码文件 解释器是在运行时进行及时解释，并立即执行(当编译器以解释方式运行的时候，也称之为解释器) 执行过程 类似于请客吃饭： 编译语言：首先把所有菜做好，才能上桌吃饭 解释语言：好比吃火锅，边吃边涮，同时进行关键字和保留字标识符标识(zhi)符：就是指开发人员为变量、属性、函数、参数取的名字。 标识符不能是关键字或保留字。关键字关键字：是指 JS本身已经使用了的字，不能再用它们充当变量名、方法名。 包括：break、case、catch、continue、default、delete、do、else、finally、for、function、if、in、instanceof、new、return、switch、this、throw、try、typeof、var、void、while、with 等。保留字保留字：实际上就是预留的“关键字”，意思是现在虽然还不是关键字，但是未来可能会成为关键字，同样不能使用它们当变量名或方法名。 包括：boolean、byte、char、class、const、debugger、double、enum、export、extends、fimal、float、goto、implements、import、int、interface、long、mative、package、private、protected、public、short、static、super、synchronized、throws、transient、volatile 等。 注意：如果将保留字用作变量名或函数名，那么除非将来的浏览器实现了该保留字，否则很可能收不到任何错误消息。当浏览器将其实现后，该单词将被看做关键字，如此将出现关键字错误。","link":"/前端笔记/javascript-day01/"},{"title":"WebAPIs-Day01","text":"第03阶段.JavaScript基础.操作元素 Web API介绍API的概念API（Application Programming Interface，应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，无需理解其内部工作机制细节，只需直接调用使用即可。 举例解释什么是API。 例如， ​ C语言中有一个函数 fopen()可以打开硬盘上的文件，这个函数对于我们来说，就是一个C语言提供的打开文件的工具。 ​ javascript中有一个函数alert()可以在页面弹一个提示框，这个函数就是js提供的一个弹框工具。 这些工具（函数）由编程语言提供，内部的实现已经封装好了，我们只要学会灵活的使用这些工具即可。 Web API的概念​ Web API 是浏览器提供的一套操作浏览器功能和页面元素的 API ( BOM 和 DOM )。 ​ 现阶段我们主要针对于浏览器讲解常用的 API , 主要针对浏览器做交互效果。比如我们想要浏览器弹出一个警示框， 直接使用 alert(‘弹出’) ​ MDN 详细 API : https://developer.mozilla.org/zh-CN/docs/Web/API ​ 因为 Web API 很多，所以我们将这个阶段称为 Web APIs。 ​ 此处的 Web API 特指浏览器提供的一系列API(很多函数或对象方法)，即操作网页的一系列工具。例如：操作html标签、操作页面地址的方法。 API 和 Web API 总结 API 是为我们程序员提供的一个接口，帮助我们实现某种功能，我们会使用就可以了，不必纠结内部如何实现 Web API 主要是针对于浏览器提供的接口，主要针对于浏览器做交互效果。 Web API 一般都有输入和输出（函数的传参和返回值），Web API 很多都是方法（函数） 学习 Web API 可以结合前面学习内置对象方法的思路学习 DOM 介绍什么是DOM​ 文档对象模型（Document Object Model，简称DOM），是 W3C 组织推荐的处理可扩展标记语言（html或者xhtml）的标准编程接口。 ​ W3C 已经定义了一系列的 DOM 接口，通过这些 DOM 接口可以改变网页的内容、结构和样式。 DOM是W3C组织制定的一套处理 html和xml文档的规范，所有的浏览器都遵循了这套标准。 DOM树 DOM树 又称为文档树模型，把文档映射成树形结构，通过节点对象对其处理，处理的结果可以加入到当前的页面。 文档：一个页面就是一个文档，DOM中使用document表示 节点：网页中的所有内容，在文档树中都是节点（标签、属性、文本、注释等），使用node表示 标签节点：网页中的所有标签，通常称为元素节点，又简称为“元素”，使用element表示 获取元素为什么要获取页面元素？ 例如：我们想要操作页面上的某部分(显示/隐藏，动画)，需要先获取到该部分对应的元素，再对其进行操作。 根据ID获取1234语法：document.getElementById(id)作用：根据ID获取元素对象参数：id值，区分大小写的字符串返回值：元素对象 或 null 案例代码 1234567891011&lt;body&gt; &lt;div id=\"time\"&gt;2019-9-9&lt;/div&gt; &lt;script&gt; // 因为我们文档页面从上往下加载，所以先得有标签 所以我们script写到标签的下面 var timer = document.getElementById('time'); console.log(timer); console.log(typeof timer); // console.dir 打印我们返回的元素对象 更好的查看里面的属性和方法 console.dir(timer); &lt;/script&gt;&lt;/body&gt; 根据标签名获取元素1234语法：document.getElementsByTagName(&apos;标签名&apos;) 或者 element.getElementsByTagName(&apos;标签名&apos;) 作用：根据标签名获取元素对象参数：标签名返回值：元素对象集合（伪数组，数组元素是元素对象） 案例代码 123456789101112131415161718192021222324252627282930&lt;body&gt; &lt;ul&gt; &lt;li&gt;知否知否，应是等你好久11&lt;/li&gt; &lt;li&gt;知否知否，应是等你好久22&lt;/li&gt; &lt;li&gt;知否知否，应是等你好久33&lt;/li&gt; &lt;li&gt;知否知否，应是等你好久44&lt;/li&gt; &lt;li&gt;知否知否，应是等你好久55&lt;/li&gt; &lt;/ul&gt; &lt;ul id=\"nav\"&gt; &lt;li&gt;生僻字&lt;/li&gt; &lt;li&gt;生僻字&lt;/li&gt; &lt;li&gt;生僻字&lt;/li&gt; &lt;li&gt;生僻字&lt;/li&gt; &lt;li&gt;生僻字&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // 1.返回的是 获取过来元素对象的集合 以伪数组的形式存储的 var lis = document.getElementsByTagName('li'); console.log(lis); console.log(lis[0]); // 2. 我们想要依次打印里面的元素对象我们可以采取遍历的方式 for (var i = 0; i &lt; lis.length; i++) { console.log(lis[i]); } // 3. element.getElementsByTagName() 可以得到这个元素里面的某些标签 var nav = document.getElementById('nav'); // 这个获得nav 元素 var navLis = nav.getElementsByTagName('li'); console.log(navLis); &lt;/script&gt;&lt;/body&gt; 注意：getElementsByTagName()获取到是动态集合，即：当页面增加了标签，这个集合中也就增加了元素。 H5新增获取元素方式 案例代码 123456789101112131415161718192021222324252627&lt;body&gt; &lt;div class=\"box\"&gt;盒子1&lt;/div&gt; &lt;div class=\"box\"&gt;盒子2&lt;/div&gt; &lt;div id=\"nav\"&gt; &lt;ul&gt; &lt;li&gt;首页&lt;/li&gt; &lt;li&gt;产品&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; // 1. getElementsByClassName 根据类名获得某些元素集合 var boxs = document.getElementsByClassName('box'); console.log(boxs); // 2. querySelector 返回指定选择器的第一个元素对象 切记 里面的选择器需要加符号 .box #nav var firstBox = document.querySelector('.box'); console.log(firstBox); var nav = document.querySelector('#nav'); console.log(nav); var li = document.querySelector('li'); console.log(li); // 3. querySelectorAll()返回指定选择器的所有元素对象集合 var allBox = document.querySelectorAll('.box'); console.log(allBox); var lis = document.querySelectorAll('li'); console.log(lis); &lt;/script&gt;&lt;/body&gt; 获取特殊元素（body，html） 事件基础事件概述JavaScript 使我们有能力创建动态页面，而事件是可以被 JavaScript 侦测到的行为。 简单理解： 触发— 响应机制。 ​ 网页中的每个元素都可以产生某些可以触发 JavaScript 的事件，例如，我们可以在用户点击某按钮时产生一个 事件，然后去执行某些操作。 事件三要素 事件源（谁）：触发事件的元素 事件类型（什么事件）： 例如 click 点击事件 事件处理程序（做啥）：事件触发后要执行的代码(函数形式)，事件处理函数 案例代码 1234567891011121314&lt;body&gt; &lt;button id=\"btn\"&gt;唐伯虎&lt;/button&gt; &lt;script&gt; // 点击一个按钮，弹出对话框 // 1. 事件是有三部分组成 事件源 事件类型 事件处理程序 我们也称为事件三要素 //(1) 事件源 事件被触发的对象 谁 按钮 var btn = document.getElementById('btn'); //(2) 事件类型 如何触发 什么事件 比如鼠标点击(onclick) 还是鼠标经过 还是键盘按下 //(3) 事件处理程序 通过一个函数赋值的方式 完成 btn.onclick = function() { alert('点秋香'); } &lt;/script&gt;&lt;/body&gt; 执行事件的步骤 案例代码 123456789101112131415&lt;body&gt; &lt;div&gt;123&lt;/div&gt; &lt;script&gt; // 执行事件步骤 // 点击div 控制台输出 我被选中了 // 1. 获取事件源 var div = document.querySelector('div'); // 2.绑定事件 注册事件 // div.onclick // 3.添加事件处理程序 div.onclick = function() { console.log('我被选中了'); } &lt;/script&gt;&lt;/body&gt; 常见的鼠标事件 分析事件三要素 下拉菜单三要素 关闭广告三要素 操作元素​ JavaScript的 DOM 操作可以改变网页内容、结构和样式，我们可以利用 DOM 操作元素来改变元素里面的内容、属性等。（注意：这些操作都是通过元素对象的属性实现的） 改变元素内容（获取或设置） innerText改变元素内容 1234567891011121314151617181920212223242526&lt;body&gt; &lt;button&gt;显示当前系统时间&lt;/button&gt; &lt;div&gt;某个时间&lt;/div&gt; &lt;p&gt;1123&lt;/p&gt; &lt;script&gt; // 当我们点击了按钮， div里面的文字会发生变化 // 1. 获取元素 var btn = document.querySelector('button'); var div = document.querySelector('div'); // 2.注册事件 btn.onclick = function() { // div.innerText = '2019-6-6'; div.innerHTML = getDate(); } function getDate() { var date = new Date(); // 我们写一个 2019年 5月 1日 星期三 var year = date.getFullYear(); var month = date.getMonth() + 1; var dates = date.getDate(); var arr = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六']; var day = date.getDay(); return '今天是：' + year + '年' + month + '月' + dates + '日 ' + arr[day]; } &lt;/script&gt;&lt;/body&gt; innerText和innerHTML的区别 获取内容时的区别： ​ innerText会去除空格和换行，而innerHTML会保留空格和换行 设置内容时的区别： ​ innerText不会识别html，而innerHTML会识别 案例代码 12345678910111213141516171819&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;p&gt; 我是文字 &lt;span&gt;123&lt;/span&gt; &lt;/p&gt; &lt;script&gt; // innerText 和 innerHTML的区别 // 1. innerText 不识别html标签 非标准 去除空格和换行 var div = document.querySelector('div'); // div.innerText = '&lt;strong&gt;今天是：&lt;/strong&gt; 2019'; // 2. innerHTML 识别html标签 W3C标准 保留空格和换行的 div.innerHTML = '&lt;strong&gt;今天是：&lt;/strong&gt; 2019'; // 这两个属性是可读写的 可以获取元素里面的内容 var p = document.querySelector('p'); console.log(p.innerText); console.log(p.innerHTML); &lt;/script&gt;&lt;/body&gt; 常用元素的属性操作 获取属性的值 元素对象.属性名 设置属性的值 元素对象.属性名 = 值 案例代码 123456789101112131415161718192021&lt;body&gt; &lt;button id=\"ldh\"&gt;刘德华&lt;/button&gt; &lt;button id=\"zxy\"&gt;张学友&lt;/button&gt; &lt;br&gt; &lt;img src=\"images/ldh.jpg\" alt=\"\" title=\"刘德华\"&gt; &lt;script&gt; // 修改元素属性 src // 1. 获取元素 var ldh = document.getElementById('ldh'); var zxy = document.getElementById('zxy'); var img = document.querySelector('img'); // 2. 注册事件 处理程序 zxy.onclick = function() { img.src = 'images/zxy.jpg'; img.title = '张学友思密达'; } ldh.onclick = function() { img.src = 'images/ldh.jpg'; img.title = '刘德华'; } &lt;/script&gt;&lt;/body&gt; 案例：分时问候 表单元素的属性操作 获取属性的值 元素对象.属性名 设置属性的值 元素对象.属性名 = 值 表单元素中有一些属性如：disabled、checked、selected，元素对象的这些属性的值是布尔型。 案例代码 123456789101112131415161718&lt;body&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;input type=\"text\" value=\"输入内容\"&gt; &lt;script&gt; // 1. 获取元素 var btn = document.querySelector('button'); var input = document.querySelector('input'); // 2. 注册事件 处理程序 btn.onclick = function() { // 表单里面的值 文字内容是通过 value 来修改的 input.value = '被点击了'; // 如果想要某个表单被禁用 不能再点击 disabled 我们想要这个按钮 button禁用 // btn.disabled = true; this.disabled = true; // this 指向的是事件函数的调用者 btn } &lt;/script&gt;&lt;/body&gt; 案例：仿京东显示密码 样式属性操作我们可以通过 JS 修改元素的大小、颜色、位置等样式。 常用方式 方式1：通过操作style属性 元素对象的style属性也是一个对象！ 元素对象.style.样式属性 = 值; 案例代码 12345678910111213&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; // 1. 获取元素 var div = document.querySelector('div'); // 2. 注册事件 处理程序 div.onclick = function() { // div.style里面的属性 采取驼峰命名法 this.style.backgroundColor = 'purple'; this.style.width = '250px'; } &lt;/script&gt;&lt;/body&gt; 案例：淘宝点击关闭二维码 案例：循环精灵图背景 案例：显示隐藏文本框内容 方式2：通过操作className属性 元素对象.className = 值; 因为class是关键字，所有使用className。 案例代码 123456789101112131415161718&lt;body&gt; &lt;div class=\"first\"&gt;文本&lt;/div&gt; &lt;script&gt; // 1. 使用 element.style 获得修改元素样式 如果样式比较少 或者 功能简单的情况下使用 var test = document.querySelector('div'); test.onclick = function() { // this.style.backgroundColor = 'purple'; // this.style.color = '#fff'; // this.style.fontSize = '25px'; // this.style.marginTop = '100px'; // 2. 我们可以通过 修改元素的className更改元素的样式 适合于样式较多或者功能复杂的情况 // 3. 如果想要保留原先的类名，我们可以这么做 多类名选择器 // this.className = 'change'; this.className = 'first change'; } &lt;/script&gt;&lt;/body&gt; 案例：密码框格式提示错误信息","link":"/前端笔记/webapis-day01/"},{"title":"WebAPIs-Day03","text":"第03阶段.JavaScript基础.事件 学习目标： 能够使用removeChild()方法删除节点 能够完成动态生成表格案例 能够使用传统方式和监听方式给元素注册事件 能够说出事件流执行的三个阶段 能够在事件处理函数中获取事件对象 能够使用事件对象取消默认行为 能够使用事件对象阻止事件冒泡 能够使用事件对象获取鼠标的位置 能够完成跟随鼠标的天使案例 节点操作删除节点 node.removeChild() 方法从 node节点中删除一个子节点，返回删除的节点。 123456789101112131415161718192021&lt;button&gt;删除&lt;/button&gt;&lt;ul&gt; &lt;li&gt;熊大&lt;/li&gt; &lt;li&gt;熊二&lt;/li&gt; &lt;li&gt;光头强&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; // 1.获取元素 var ul = document.querySelector('ul'); var btn = document.querySelector('button'); // 2. 删除元素 node.removeChild(child) // ul.removeChild(ul.children[0]); // 3. 点击按钮依次删除里面的孩子 btn.onclick = function() { if (ul.children.length == 0) { this.disabled = true; } else { ul.removeChild(ul.children[0]); } }&lt;/script&gt; 案例：删除留言 1234567891011121314151617181920212223242526272829303132333435&lt;textarea name=\"\" id=\"\"&gt;&lt;/textarea&gt;&lt;button&gt;发布&lt;/button&gt;&lt;ul&gt;&lt;/ul&gt;&lt;script&gt; // 1. 获取元素 var btn = document.querySelector('button'); var text = document.querySelector('textarea'); var ul = document.querySelector('ul'); // 2. 注册事件 btn.onclick = function() { if (text.value == '') { alert('您没有输入内容'); return false; } else { // console.log(text.value); // (1) 创建元素 var li = document.createElement('li'); // 先有li 才能赋值 li.innerHTML = text.value + \"&lt;a href='javascript:;'&gt;删除&lt;/a&gt;\"; // (2) 添加元素 // ul.appendChild(li); ul.insertBefore(li, ul.children[0]); // (3) 删除元素 删除的是当前链接的li 它的父亲 var as = document.querySelectorAll('a'); for (var i = 0; i &lt; as.length; i++) { as[i].onclick = function() { // 删除的是 li 当前a所在的li this.parentNode; ul.removeChild(this.parentNode); } } } }&lt;/script&gt; 复制（克隆）节点 123456789101112&lt;ul&gt; &lt;li&gt;1111&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; var ul = document.querySelector('ul'); // 1. node.cloneNode(); 括号为空或者里面是false 浅拷贝 只复制标签不复制里面的内容 // 2. node.cloneNode(true); 括号为true 深拷贝 复制标签复制里面的内容 var lili = ul.children[0].cloneNode(true); ul.appendChild(lili);&lt;/script&gt; 案例：动态生成表格 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 &lt;script&gt; // 1.先去准备好学生的数据 var datas = [{ name: '魏璎珞', subject: 'JavaScript', score: 100 }, { name: '弘历', subject: 'JavaScript', score: 98 }, { name: '傅恒', subject: 'JavaScript', score: 99 }, { name: '明玉', subject: 'JavaScript', score: 88 }, { name: '大猪蹄子', subject: 'JavaScript', score: 0 }]; // 2. 往tbody 里面创建行： 有几个人（通过数组的长度）我们就创建几行 var tbody = document.querySelector('tbody');// 遍历数组 for (var i = 0; i &lt; datas.length; i++) { // 1. 创建 tr行 var tr = document.createElement('tr'); tbody.appendChild(tr); // 2. 行里面创建单元格td 单元格的数量取决于每个对象里面的属性个数 // 使用for in遍历学生对象 for (var k in datas[i]) { // 创建单元格 var td = document.createElement('td'); // 把对象里面的属性值 datas[i][k] 给 td td.innerHTML = datas[i][k]; tr.appendChild(td); } // 3. 创建有删除2个字的单元格 var td = document.createElement('td'); td.innerHTML = '&lt;a href=\"javascript:;\"&gt;删除 &lt;/a&gt;'; tr.appendChild(td); } // 4. 删除操作 开始 var as = document.querySelectorAll('a'); for (var i = 0; i &lt; as.length; i++) { as[i].onclick = function() { // 点击a 删除 当前a 所在的行(链接的爸爸的爸爸) node.removeChild(child) tbody.removeChild(this.parentNode.parentNode) } } &lt;/script&gt; 创建元素的三种方式 12345678910111213141516171819202122232425&lt;script&gt; // 三种创建元素方式区别 // 1. document.write() 创建元素 如果页面文档流加载完毕，再调用这句话会导致页面重绘 var btn = document.querySelector('button'); btn.onclick = function() { document.write('&lt;div&gt;123&lt;/div&gt;'); } // 2. innerHTML 创建元素 var inner = document.querySelector('.inner'); for (var i = 0; i &lt;= 100; i++) { inner.innerHTML += '&lt;a href=\"#\"&gt;百度&lt;/a&gt;' } var arr = []; for (var i = 0; i &lt;= 100; i++) { arr.push('&lt;a href=\"#\"&gt;百度&lt;/a&gt;'); } inner.innerHTML = arr.join(''); // 3. document.createElement() 创建元素 var create = document.querySelector('.create'); for (var i = 0; i &lt;= 100; i++) { var a = document.createElement('a'); create.appendChild(a); }&lt;/script&gt; innerTHML和createElement效率对比innerHTML字符串拼接方式（效率低） 123456789101112&lt;script&gt; function fn() { var d1 = +new Date(); var str = ''; for (var i = 0; i &lt; 1000; i++) { document.body.innerHTML += '&lt;div style=\"width:100px; height:2px; border:1px solid blue;\"&gt;&lt;/div&gt;'; } var d2 = +new Date(); console.log(d2 - d1); } fn();&lt;/script&gt; createElement方式（效率一般） 12345678910111213141516&lt;script&gt; function fn() { var d1 = +new Date(); for (var i = 0; i &lt; 1000; i++) { var div = document.createElement('div'); div.style.width = '100px'; div.style.height = '2px'; div.style.border = '1px solid red'; document.body.appendChild(div); } var d2 = +new Date(); console.log(d2 - d1); } fn();&lt;/script&gt; innerHTML数组方式（效率高） 12345678910111213&lt;script&gt; function fn() { var d1 = +new Date(); var array = []; for (var i = 0; i &lt; 1000; i++) { array.push('&lt;div style=\"width:100px; height:2px; border:1px solid blue;\"&gt;&lt;/div&gt;'); } document.body.innerHTML = array.join(''); var d2 = +new Date(); console.log(d2 - d1); } fn();&lt;/script&gt; DOM的核心总结 关于dom操作，我们主要针对于元素的操作。主要有创建、增、删、改、查、属性操作、事件操作。 创建 增 删 改 查 属性操作 事件高级（重点）注册事件（2种方式） 事件监听addEventListener()事件监听（IE9以后支持） eventTarget.addEventListener()方法将指定的监听器注册到 eventTarget（目标对象）上，当该对象触发指定的事件时，就会执行事件处理函数。 attacheEvent()事件监听（IE678支持） ​ eventTarget.attachEvent()方法将指定的监听器注册到 eventTarget（目标对象） 上，当该对象触发指定的事件时，指定的回调函数就会被执行。 1234567891011121314151617181920212223242526&lt;button&gt;传统注册事件&lt;/button&gt;&lt;button&gt;方法监听注册事件&lt;/button&gt;&lt;button&gt;ie9 attachEvent&lt;/button&gt;&lt;script&gt; var btns = document.querySelectorAll('button'); // 1. 传统方式注册事件 btns[0].onclick = function() { alert('hi'); } btns[0].onclick = function() { alert('hao a u'); } // 2. 事件侦听注册事件 addEventListener // (1) 里面的事件类型是字符串 必定加引号 而且不带on // (2) 同一个元素 同一个事件可以添加多个侦听器（事件处理程序） btns[1].addEventListener('click', function() { alert(22); }) btns[1].addEventListener('click', function() { alert(33); }) // 3. attachEvent ie9以前的版本支持 btns[2].attachEvent('onclick', function() { alert(11); })&lt;/script&gt; 事件监听兼容性解决方案封装一个函数，函数中判断浏览器的类型： 删除事件（解绑事件） 123456789101112131415161718192021222324&lt;div&gt;1&lt;/div&gt;&lt;div&gt;2&lt;/div&gt;&lt;div&gt;3&lt;/div&gt;&lt;script&gt; var divs = document.querySelectorAll('div'); divs[0].onclick = function() { alert(11); // 1. 传统方式删除事件 divs[0].onclick = null; } // 2. removeEventListener 删除事件 divs[1].addEventListener('click', fn) // 里面的fn 不需要调用加小括号 function fn() { alert(22); divs[1].removeEventListener('click', fn); } // 3. detachEvent divs[2].attachEvent('onclick', fn1); function fn1() { alert(33); divs[2].detachEvent('onclick', fn1); }&lt;/script&gt; *删除事件兼容性解决方案 * 1.3.4. DOM事件流 12345&gt; html中的标签都是相互嵌套的，我们可以将元素想象成一个盒子装一个盒子，document是最外面的大盒子。&gt; 当你单击一个div时，同时你也单击了div的父元素，甚至整个页面。&gt; &gt; 那么是先执行父元素的单击事件，还是先执行div的单击事件 ？？？&gt; 比如：我们给页面中的一个div注册了单击事件，当你单击了div时，也就单击了body，单击了html，单击了document。 123456789&gt; 当时的2大浏览器霸主谁也不服谁！&gt; IE 提出从目标元素开始，然后一层一层向外接收事件并响应，也就是冒泡型事件流。&gt; Netscape（网景公司）提出从最外层开始，然后一层一层向内接收事件并响应，也就是捕获型事件流。&gt; &gt; 江湖纷争，武林盟主也脑壳疼！！！&gt; &gt; 最终，w3c 采用折中的方式，平息了战火，制定了统一的标准 —--— 先捕获再冒泡。&gt; 现代浏览器都遵循了此标准，所以当事件发生时，会经历3个阶段。&gt; DOM 事件流会经历3个阶段： 捕获阶段 当前目标阶段 冒泡阶段 ​ 我们向水里面扔一块石头，首先它会有一个下降的过程，这个过程就可以理解为从最顶层向事件发生的最具体元素（目标点）的捕获过程；之后会产生泡泡，会在最低点（ 最具体元素）之后漂浮到水面上，这个过程相当于事件冒泡。 事件冒泡 12345678910111213141516171819202122 &lt;div class=\"father\"&gt; &lt;div class=\"son\"&gt;son盒子&lt;/div&gt; &lt;/div&gt; &lt;script&gt; // onclick 和 attachEvent（ie） 在冒泡阶段触发 // 冒泡阶段 如果addEventListener 第三个参数是 false 或者 省略 // son -&gt; father -&gt;body -&gt; html -&gt; document var son = document.querySelector('.son');// 给son注册单击事件 son.addEventListener('click', function() { alert('son'); }, false);// 给father注册单击事件 var father = document.querySelector('.father'); father.addEventListener('click', function() { alert('father'); }, false);// 给document注册单击事件，省略第3个参数 document.addEventListener('click', function() { alert('document'); }) &lt;/script&gt; 事件捕获 123456789101112131415161718192021 &lt;div class=\"father\"&gt; &lt;div class=\"son\"&gt;son盒子&lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 如果addEventListener() 第三个参数是 true 那么在捕获阶段触发 // document -&gt; html -&gt; body -&gt; father -&gt; son var son = document.querySelector('.son');// 给son注册单击事件，第3个参数为true son.addEventListener('click', function() { alert('son'); }, true); var father = document.querySelector('.father');// 给father注册单击事件，第3个参数为true father.addEventListener('click', function() { alert('father'); }, true);// 给document注册单击事件，第3个参数为true document.addEventListener('click', function() { alert('document'); }, true) &lt;/script&gt; 事件对象什么是事件对象事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象。 比如： 谁绑定了这个事件。 鼠标触发事件的话，会得到鼠标的相关信息，如鼠标位置。 键盘触发事件的话，会得到键盘的相关信息，如按了哪个键。 事件对象的使用事件触发发生时就会产生事件对象，并且系统会以实参的形式传给事件处理函数。 所以，在事件处理函数中声明1个形参用来接收事件对象。 事件对象的兼容性处理事件对象本身的获取存在兼容问题： 标准浏览器中是浏览器给方法传递的参数，只需要定义形参 e 就可以获取到。 在 IE6~8 中，浏览器不会给方法传递参数，如果需要的话，需要到 window.event 中获取查找。 12只要“||”前面为false, 不管“||”后面是true 还是 false，都返回 “||” 后面的值。只要“||”前面为true, 不管“||”后面是true 还是 false，都返回 “||” 前面的值。 123456789&lt;div&gt;123&lt;/div&gt;&lt;script&gt; var div = document.querySelector('div'); div.onclick = function(e) { // 事件对象 e = e || window.event; console.log(e); }&lt;/script&gt; 事件对象的属性和方法 e.target 和 this 的区别 this 是事件绑定的元素（绑定这个事件处理函数的元素） 。 e.target 是事件触发的元素。 12345&gt; 常情况下terget 和 this是一致的，&gt; 但有一种情况不同，那就是在事件冒泡时（父子元素有相同事件，单击子元素，父元素的事件处理函数也会被触发执行），&gt; 这时候this指向的是父元素，因为它是绑定事件的元素对象，&gt; 而target指向的是子元素，因为他是触发事件的那个具体元素对象。&gt; 12345678910&lt;div&gt;123&lt;/div&gt;&lt;script&gt; var div = document.querySelector('div'); div.addEventListener('click', function(e) { // e.target 和 this指向的都是div console.log(e.target); console.log(this); });&lt;/script&gt; 事件冒泡下的e.target和this 123456789101112131415&lt;ul&gt; &lt;li&gt;abc&lt;/li&gt; &lt;li&gt;abc&lt;/li&gt; &lt;li&gt;abc&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; var ul = document.querySelector('ul'); ul.addEventListener('click', function(e) { // 我们给ul 绑定了事件 那么this 就指向ul console.log(this); // ul // e.target 触发了事件的对象 我们点击的是li e.target 指向的就是li console.log(e.target); // li });&lt;/script&gt; 阻止默认行为 html中一些标签有默认行为，例如a标签被单击后，默认会进行页面跳转。 1234567891011121314151617&lt;a href=\"http://www.baidu.com\"&gt;百度&lt;/a&gt;&lt;script&gt; // 2. 阻止默认行为 让链接不跳转 var a = document.querySelector('a'); a.addEventListener('click', function(e) { e.preventDefault(); // dom 标准写法 }); // 3. 传统的注册方式 a.onclick = function(e) { // 普通浏览器 e.preventDefault(); 方法 e.preventDefault(); // 低版本浏览器 ie678 returnValue 属性 e.returnValue = false; // 我们可以利用return false 也能阻止默认行为 没有兼容性问题 return false; }&lt;/script&gt; 阻止事件冒泡事件冒泡本身的特性，会带来的坏处，也会带来的好处。 12345678910111213141516171819202122 &lt;div class=\"father\"&gt; &lt;div class=\"son\"&gt;son儿子&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var son = document.querySelector('.son');// 给son注册单击事件 son.addEventListener('click', function(e) { alert('son'); e.stopPropagation(); // stop 停止 Propagation 传播 window.event.cancelBubble = true; // 非标准 cancel 取消 bubble 泡泡 }, false); var father = document.querySelector('.father');// 给father注册单击事件 father.addEventListener('click', function() { alert('father'); }, false);// 给document注册单击事件 document.addEventListener('click', function() { alert('document'); }) &lt;/script&gt; 阻止事件冒泡的兼容性处理 事件委托事件冒泡本身的特性，会带来的坏处，也会带来的好处。 什么是事件委托1把事情委托给别人，代为处理。 事件委托也称为事件代理，在 jQuery 里面称为事件委派。 说白了就是，不给子元素注册事件，给父元素注册事件，把处理代码在父元素的事件中执行。 生活中的代理： js事件中的代理： 事件委托的原理​ 给父元素注册事件，利用事件冒泡，当子元素的事件触发，会冒泡到父元素，然后去控制相应的子元素。 事件委托的作用 我们只操作了一次 DOM ，提高了程序的性能。 动态新创建的子元素，也拥有事件。 123456789101112131415&lt;ul&gt; &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt; &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt; &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt; &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt; &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; // 事件委托的核心原理：给父节点添加侦听器， 利用事件冒泡影响每一个子节点 var ul = document.querySelector('ul'); ul.addEventListener('click', function(e) { // e.target 这个可以得到我们点击的对象 e.target.style.backgroundColor = 'pink'; })&lt;/script&gt; 常用鼠标事件 案例：禁止选中文字和禁止右键菜单 12345678910111213&lt;body&gt; 我是一段不愿意分享的文字 &lt;script&gt; // 1. contextmenu 我们可以禁用右键菜单 document.addEventListener('contextmenu', function(e) { e.preventDefault(); }) // 2. 禁止选中文字 selectstart document.addEventListener('selectstart', function(e) { e.preventDefault(); }) &lt;/script&gt;&lt;/body&gt; 鼠标事件对象 获取鼠标在页面的坐标12345678910111213141516171819&lt;script&gt; // 鼠标事件对象 MouseEvent document.addEventListener('click', function(e) { // 1. client 鼠标在可视区的x和y坐标 console.log(e.clientX); console.log(e.clientY); console.log('---------------------'); // 2. page 鼠标在页面文档的x和y坐标 console.log(e.pageX); console.log(e.pageY); console.log('---------------------'); // 3. screen 鼠标在电脑屏幕的x和y坐标 console.log(e.screenX); console.log(e.screenY); })&lt;/script&gt; 案例：跟随鼠标的天使 123456789101112131415&lt;img src=\"images/angel.gif\" alt=\"\"&gt;&lt;script&gt; var pic = document.querySelector('img'); document.addEventListener('mousemove', function(e) { // 1. mousemove只要我们鼠标移动1px 就会触发这个事件 // 2.核心原理： 每次鼠标移动，我们都会获得最新的鼠标坐标， // 把这个x和y坐标做为图片的top和left 值就可以移动图片 var x = e.pageX; var y = e.pageY; console.log('x坐标是' + x, 'y坐标是' + y); //3 . 千万不要忘记给left 和top 添加px 单位 pic.style.left = x - 50 + 'px'; pic.style.top = y - 40 + 'px'; });&lt;/script&gt;","link":"/前端笔记/webapis-day03/"},{"title":"WebAPIs-Day04","text":"第03阶段.JavaScript基础.键盘事件 学习目标： 能够说出常用的3-5个键盘事件 能够知道如何获取当前键盘按下的是哪个键 能够知道浏览器的顶级对象window 能够使用window.onload事件 能够使用window.onresize事件 能够说出两种定时器的区别 能够使用location对象的href属性完成页面之间的跳转 能够使用location对象获取url中的参数部分 能够使用history提供的方法实现页面刷新 常用的键盘事件键盘事件 1234567891011121314151617&lt;script&gt; // 常用的键盘事件 //1. keyup 按键弹起的时候触发 document.addEventListener('keyup', function() { console.log('我弹起了'); }) //3. keypress 按键按下的时候触发 不能识别功能键 比如 ctrl shift 左右箭头啊 document.addEventListener('keypress', function() { console.log('我按下了press'); }) //2. keydown 按键按下的时候触发 能识别功能键 比如 ctrl shift 左右箭头啊 document.addEventListener('keydown', function() { console.log('我按下了down'); }) // 4. 三个事件的执行顺序 keydown -- keypress -- keyup&lt;/script&gt; 键盘事件对象 使用keyCode属性判断用户按下哪个键 12345678910111213141516&lt;script&gt; // 键盘事件对象中的keyCode属性可以得到相应键的ASCII码值 document.addEventListener('keyup', function(e) { console.log('up:' + e.keyCode); // 我们可以利用keycode返回的ASCII码值来判断用户按下了那个键 if (e.keyCode === 65) { alert('您按下的a键'); } else { alert('您没有按下a键') } }) document.addEventListener('keypress', function(e) { // console.log(e); console.log('press:' + e.keyCode); })&lt;/script&gt; 案例：模拟京东按键输入内容当我们按下 s 键， 光标就定位到搜索框（文本框获得焦点）。 注意：触发获得焦点事件，可以使用 元素对象.focus() 12345678910111213 &lt;input type=\"text\"&gt; &lt;script&gt; // 获取输入框 var search = document.querySelector('input');// 给document注册keyup事件 document.addEventListener('keyup', function(e) { // 判断keyCode的值 if (e.keyCode === 83) { // 触发输入框的获得焦点事件 search.focus(); } }) &lt;/script&gt; 案例：模拟京东快递单号查询要求：当我们在文本框中输入内容时，文本框上面自动显示大字号的内容。 123456789101112131415161718192021222324252627282930313233 &lt;div class=\"search\"&gt; &lt;div class=\"con\"&gt;123&lt;/div&gt; &lt;input type=\"text\" placeholder=\"请输入您的快递单号\" class=\"jd\"&gt; &lt;/div&gt; &lt;script&gt; // 获取要操作的元素 var con = document.querySelector('.con'); var jd_input = document.querySelector('.jd');// 给输入框注册keyup事件 jd_input.addEventListener('keyup', function() { // 判断输入框内容是否为空 if (this.value == '') { // 为空，隐藏放大提示盒子 con.style.display = 'none'; } else { // 不为空，显示放大提示盒子，设置盒子的内容 con.style.display = 'block'; con.innerText = this.value; } }) // 给输入框注册失去焦点事件，隐藏放大提示盒子 jd_input.addEventListener('blur', function() { con.style.display = 'none'; }) // 给输入框注册获得焦点事件 jd_input.addEventListener('focus', function() { // 判断输入框内容是否为空 if (this.value !== '') { // 不为空则显示提示盒子 con.style.display = 'block'; } }) &lt;/script&gt; BOM什么是BOM​ BOM（Browser Object Model）即浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是 window。 ​ BOM 由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。 ​ BOM 缺乏标准，JavaScript 语法的标准化组织是 ECMA，DOM 的标准化组织是 W3C，BOM 最初是Netscape 浏览器标准的一部分。 BOM的构成BOM 比 DOM 更大，它包含 DOM。 顶级对象window window对象的常见事件页面（窗口）加载事件（2种）第1种 window.onload 是窗口 (页面）加载事件，当文档内容完全加载完成会触发该事件(包括图像、脚本文件、CSS 文件等), 就调用的处理函数。 第2种 ​ DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片，flash等等。 ​ IE9以上才支持！！！ ​ 如果页面的图片很多的话, 从用户访问到onload触发可能需要较长的时间, 交互效果就不能实现，必然影响用户的体验，此时用 DOMContentLoaded 事件比较合适。 1234567891011121314&lt;script&gt; window.addEventListener('load', function() { var btn = document.querySelector('button'); btn.addEventListener('click', function() { alert('点击我'); }) }) window.addEventListener('load', function() { alert(22); }) document.addEventListener('DOMContentLoaded', function() { alert(33); })&lt;/script&gt; 调整窗口大小事件 ​ window.onresize 是调整窗口大小加载事件, 当触发时就调用的处理函数。 注意： 只要窗口大小发生像素变化，就会触发这个事件。 我们经常利用这个事件完成响应式布局。 window.innerWidth 当前屏幕的宽度 1234567891011121314151617&lt;script&gt; // 注册页面加载事件 window.addEventListener('load', function() { var div = document.querySelector('div'); // 注册调整窗口大小事件 window.addEventListener('resize', function() { // window.innerWidth 获取窗口大小 console.log('变化了'); if (window.innerWidth &lt;= 800) { div.style.display = 'none'; } else { div.style.display = 'block'; } }) })&lt;/script&gt;&lt;div&gt;&lt;/div&gt; 定时器（两种）window 对象给我们提供了 2 个非常好用的方法-定时器。 setTimeout() setInterval() setTimeout() 炸弹定时器开启定时器 12345678&gt; 普通函数是按照代码顺序直接调用。&gt; &gt; 简单理解： 回调，就是回头调用的意思。上一件事干完，再回头再调用这个函数。&gt; 例如：定时器中的调用函数，事件处理函数，也是回调函数。&gt; &gt; 以前我们讲的 element.onclick = function(){} 或者 element.addEventListener(“click”, fn); 里面的 函数也是回调函数。&gt; &gt; 12345678910111213 &lt;script&gt; // 回调函数是一个匿名函数 setTimeout(function() { console.log('时间到了'); }, 2000); function callback() { console.log('爆炸了'); }// 回调函数是一个有名函数 var timer1 = setTimeout(callback, 3000); var timer2 = setTimeout(callback, 5000); &lt;/script&gt; 案例：5秒后关闭广告 1234567891011&lt;body&gt; &lt;img src=\"images/ad.jpg\" alt=\"\" class=\"ad\"&gt; &lt;script&gt; // 获取要操作的元素 var ad = document.querySelector('.ad'); // 开启定时器 setTimeout(function() { ad.style.display = 'none'; }, 5000); &lt;/script&gt;&lt;/body&gt; 停止定时器 12345678910111213 &lt;button&gt;点击停止定时器&lt;/button&gt; &lt;script&gt; var btn = document.querySelector('button');// 开启定时器 var timer = setTimeout(function() { console.log('爆炸了'); }, 5000);// 给按钮注册单击事件 btn.addEventListener('click', function() { // 停止定时器 clearTimeout(timer); }) &lt;/script&gt; setInterval() 闹钟定时器开启定时器 123456&lt;script&gt; // 1. setInterval setInterval(function() { console.log('继续输出'); }, 1000);&lt;/script&gt; 案例：倒计时 12345678910111213141516171819202122232425262728293031&lt;div&gt; &lt;span class=\"hour\"&gt;1&lt;/span&gt; &lt;span class=\"minute\"&gt;2&lt;/span&gt; &lt;span class=\"second\"&gt;3&lt;/span&gt;&lt;/div&gt;&lt;script&gt; // 1. 获取元素（时分秒盒子） var hour = document.querySelector('.hour'); // 小时的黑色盒子 var minute = document.querySelector('.minute'); // 分钟的黑色盒子 var second = document.querySelector('.second'); // 秒数的黑色盒子 var inputTime = +new Date('2019-5-1 18:00:00'); // 返回的是用户输入时间总的毫秒数 countDown(); // 我们先调用一次这个函数，防止第一次刷新页面有空白 // 2. 开启定时器 setInterval(countDown, 1000); function countDown() { var nowTime = +new Date(); // 返回的是当前时间总的毫秒数 var times = (inputTime - nowTime) / 1000; // times是剩余时间总的秒数 var h = parseInt(times / 60 / 60 % 24); //时 h = h &lt; 10 ? '0' + h : h; hour.innerHTML = h; // 把剩余的小时给 小时黑色盒子 var m = parseInt(times / 60 % 60); // 分 m = m &lt; 10 ? '0' + m : m; minute.innerHTML = m; var s = parseInt(times % 60); // 当前的秒 s = s &lt; 10 ? '0' + s : s; second.innerHTML = s; }&lt;/script&gt; 停止定时器 案例：发送短信倒计时​ 点击按钮后，该按钮60秒之内不能再次点击，防止重复发送短信。 123456789101112131415161718192021222324 手机号码： &lt;input type=\"number\"&gt; &lt;button&gt;发送&lt;/button&gt; &lt;script&gt; var btn = document.querySelector('button');// 全局变量，定义剩下的秒数 var time = 3; // 注册单击事件 btn.addEventListener('click', function() { // 禁用按钮 btn.disabled = true; // 开启定时器 var timer = setInterval(function() { // 判断剩余秒数 if (time == 0) { // 清除定时器和复原按钮 clearInterval(timer); btn.disabled = false; btn.innerHTML = '发送'; } else { btn.innerHTML = '还剩下' + time + '秒'; time--; } }, 1000); }); &lt;/script&gt; this指向问题​ this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，一般情况下this的最终指向的是那个调用它的对象。 现阶段，我们先了解一下几个this指向 全局作用域或者普通函数中this指向全局对象window（注意定时器里面的this指向window） 方法调用中谁调用this指向谁 构造函数中this指向构造函数的实例 1234567891011121314151617181920212223242526272829&lt;button&gt;点击&lt;/button&gt;&lt;script&gt; // this 指向问题 一般情况下this的最终指向的是那个调用它的对象 // 1. 全局作用域或者普通函数中this指向全局对象window（ 注意定时器里面的this指向window） console.log(this); function fn() { console.log(this); } window.fn(); window.setTimeout(function() { console.log(this); }, 1000); // 2. 方法调用中谁调用this指向谁 var o = { sayHi: function() { console.log(this); // this指向的是 o 这个对象 } } o.sayHi(); var btn = document.querySelector('button'); btn.addEventListener('click', function() { console.log(this); // 事件处理函数中的this指向的是btn这个按钮对象 }) // 3. 构造函数中this指向构造函数的实例 function Fun() { console.log(this); // this 指向的是fun 实例对象 } var fun = new Fun();&lt;/script&gt; location对象什么是 location 对象 URL location 对象的属性 案例：5分钟自动跳转页面 12345678910111213141516171819&lt;button&gt;点击&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;script&gt; var btn = document.querySelector('button'); var div = document.querySelector('div'); btn.addEventListener('click', function() { // console.log(location.href); location.href = 'http://www.itcast.cn'; }) var timer = 5; setInterval(function() { if (timer == 0) { location.href = 'http://www.itcast.cn'; } else { div.innerHTML = '您将在' + timer + '秒钟之后跳转到首页'; timer--; } }, 1000);&lt;/script&gt; 案例：获取URL参数 12345678910111213 &lt;div&gt;&lt;/div&gt;&lt;script&gt; console.log(location.search); // ?uname=andy // 1.先去掉？ substr('起始的位置'，截取几个字符); var params = location.search.substr(1); // uname=andy console.log(params); // 2. 利用=把字符串分割为数组 split('='); var arr = params.split('='); console.log(arr); // [\"uname\", \"ANDY\"] var div = document.querySelector('div'); // 3.把数据写入div中 div.innerHTML = arr[1] + '欢迎您'; &lt;/script&gt; location对象的常见方法 1234567891011&lt;button&gt;点击&lt;/button&gt;&lt;script&gt; var btn = document.querySelector('button'); btn.addEventListener('click', function() { // 记录浏览历史，所以可以实现后退功能 // location.assign('http://www.itcast.cn'); // 不记录浏览历史，所以不可以实现后退功能 // location.replace('http://www.itcast.cn'); location.reload(true); })&lt;/script&gt; navigator对象​ navigator 对象包含有关浏览器的信息，它有很多属性，我们最常用的是 userAgent，该属性可以返回由客户机发送服务器的 user-agent 头部的值。 下面前端代码可以判断用户那个终端打开页面，实现跳转 12345if((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) { window.location.href = \"\"; //手机 } else { window.location.href = \"\"; //电脑 } history对象​ window对象给我们提供了一个 history对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中）访问过的URL。 history对象一般在实际开发中比较少用，但是会在一些 OA 办公系统中见到。 JS执行机制以下代码执行的结果是什么？ 1234567console.log(1);setTimeout(function () { console.log(3);}, 1000);console.log(2); 以下代码执行的结果是什么？ 1234567console.log(1);setTimeout(function () { console.log(3);}, 0);console.log(2); JS 是单线程 12单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。这样所导致的问题是： 如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。 同步任务和异步任务​ 单线程导致的问题就是后面的任务等待前面任务完成，如果前面任务很耗时（比如读取网络数据），后面任务不得不一直等待！！ ​ 为了解决这个问题，利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制。于是，JS 中出现了同步任务和异步任务。 同步​ 前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。比如做饭的同步做法：我们要烧水煮饭，等水开了（10分钟之后），再去切菜，炒菜。 异步​ 你在做一件事情时，因为这件事情会花费很长时间，在做这件事的同时，你还可以去处理其他事情。比如做饭的异步做法，我们在烧水的同时，利用这10分钟，去切菜，炒菜。 1234567&gt; JS中所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。&gt; &gt; 同步任务指的是：&gt; 在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；&gt; 异步任务指的是：&gt; 不进入主线程、而进入”任务队列”的任务，当主线程中的任务运行完了，才会从”任务队列”取出异步任务放入主线程执行。&gt; JS执行机制（事件循环） 代码思考题123456789console.log(1);document.onclick = function() { console.log('click');}setTimeout(function() { console.log(3)}, 3000)console.log(2);","link":"/前端笔记/webapis-day04/"},{"title":"jQuery-Day01","text":"第03阶段.jQuery基础.认识jQuery 学习目标： 能够说出什么是 jQuery能够说出 jQuery 的优点能够简单使用 jQuery能够说出 DOM 对象和 jQuery 对象的区别能够写出常用的 jQuery 选择器能够操作 jQuery 样式能够写出常用的 jQuery 动画 jQuery 介绍JavaScript 库​ JavaScript库：即 library，是一个封装好的特定的集合（方法和函数）。从封装一大堆函数的角度理解库，就是在这个库中，封装了很多预先定义好的函数在里面，比如动画animate、hide、show，比如获取元素等。 简单理解： 就是一个JS 文件，里面对我们原生js代码进行了封装，存放到里面。这样我们可以快速高效的使用这些封装好的功能了。 比如 jQuery，就是为了快速方便的操作DOM，里面基本都是函数（方法）。 ​ 常见的JavaScript 库：jQuery、Prototype、YUI、Dojo、Ext JS、移动端的zepto等，这些库都是对原生 JavaScript 的封装，内部都是用 JavaScript 实现的，我们主要学习的是 jQuery。 jQuery的概念​ jQuery总体概况如下 : jQuery 是一个快速、简洁的 JavaScript 库，其设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。 j 就是 JavaScript； Query 查询； 意思就是查询js，把js中的DOM操作做了封装，我们可以快速的查询使用里面的功能。 jQuery 封装了 JavaScript 常用的功能代码，优化了 DOM 操作、事件处理、动画设计和 Ajax 交互。 学习jQuery本质： 就是学习调用这些函数（方法）。 jQuery 出现的目的是加快前端人员的开发速度，我们可以非常方便的调用和使用它，从而提高开发效率。 jQuery的优点 轻量级。核心文件才几十kb，不会影响页面加载速度。 跨浏览器兼容，基本兼容了现在主流的浏览器。 链式编程、隐式迭代。 对事件、样式、动画支持，大大简化了DOM操作。 支持插件扩展开发。有着丰富的第三方的插件，例如：树形菜单、日期控件、轮播图等。 免费、开源。 jQuery 的基本使用jQuery 的下载​ jQuery的官网地址： https://jquery.com/，官网即可下载最新版本。 各个版本的下载：https://code.jquery.com/ ​ 版本介绍： 1x ：兼容 IE 678 等低版本浏览器， 官网不再更新 2x ：不兼容 IE 678 等低版本浏览器， 官网不再更新 3x ：不兼容 IE 678 等低版本浏览器， 是官方主要更新维护的版本 体验jQuery​ 步骤： 引入jQuery文件。 在文档最末尾插入 script 标签，书写体验代码。 $(‘div’).hide() 可以隐藏盒子。 jQuery的入口函数​ jQuery中常见的两种入口函数： 123456789// 第一种: 简单易用。$(function () { ... // 此处是页面 DOM 加载完成的入口}) ; // 第二种: 繁琐，但是也可以实现$(document).ready(function(){ ... // 此处是页面DOM加载完成的入口}); ​ 总结： 等着 DOM 结构渲染完毕即可执行内部代码，不必等到所有外部资源加载完成，jQuery 帮我们完成了封装。 相当于原生 js 中的 DOMContentLoaded。 不同于原生 js 中的 load 事件是等页面文档、外部的 js 文件、css文件、图片加载完毕才执行内部代码。 更推荐使用第一种方式。 jQuery中的顶级对象$ $是 jQuery 的别称，在代码中可以使用 jQuery 代替，但一般为了方便，通常都直接使用 $ 。 $是jQuery的顶级对象，相当于原生JavaScript中的 window。把元素利用$包装成jQuery对象，就可以调用jQuery 的方法。 jQuery 对象和 DOM 对象​ 使用 jQuery 方法和原生JS获取的元素是不一样的，总结如下 : 用原生 JS 获取来的对象就是 DOM 对象 jQuery 方法获取的元素就是 jQuery 对象。 jQuery 对象本质是： 利用$对DOM 对象包装后产生的对象（伪数组形式存储）。 注意： 只有 jQuery 对象才能使用 jQuery 方法，DOM 对象则使用原生的 JavaScirpt 方法。 jQuery 对象和 DOM 对象转换​ DOM 对象与 jQuery 对象之间是可以相互转换的。因为原生js 比 jQuery 更大，原生的一些属性和方法 jQuery没有给我们封装. 要想使用这些属性和方法需要把jQuery对象转换为DOM对象才能使用。 12345678910// 1.DOM对象转换成jQuery对象，方法只有一种var box = document.getElementById('box'); // 获取DOM对象var jQueryObject = $(box); // 把DOM对象转换为 jQuery 对象// 2.jQuery 对象转换为 DOM 对象有两种方法：// 2.1 jQuery对象[索引值]var domObject1 = $('div')[0]// 2.2 jQuery对象.get(索引值)var domObject2 = $('div').get(0) 总结：实际开发比较常用的是把DOM对象转换为jQuery对象，这样能够调用功能更加强大的jQuery中的方法。 jQuery 选择器​ 原生 JS 获取元素方式很多，很杂，而且兼容性情况不一致，因此 jQuery 给我们做了封装，使获取元素统一标准。 基础选择器1$(\"选择器\") // 里面选择器直接写 CSS 选择器即可，但是要加引号 ​ 层级选择器​ 层级选择器最常用的两个分别为：后代选择器和子代选择器。 ​ 基础选择器和层级选择器案例代码 12345678910111213141516&lt;body&gt; &lt;div&gt;我是div&lt;/div&gt; &lt;div class=\"nav\"&gt;我是nav div&lt;/div&gt; &lt;p&gt;我是p&lt;/p&gt; &lt;ul&gt; &lt;li&gt;我是ul 的&lt;/li&gt; &lt;li&gt;我是ul 的&lt;/li&gt; &lt;li&gt;我是ul 的&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; $(function() { console.log($(\".nav\")); console.log($(\"ul li\")); }) &lt;/script&gt;&lt;/body&gt; 筛选选择器​ 筛选选择器，顾名思义就是在所有的选项中选择满足条件的进行筛选选择。常见如下 : 案例代码 1234567891011121314151617181920212223242526&lt;body&gt; &lt;ul&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;/ol&gt; &lt;script&gt; $(function() { $(\"ul li:first\").css(\"color\", \"red\"); $(\"ul li:eq(2)\").css(\"color\", \"blue\"); $(\"ol li:odd\").css(\"color\", \"skyblue\"); $(\"ol li:even\").css(\"color\", \"pink\"); }) &lt;/script&gt;&lt;/body&gt; 另: jQuery中还有一些筛选方法，类似DOM中的通过一个节点找另外一个节点，父、子、兄以外有所加强。 偏重于记忆，演示代码略。 知识铺垫 jQuery 设置样式 1$('div').css('属性', '值') jQuery 里面的排他思想 123// 想要多选一的效果，排他思想：当前元素设置样式，其余的兄弟元素清除样式。$(this).css(“color”,”red”);$(this).siblings(). css(“color”,””); 隐式迭代 123// 遍历内部 DOM 元素（伪数组形式存储）的过程就叫做隐式迭代。// 简单理解：给匹配到的所有元素进行循环遍历，执行相应的方法，而不用我们再进行循环，简化我们的操作，方便我们调用。$('div').hide(); // 页面中所有的div全部隐藏，不用循环操作 链式编程 12// 链式编程是为了节省代码量，看起来更优雅。$(this).css('color', 'red').sibling().css('color', ''); 案例：淘宝服饰精品案例 思路分析:1.核心原理：鼠标经过左侧盒子某个小li，就让内容区盒子相对应图片显示，其余的图片隐藏。2.需要得到当前小li 的索引号，就可以显示对应索引号的图片3.jQuery 得到当前元素索引号 $(this).index()4.中间对应的图片，可以通过 eq(index) 方法去选择5.显示元素 show() 隐藏元素 hide() ​ 代码实现略。(详情参考源代码) jQuery 样式操作​ jQuery中常用的样式操作有两种：css() 和 设置类样式方法 方法1: 操作 css 方法​ jQuery 可以使用 css 方法来修改简单元素样式； 也可以操作类，修改多个样式。 ​ 常用以下三种形式 : 12345678// 1.参数只写属性名，则是返回属性值var strColor = $(this).css('color');// 2. 参数是属性名，属性值，逗号分隔，是设置一组样式，属性必须加引号，值如果是数字可以不用跟单位和引号$(this).css(''color'', ''red'');// 3. 参数可以是对象形式，方便设置多组样式。属性名和属性值用冒号隔开， 属性可以不用加引号$(this).css({ \"color\":\"white\",\"font-size\":\"20px\"}); ​ 注意：css() 多用于样式少时操作，多了则不太方便。 方法2: 设置类样式方法​ 作用等同于以前的 classList，可以操作类样式， 注意操作类里面的参数不要加点。 ​ 常用的三种设置类样式方法： 12345678// 1.添加类$(\"div\").addClass(\"current\");// 2.删除类$(\"div\").removeClass(\"current\");// 3.切换类$(\"div\").toggleClass(\"current\"); ​ 注意： 设置类样式方法比较适合样式多时操作，可以弥补css()的不足。 原生 JS 中 className 会覆盖元素原先里面的类名，jQuery 里面类操作只是对指定类进行操作，不影响原先的类名。 案例：tab 栏切换 思路分析:1.点击上部的li，当前li 添加current类，其余兄弟移除类。2.点击的同时，得到当前li 的索引号3.让下部里面相应索引号的item显示，其余的item隐藏 ​ 代码实现略。(详情参考源代码) jQuery 效果​ jQuery 给我们封装了很多动画效果，最为常见的如下： 显示隐藏：show() / hide() / toggle() ; 划入画出：slideDown() / slideUp() / slideToggle() ; 淡入淡出：fadeIn() / fadeOut() / fadeToggle() / fadeTo() ; 自定义动画：animate() ; 注意： 动画或者效果一旦触发就会执行，如果多次触发，就造成多个动画或者效果排队执行。 jQuery为我们提供另一个方法，可以停止动画排队：stop() ; 显示隐藏​ 显示隐藏动画，常见有三个方法：show() / hide() / toggle() ; ​ 语法规范如下: 代码演示 123456789101112131415161718192021222324&lt;body&gt; &lt;button&gt;显示&lt;/button&gt; &lt;button&gt;隐藏&lt;/button&gt; &lt;button&gt;切换&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() { $(\"button\").eq(0).click(function() { $(\"div\").show(1000, function() { alert(1); }); }) $(\"button\").eq(1).click(function() { $(\"div\").hide(1000, function() { alert(1); }); }) $(\"button\").eq(2).click(function() { $(\"div\").toggle(1000); }) // 一般情况下，我们都不加参数直接显示隐藏就可以了 }); &lt;/script&gt;&lt;/body&gt; 滑入滑出​ 滑入滑出动画，常见有三个方法：slideDown() / slideUp() / slideToggle() ; ​ 语法规范如下: 代码演示 12345678910111213141516171819202122&lt;body&gt; &lt;button&gt;下拉滑动&lt;/button&gt; &lt;button&gt;上拉滑动&lt;/button&gt; &lt;button&gt;切换滑动&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() { $(\"button\").eq(0).click(function() { // 下滑动 slideDown() $(\"div\").slideDown(); }) $(\"button\").eq(1).click(function() { // 上滑动 slideUp() $(\"div\").slideUp(500); }) $(\"button\").eq(2).click(function() { // 滑动切换 slideToggle() $(\"div\").slideToggle(500); }); }); &lt;/script&gt;&lt;/body&gt; 小案例：下拉菜单略（详情参看源码）。 淡入淡出​ 淡入淡出动画，常见有四个方法：fadeIn() / fadeOut() / fadeToggle() / fadeTo() ; ​ 语法规范如下: 代码演示 123456789101112131415161718192021222324252627&lt;body&gt; &lt;button&gt;淡入效果&lt;/button&gt; &lt;button&gt;淡出效果&lt;/button&gt; &lt;button&gt;淡入淡出切换&lt;/button&gt; &lt;button&gt;修改透明度&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() { $(\"button\").eq(0).click(function() { // 淡入 fadeIn() $(\"div\").fadeIn(1000); }) $(\"button\").eq(1).click(function() { // 淡出 fadeOut() $(\"div\").fadeOut(1000); }) $(\"button\").eq(2).click(function() { // 淡入淡出切换 fadeToggle() $(\"div\").fadeToggle(1000); }); $(\"button\").eq(3).click(function() { // 修改透明度 fadeTo() 这个速度和透明度要必须写 $(\"div\").fadeTo(1000, 0.5); }); }); &lt;/script&gt;&lt;/body&gt; 自定义动画​ 自定义动画非常强大，通过参数的传递可以模拟以上所有动画，方法为：animate() ; ​ 语法规范如下: 代码演示 12345678910111213141516&lt;body&gt; &lt;button&gt;动起来&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() { $(\"button\").click(function() { $(\"div\").animate({ left: 500, top: 300, opacity: .4, width: 500 }, 500); }) }) &lt;/script&gt;&lt;/body&gt; 停止动画排队​ 动画或者效果一旦触发就会执行，如果多次触发，就造成多个动画或者效果排队执行。 ​ 停止动画排队的方法为：stop() ; stop() 方法用于停止动画或效果。 stop() 写到动画或者效果的前面， 相当于停止结束上一次的动画。 ​ 总结: 每次使用动画之前，先调用 stop() ,在调用动画。 事件切换​ jQuery中为我们添加了一个新事件 hover() ; 功能类似 css 中的伪类 :hover 。介绍如下 语法 1hover([over,]out) // 其中over和out为两个函数 over:鼠标移到元素上要触发的函数（相当于mouseenter） out:鼠标移出元素要触发的函数（相当于mouseleave） 如果只写一个函数，则鼠标经过和离开都会触发它 hover事件和停止动画排列案例 12345678910111213141516171819202122232425262728293031323334353637&lt;body&gt; &lt;ul class=\"nav\"&gt; &lt;li&gt; &lt;a href=\"#\"&gt;微博&lt;/a&gt; &lt;ul&gt;&lt;li&gt;&lt;a href=\"\"&gt;私信&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"\"&gt;评论&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"\"&gt;@我&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"#\"&gt;微博&lt;/a&gt; &lt;ul&gt;&lt;li&gt;&lt;a href=\"\"&gt;私信&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"\"&gt;评论&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"\"&gt;@我&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;script&gt; $(function() { // 鼠标经过 // $(\".nav&gt;li\").mouseover(function() { // // $(this) jQuery 当前元素 this不要加引号 // // show() 显示元素 hide() 隐藏元素 // $(this).children(\"ul\").slideDown(200); // }); // // 鼠标离开 // $(\".nav&gt;li\").mouseout(function() { // $(this).children(\"ul\").slideUp(200); // }); // 1. 事件切换 hover 就是鼠标经过和离开的复合写法 // $(\".nav&gt;li\").hover(function() { // $(this).children(\"ul\").slideDown(200); // }, function() { // $(this).children(\"ul\").slideUp(200); // }); // 2. 事件切换 hover 如果只写一个函数，那么鼠标经过和鼠标离开都会触发这个函数 $(\".nav&gt;li\").hover(function() { // stop 方法必须写到动画的前面 $(this).children(\"ul\").stop().slideToggle(); }); }) &lt;/script&gt;&lt;/body&gt;","link":"/前端笔记/jquery-day01/"},{"title":"jQuery-Day03","text":"第03阶段.jQuery基础.jQuery事件 学习目标： 能够说出4种常见的注册事件能够说出 on 绑定事件的优势能够说出 jQuery 事件委派的优点以及方式能够说出绑定事件与解绑事件能够说出 jQuery 对象的拷贝方法能够说出 jQuery 多库共存的2种方法能够使用 jQuery 插件 jQuery 事件注册​ jQuery 为我们提供了方便的事件注册机制，是开发人员抑郁操作优缺点如下： 优点: 操作简单，且不用担心事件覆盖等问题。 缺点: 普通的事件注册不能做事件委托，且无法实现事件解绑，需要借助其他方法。 语法 演示代码 1234567891011121314&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() { // 1. 单个事件注册 $(\"div\").click(function() { $(this).css(\"background\", \"purple\"); }); $(\"div\").mouseenter(function() { $(this).css(\"background\", \"skyblue\"); }); }) &lt;/script&gt;&lt;/body&gt; jQuery 事件处理​ 因为普通注册事件方法的不足，jQuery又开发了多个处理方法，重点讲解如下： on(): 用于事件绑定，目前最好用的事件绑定方法 off(): 事件解绑 trigger() / triggerHandler(): 事件触发 事件处理 on() 绑定事件​ 因为普通注册事件方法的不足，jQuery又创建了多个新的事件绑定方法bind() / live() / delegate() / on()等，其中最好用的是: on() 语法 演示代码 12345678910111213141516171819202122232425262728293031323334353637383940&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;ul&gt; &lt;li&gt;我们都是好孩子&lt;/li&gt; &lt;li&gt;我们都是好孩子&lt;/li&gt; &lt;li&gt;我们都是好孩子&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt;&lt;/ol&gt; &lt;script&gt; $(function() { // (1) on可以绑定1个或者多个事件处理程序 // $(\"div\").on({ // mouseenter: function() { // $(this).css(\"background\", \"skyblue\"); // }, // click: function() { // $(this).css(\"background\", \"purple\"); // } // }); $(\"div\").on(\"mouseenter mouseleave\", function() { $(this).toggleClass(\"current\"); }); // (2) on可以实现事件委托（委派） // click 是绑定在ul 身上的，但是 触发的对象是 ul 里面的小li // $(\"ul li\").click(); $(\"ul\").on(\"click\", \"li\", function() { alert(11); }); // (3) on可以给未来动态创建的元素绑定事件 $(\"ol\").on(\"click\", \"li\", function() { alert(11); }) var li = $(\"&lt;li&gt;我是后来创建的&lt;/li&gt;\"); $(\"ol\").append(li); }) &lt;/script&gt;&lt;/body&gt; 案例：发布微博案例 1.点击发布按钮， 动态创建一个小li，放入文本框的内容和删除按钮， 并且添加到ul 中。2.点击的删除按钮，可以删除当前的微博留言。 ​ 代码实现略。(详情参考源代码) 事件处理 off() 解绑事件​ 当某个事件上面的逻辑，在特定需求下不需要的时候，可以把该事件上的逻辑移除，这个过程我们称为事件解绑。jQuery 为我们提供 了多种事件解绑方法：die() / undelegate() / off() 等，甚至还有只触发一次的事件绑定方法 one()，在这里我们重点讲解一下 off() ; 语法 演示代码 1234567891011121314151617181920212223242526272829303132333435&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;ul&gt; &lt;li&gt;我们都是好孩子&lt;/li&gt; &lt;li&gt;我们都是好孩子&lt;/li&gt; &lt;li&gt;我们都是好孩子&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;我是一个P标签&lt;/p&gt; &lt;script&gt; $(function() { // 事件绑定 $(\"div\").on({ click: function() { console.log(\"我点击了\"); }, mouseover: function() { console.log('我鼠标经过了'); } }); $(\"ul\").on(\"click\", \"li\", function() { alert(11); }); // 1. 事件解绑 off // $(\"div\").off(); // 这个是解除了div身上的所有事件 $(\"div\").off(\"click\"); // 这个是解除了div身上的点击事件 $(\"ul\").off(\"click\", \"li\"); // 2. one() 但是它只能触发事件一次 $(\"p\").one(\"click\", function() { alert(11); }) }) &lt;/script&gt;&lt;/body&gt; 事件处理 trigger() 自动触发事件​ 有些时候，在某些特定的条件下，我们希望某些事件能够自动触发, 比如轮播图自动播放功能跟点击右侧按钮一致。可以利用定时器自动触发右侧按钮点击事件，不必鼠标点击触发。由此 jQuery 为我们提供了两个自动触发事件 trigger() 和 triggerHandler() ; 语法 演示代码 1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;input type=\"text\"&gt; &lt;script&gt; $(function() { // 绑定事件 $(\"div\").on(\"click\", function() { alert(11); }); // 自动触发事件 // 1. 元素.事件() // $(\"div\").click();会触发元素的默认行为 // 2. 元素.trigger(\"事件\") // $(\"div\").trigger(\"click\");会触发元素的默认行为 $(\"input\").trigger(\"focus\"); // 3. 元素.triggerHandler(\"事件\") 就是不会触发元素的默认行为 $(\"input\").on(\"focus\", function() { $(this).val(\"你好吗\"); }); // 一个会获取焦点，一个不会 $(\"div\").triggerHandler(\"click\"); // $(\"input\").triggerHandler(\"focus\"); }); &lt;/script&gt;&lt;/body&gt; jQuery 事件对象​ jQuery 对DOM中的事件对象 event 进行了封装，兼容性更好，获取更方便，使用变化不大。事件被触发，就会有事件对象的产生。 语法 演示代码 12345678910111213141516&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() { $(document).on(\"click\", function() { console.log(\"点击了document\"); }) $(\"div\").on(\"click\", function(event) { // console.log(event); console.log(\"点击了div\"); event.stopPropagation(); }) }) &lt;/script&gt;&lt;/body&gt; 注意：jQuery中的 event 对象使用，可以借鉴 API 和 DOM 中的 event 。 jQuery 拷贝对象​ jQuery中分别为我们提供了两套快速获取和设置元素尺寸和位置的API，方便易用，内容如下。 语法 演示代码 12345678910111213141516171819202122232425&lt;script&gt; $(function() { // 1.合并数据 var targetObj = {}; var obj = { id: 1, name: \"andy\" }; // $.extend(target, obj); $.extend(targetObj, obj); console.log(targetObj); // 2. 会覆盖 targetObj 里面原来的数据 var targetObj = { id: 0 }; var obj = { id: 1, name: \"andy\" }; // $.extend(target, obj); $.extend(targetObj, obj); console.log(targetObj); }) &lt;/script&gt; jQuery 多库共存​ 实际开发中，很多项目连续开发十多年，jQuery版本不断更新，最初的 jQuery 版本无法满足需求，这时就需要保证在旧有版本正常运行的情况下，新的功能使用新的jQuery版本实现，这种情况被称为，jQuery 多库共存。 语法 演示代码 1234567&lt;script&gt; $(function() { // 让jquery 释放对$ 控制权 让用自己决定 var suibian = jQuery.noConflict(); console.log(suibian(\"span\")); })&lt;/script&gt; jQuery 插件​ jQuery 功能比较有限，想要更复杂的特效效果，可以借助于 jQuery 插件完成。 这些插件也是依赖于jQuery来完成的，所以必须要先引入 jQuery文件，因此也称为 jQuery 插件。 ​ jQuery 插件常用的网站： jQuery 插件库 http://www.jq22.com/ jQuery 之家 http://www.htmleaf.com/ jQuery 插件使用步骤： 引入相关文件。（jQuery 文件 和 插件文件） 复制相关html、css、js (调用插件)。 瀑布流插件（重点讲解）​ 我们学习的第一个插件是jQuery之家的开源插件，瀑布流。我们将重点详细讲解，从找到插件所在网页，然后点击下载代码，到插件的使用等，后面的插件使用可参考瀑布流插件的使用。 下载位置 代码演示 ​ 插件的使用三点： 1. 引入css. 2.引入JS 3.引入html。 （有的简单插件只需引入html和js，甚至有的只需引入js） 1.引入css. 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;link rel=\"stylesheet\" href=\"css/normalize.css\"&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"css/default.css\"&gt; &lt;!-- 下面的样式代码为页面布局，可以引入，也可以自己写，自己设计页面样式，一般为直接引入，方便 --&gt;&lt;style type=\"text/css\"&gt; #gallery-wrapper { position: relative; max-width: 75%; width: 75%; margin: 50px auto; } img.thumb { width: 100%; max-width: 100%; height: auto; } .white-panel { position: absolute; background: white; border-radius: 5px; box-shadow: 0px 1px 2px rgba(0, 0, 0, 0.3); padding: 10px; } .white-panel h1 { font-size: 1em; } .white-panel h1 a { color: #A92733; } .white-panel:hover { box-shadow: 1px 1px 10px rgba(0, 0, 0, 0.5); margin-top: -5px; -webkit-transition: all 0.3s ease-in-out; -moz-transition: all 0.3s ease-in-out; -o-transition: all 0.3s ease-in-out; transition: all 0.3s ease-in-out; }&lt;/style&gt; 2.引入js. 123456789101112131415&lt;!-- 前两个必须引入 --&gt;&lt;script src=\"js/jquery-1.11.0.min.js\"&gt;&lt;/script&gt;&lt;script src=\"js/pinterest_grid.js\"&gt;&lt;/script&gt;&lt;!-- 下面的为启动瀑布流代码，参数可调节属性，具体功能可参考readme.html --&gt;&lt;script type=\"text/javascript\"&gt; $(function() { $(\"#gallery-wrapper\").pinterest_grid({ no_columns: 5, padding_x: 15, padding_y: 10, margin_bottom: 50, single_column_breakpoint: 700 }); });&lt;/script&gt; 3.引入html. 1234567891011121314151617181920212223&lt;!-- html结构一般为事先写好，很难修改结构，但可以修改内容及图片的多少（article标签） --&gt;&lt;section id=\"gallery-wrapper\"&gt; &lt;article class=\"white-panel\"&gt; &lt;img src=\"images/P_000.jpg\" class=\"thumb\"&gt; &lt;h1&gt;&lt;a href=\"#\"&gt;我是轮播图片1&lt;/a&gt;&lt;/h1&gt; &lt;p&gt;里面很精彩哦&lt;/p&gt; &lt;/article&gt; &lt;article class=\"white-panel\"&gt; &lt;img src=\"images/P_005.jpg\" class=\"thumb\"&gt; &lt;h1&gt;&lt;a href=\"#\"&gt;我是轮播图片1&lt;/a&gt;&lt;/h1&gt; &lt;p&gt;里面很精彩哦&lt;/p&gt; &lt;/article&gt; &lt;article class=\"white-panel\"&gt; &lt;img src=\"images/P_006.jpg\" class=\"thumb\"&gt; &lt;h1&gt;&lt;a href=\"#\"&gt;我是轮播图片1&lt;/a&gt;&lt;/h1&gt; &lt;p&gt;里面很精彩哦&lt;/p&gt; &lt;/article&gt; &lt;article class=\"white-panel\"&gt; &lt;img src=\"images/P_007.jpg\" class=\"thumb\"&gt; &lt;h1&gt;&lt;a href=\"#\"&gt;我是轮播图片1&lt;/a&gt;&lt;/h1&gt; &lt;p&gt;里面很精彩哦&lt;/p&gt; &lt;/article&gt; &lt;/section&gt; 总结：jQuery插件就是引入别人写好的：html 、css、js （有时也可以只引入一部分，读懂后也可以修改部分内容） 图片懒加载插件​ 图片的懒加载就是：当页面滑动到有图片的位置，图片才进行加载，用以提升页面打开的速度及用户体验。（下载略） 代码演示 ​ 懒加载只需引入html 和 js操作 即可，此插件不涉及css。 1.引入js 123456789101112&lt;script src=\"js/EasyLazyload.min.js\"&gt;&lt;/script&gt;&lt;script&gt; lazyLoadInit({ showTime: 1100, onLoadBackEnd: function(i, e) { console.log(\"onLoadBackEnd:\" + i); }, onLoadBackStart: function(i, e) { console.log(\"onLoadBackStart:\" + i); } });&lt;/script&gt; 2.引入html 1&lt;img data-lazy-src=\"upload/floor-1-3.png\" alt=\"\"&gt; 全屏滚动插件​ 全屏滚动插件比较大，所以，一般大型插件都会有帮助文档，或者网站。全屏滚动插件介绍比较详细的网站为： http://www.dowebok.com/demo/2014/77/ 代码演示 ​ 全屏滚动因为有多重形式，所以不一样的风格html和css也不一样，但是 js 变化不大。所以下面只演示js的引入，html和css引入根据自己实际 项目需要使用哪种风格引入对应的HTML和CSS。 12345678910&lt;script src=\"js/jquery.min.js\"&gt;&lt;/script&gt;&lt;script src=\"js/fullpage.min.js\"&gt;&lt;/script&gt;&lt;script&gt; $(function() { $('#dowebok').fullpage({ sectionsColor: ['pink', '#4BBFC3', '#7BAABE', '#f90'], navigation: true }); });&lt;/script&gt; 注意：实际开发，一般复制文件，然后在文件中进行修改和添加功能。 bootstrap组件​ Bootstrap是 Twitter 公司设计的基于HTML、CSS、JavaScript开发的简洁、直观、强悍的前端开发框架，他依靠jQuery实现，且支持响应式 布局，使得 Web 开发更加方便快捷。 ​ 凡是在软件开发中用到了软件的复用，被复用的部分都可以称为组件，凡是在应用程序中已经预留接口的组件就是插件。Bootstrap组件使 用非常方便: 1.引入bootstrap相关css和js 2.去官网复制html 代码演示 引入bootstrap相关css和js 123&lt;link rel=\"stylesheet\" href=\"bootstrap/css/bootstrap.min.css\"&gt;&lt;script src=\"bootstrap/js/jquery.min.js\"&gt;&lt;/script&gt;&lt;script src=\"bootstrap/js/bootstrap.min.js\"&gt;&lt;/script&gt; 去官网复制html的功能模块 123456789101112131415 &lt;div class=\"container\"&gt; &lt;!-- Single button --&gt; &lt;div class=\"btn-group\"&gt; &lt;button type=\"button\" class=\"btn btn-default dropdown-toggle\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\"&gt; Action &lt;span class=\"caret\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role=\"separator\" class=\"divider\"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; bootstrap插件（JS）​ bootstrap中的js插件其实也是组件的一部分，只不过是需要js调用功能的组件，所以一般bootstrap的js插件一般会伴随着js代码（有的也可以 省略js，用属性实现）。 ​ 步骤： 1.引入bootstrap相关css和js 2.去官网复制html 3.复制js代码，启动js插件。 代码演示 引入bootstrap相关css和js 123&lt;link rel=\"stylesheet\" href=\"bootstrap/css/bootstrap.min.css\"&gt;&lt;script src=\"bootstrap/js/jquery.min.js\"&gt;&lt;/script&gt;&lt;script src=\"bootstrap/js/bootstrap.min.js\"&gt;&lt;/script&gt; 去官网复制html的功能模块 12345678910&lt;!-- 模态框 --&gt;&lt;!-- Large modal --&gt;&lt;button type=\"button\" class=\"btn btn-primary\" data-toggle=\"modal\" data-target=\".bs-example-modal-lg\"&gt;Large modal&lt;/button&gt;&lt;div class=\"modal fade bs-example-modal-lg\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"myLargeModalLabel\"&gt; &lt;div class=\"modal-dialog modal-lg\" role=\"document\"&gt; &lt;div class=\"modal-content\"&gt; 里面就是模态框 &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 复制js代码，启动js插件。 1234567&lt;script&gt; // 当我们点击了自己定义的按钮，就弹出模态框 $(\".myBtn\").on(\"click\", function() { // alert(11); $('#btn').modal() })&lt;/script&gt; bootstrap案例-阿里百秀 1.通过调用组件实现导航栏2.通过调用插件实现登录3.通过调用插件标签页实现 tab 栏 ​ 代码实现略。(详情参考源代码) 综合案例: toDoList案例分析（代码略）案例：案例介绍1234// 1. 文本框里面输入内容，按下回车，就可以生成待办事项。// 2. 点击待办事项复选框，就可以把当前数据添加到已完成事项里面。// 3. 点击已完成事项复选框，就可以把当前数据添加到待办事项里面。// 4. 但是本页面内容刷新页面不会丢失。 案例：toDoList 分析12345// 1. 刷新页面不会丢失数据，因此需要用到本地存储 localStorage// 2. 核心思路： 不管按下回车，还是点击复选框，都是把本地存储的数据加载到页面中，这样保证刷新关闭页面不会丢失数据// 3. 存储的数据格式：var todolist = [{ title : ‘xxx’, done: false}]// 4. 注意点1： 本地存储 localStorage 里面只能存储字符串格式 ，因此需要把对象转换为字符串 JSON.stringify(data)。// 5. 注意点2： 获取本地存储数据，需要把里面的字符串转换为对象格式JSON.parse() 我们才能使用里面的数据。 案例：toDoList 按下回车把新数据添加到本地存储里面123456// 1.切记： 页面中的数据，都要从本地存储里面获取，这样刷新页面不会丢失数据，所以先要把数据保存到本地存储里面。// 2.利用事件对象.keyCode判断用户按下回车键（13）。// 3.声明一个数组，保存数据。// 4.先要读取本地存储原来的数据（声明函数 getData()），放到这个数组里面。// 5.之后把最新从表单获取过来的数据，追加到数组里面。// 6.最后把数组存储给本地存储 (声明函数 savaDate()) 案例：toDoList 本地存储数据渲染加载到页面1234// 1.因为后面也会经常渲染加载操作，所以声明一个函数 load，方便后面调用// 2.先要读取本地存储数据。（数据不要忘记转换为对象格式）// 3.之后遍历这个数据（$.each()），有几条数据，就生成几个小li 添加到 ol 里面。// 4.每次渲染之前，先把原先里面 ol 的内容清空，然后渲染加载最新的数据。 案例：toDoList 删除操作1234567// 1.点击里面的a链接，不是删除的li，而是删除本地存储对应的数据。// 2.核心原理：先获取本地存储数据，删除对应的数据，保存给本地存储，重新渲染列表li// 3.我们可以给链接自定义属性记录当前的索引号// 4.根据这个索引号删除相关的数据----数组的splice(i, 1)方法// 5.存储修改后的数据，然后存储给本地存储// 6.重新渲染加载数据列表// 7.因为a是动态创建的，我们使用on方法绑定事件 案例：toDoList 正在进行和已完成选项操作1234567// 1.当我们点击了小的复选框，修改本地存储数据，再重新渲染数据列表。// 2.点击之后，获取本地存储数据。// 3.修改对应数据属性 done 为当前复选框的checked状态。// 4.之后保存数据到本地存储// 5.重新渲染加载数据列表// 6.load 加载函数里面，新增一个条件,如果当前数据的done为true 就是已经完成的，就把列表渲染加载到 ul 里面// 7.如果当前数据的done 为false， 则是待办事项，就把列表渲染加载到 ol 里面 案例：toDoList 统计正在进行个数和已经完成个数1234// 1.在我们load 函数里面操作// 2.声明2个变量 ：todoCount 待办个数 doneCount 已完成个数 // 3.当进行遍历本地存储数据的时候， 如果 数据done为 false， 则 todoCount++, 否则 doneCount++// 4.最后修改相应的元素 text()","link":"/前端笔记/jquery-day03/"},{"title":"CSS-Day01","text":"第01阶段.前端基础.CSS初识 CSS层叠样式表 目标 理解 css的目的作用 css的三种引入方式 应用 css三种引用方式的书写 通过样式规则给标签添加简单的样式 HTML的局限性说起HTML，这其实是个非常单纯的家伙， 他只关注内容的语义， 很早的时候，世界上的网站虽然很多，但是他们都有一个共同的特点： 丑。 这个是一个外国比较早的购物网站 有些人就忍受不了了，你就不能把自己打扮得漂亮一点吗？ HTML说，我试试… 如果要改变下 高度或者变一个颜色，就需要大量重复操作 总结： HTML满足不了设计者的需求 操作html属性不方便 HTML里面添加样式带来的是无尽的臃肿和繁琐 CSS 网页的美容师 让我们的网页更加丰富多彩，布局更加灵活自如。 CSS的最大贡献就是： 让 HTML 从样式中脱离， 实现了 HTML 专注去做 结构呈现，样式交给css 我们理想中的结果： 结构(html)与样式(css)相分离 这句话要记住 而且。。。。。 CSS 做的很出色，如果JavaScript是网页的魔法师，那么CSS它是我们网页的美容师，不信，你看: CSS初识 概念： ​ CSS(Cascading Style Sheets) ，通常称为CSS样式表或层叠样式表（级联样式表） 作用： 主要用于设置 HTML页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及版面的布局和外观显示样式。 CSS以HTML为基础，提供了丰富的功能，如字体、颜色、背景的控制及整体排版等，而且还可以针对不同的浏览器设置不同的样式。 引入CSS样式表（书写位置）1要书写css样式，那css样式书写的位置在哪呢？ 行内式（内联样式） 概念： ​ 称行内样式、行间样式. ​ 是通过标签的style属性来设置元素的样式 其基本语法格式如下： 1&lt;标签名 style=\"属性1:属性值1; 属性2:属性值2; 属性3:属性值3;\"&gt; 内容 &lt;/标签名&gt; 实际上任何HTML标签都拥有style属性，用来设置行内式。 案例： 1&lt;div style=\"color: red; font-size: 12px;\"&gt;青春不常在，抓紧谈恋爱&lt;/div&gt; 注意： style其实就是标签的属性 样式属性和值中间是: 多组属性值之间用;隔开。 只能控制当前的标签和以及嵌套在其中的字标签，造成代码冗余 缺点： 没有实现样式和结构相分离 内部样式表（内嵌样式表） 概念： ​ 称内嵌式 ​ 是将CSS代码集中写在HTML文档的head头部标签中，并且用style标签定义 其基本语法格式如下： 123456789&lt;head&gt;&lt;style type=\"text/CSS\"&gt; 选择器（选择的标签） { 属性1: 属性值1; 属性2: 属性值2; 属性3: 属性值3; }&lt;/style&gt;&lt;/head&gt; 123456&lt;style&gt; div { color: red; font-size: 12px; }&lt;/style&gt; 注意： style标签一般位于head标签中，当然理论上他可以放在HTML文档的任何地方。 type=”text/css” 在html5中可以省略。 只能控制当前的页面 缺点： 没有彻底分离 综合案例1234567891011121314151617&lt;style&gt; /*选择器{属性:值；}*/ p { color:#06C; font-size:14px; } /*文字的颜色是 蓝色*/ h4 { color:#900; } h1 { color:#090; font-size:16px; } body { background:url(bg2.jpg); }&lt;/style&gt; 展示 123思考： 1. 如何实现结构与样式完全分离？ 2. 如何实现css样式共享？ 外部样式表（外链式） 概念： ​ 称链入式 ​ 是将所有的样式放在一个或多个以.CSS为扩展名的外部样式表文件中， ​ 通过link标签将外部样式表文件链接到HTML文档中 其基本语法格式如下： 123&lt;head&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"css文件路径\"&gt;&lt;/head&gt; 注意： link 是个单标签 link标签需要放在head头部标签中，并且指定link标签的三个属性 属性 作用 rel 定义当前文档与被链接文档之间的关系，在这里需要指定为“stylesheet”，表示被链接的文档是一个样式表文件。 type 定义所链接文档的类型，在这里需要指定为“text/CSS”，表示链接的外部文件为CSS样式表。我们都可以省略 href 定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径。 三种样式表总结（位置） 样式表 优点 缺点 使用情况 控制范围 行内样式表 书写方便，权重高 没有实现样式和结构相分离 较少 控制一个标签（少） 内部样式表 部分结构和样式相分离 没有彻底分离 较多 控制一个页面（中） 外部样式表 完全实现结构和样式相分离 需要引入 最多，强烈推荐 控制整个站点（多） 团队约定-代码风格样式书写一般有两种： 一种是紧凑格式 (Compact) 1h3 { color: deeppink;font-size: 20px;} 一种是展开格式（推荐） 1234h3 { color: deeppink; font-size: 20px; } 团队约定-代码大小写样式选择器，属性名，属性值关键字全部使用小写字母书写，属性字符串允许使用大小写。 123456789/* 推荐 */h3{ color: pink;} /* 不推荐 */H3{ COLOR: PINK;} 总结CSS样式规则使用HTML时，需要遵从一定的规范。CSS亦如此，要想熟练地使用CSS对网页进行修饰，首先需要了解CSS样式规则， 具体格式如下： 总结： 选择器用于指定CSS样式作用的HTML标签，花括号内是对该对象设置的具体样式。 属性和属性值以“键值对”的形式出现。 属性是对指定的对象设置的样式属性，例如字体大小、文本颜色等。 属性和属性值之间用英文“:”连接。 多个“键值对”之间用英文“;”进行区分。 @拓展阅读CSS的发展史 第01阶段.前端基础.CSS基础选择器 CSS选择器（重点） 学习目标： 理解 能说出选择器的作用 id选择器和类选择器的区别 应用 能够使用基础选择器给页面元素添加样式 CSS选择器作用（重点） 如上图所以，要把里面的小黄人分为2组，最快的方法怎办？ 很多， 比如 一只眼睛的一组，剩下的一组 选择器的作用​ 找到特定的HTML页面元素 pink老师一句话说出他们： ※※※※ *CSS选择器干啥的？ 选择标签用的， 把我们想要的标签选择出来 * 必须记住的 css 就是 分两件事， 选对人， 做对事。 123h3 { color: red;} 这段代码就是2件事， 把 h3选出来， 然后 把它变成了 红色。 以后我们都这么干。 选择器分为基础选择器和 复合选择器，我们这里先讲解一下 基础选择器。 CSS基础选择器标签选择器 概念： 标签选择器（元素选择器）是指用HTML标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的CSS样式。 语法： 1标签名{属性1:属性值1; 属性2:属性值2; 属性3:属性值3; } 作用： 标签选择器 可以把某一类标签全部选择出来 比如所有的div标签 和 所有的 span标签 优点： 是能快速为页面中同类型的标签统一样式 缺点： 不能设计差异化样式。 总结 口诀： 标签选择器， 页面同选起。 直接写标签， 全部不放弃。 1思考： 如果想要差异化选择不同的标签，怎么办呢？ 就是说 我想单独选一个或者某几个标签呢？ 类选择器类选择器使用“.”（英文点号）进行标识，后面紧跟类名. 语法： 类名选择器 12345.类名 { 属性1:属性值1; 属性2:属性值2; 属性3:属性值3; } 标签 1&lt;p class=&apos;类名&apos;&gt;&lt;/p&gt; 优点： 可以为元素对象定义单独或相同的样式。 可以选择一个或者多个标签 注意 类选择器使用“.”（英文点号）进行标识，后面紧跟类名(自定义，我们自己命名的) 长名称或词组可以使用中横线来为选择器命名。 不要纯数字、中文等命名， 尽量使用英文字母来表示。 命名规范： 见附件（Web前端开发规范手册.doc） 命名是我们通俗约定的，但是没有规定必须用这些常用的命名。 记忆口诀 差异化选择一个或多个上面点定义类名别写错谁用谁调用class来做。 嘿嘿，工作类最多。 课堂案例： 123456789101112131415161718192021222324252627282930&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;style&gt; .blue { color: blue; font-size: 100px; } .red { color: red; font-size: 100px; } .orange { color: orange; font-size: 100px; } .green { color: green; font-size: 100px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;span class=\"blue\"&gt;G&lt;/span&gt; &lt;span class=\"red\"&gt;o&lt;/span&gt; &lt;span class=\"orange\"&gt;o&lt;/span&gt; &lt;span class=\"blue\"&gt;g&lt;/span&gt; &lt;span class=\"green\"&gt;l&lt;/span&gt; &lt;span class=\"red\"&gt;e&lt;/span&gt; &lt;/body&gt; 类选择器特殊用法- 多类名我们可以给标签指定多个类名，从而达到更多的选择目的。 注意： 各个类名中间用空格隔开。 多类名选择器在后期布局比较复杂的情况下，还是较多使用的。 1234&lt;div class=\"pink fontWeight font20\"&gt;亚瑟&lt;/div&gt;&lt;div class=\"font20\"&gt;刘备&lt;/div&gt;&lt;div class=\"font14 pink\"&gt;安其拉&lt;/div&gt;&lt;div class=\"font14\"&gt;貂蝉&lt;/div&gt; id选择器id选择器使用#进行标识，后面紧跟id名 其基本语法格式如下： id选择器 1#id名 {属性1:属性值1; 属性2:属性值2; 属性3:属性值3; } 标签 1&lt;p id=&quot;id名&quot;&gt;&lt;/p&gt; 元素的id值是唯一的，只能对应于文档中某一个具体的元素。 用法基本和类选择器相同。 id选择器和类选择器区别 W3C标准规定，在同一个页面内，不允许有相同名字的id对象出现，但是允许相同名字的class。 类选择器（class） 好比人的名字， 是可以多次重复使用的， 比如 张伟 王伟 李伟 李娜 id选择器 好比人的身份证号码， 全中国是唯一的， 不得重复。 只能使用一次。 id选择器和类选择器最大的不同在于 使用次数上。 pink老师 总结他们 类选择器我们在修改样式中，用的最多。 id选择器一般用于页面唯一性的元素身上，经常和我们后面学习的javascript 搭配使用。 通配符选择器 概念 通配符选择器用*号表示， * 就是 选择所有的标签 他是所有选择器中作用范围最广的，能匹配页面中所有的元素。 其基本语法格式如下： 1* { 属性1:属性值1; 属性2:属性值2; 属性3:属性值3; } 例如下面的代码，使用通配符选择器定义CSS样式，清除所有HTML标记的默认边距。 1234* { margin: 0; /* 定义外边距*/ padding: 0; /* 定义内边距*/} 注意： 会匹配页面所有的元素，降低页面响应速度，不建议随便使用 基础选择器总结 选择器 作用 缺点 使用情况 用法 标签选择器 可以选出所有相同的标签，比如p 不能差异化选择 较多 p { color：red;} 类选择器 可以选出1个或者多个标签 可以根据需求选择 非常多 .nav { color: red; } id选择器 一次只能选择器1个标签 只能使用一次 不推荐使用 #nav {color: red;} 通配符选择器 选择所有的标签 选择的太多，有部分不需要 不推荐使用 * {color: red;} 基础选择器我们一共学了4个， 每个都有自己的价值， 可能再某个地方都能用到。但是如果说，一定要找个最常用的，那么，肯定是类选择器。 团队约定选择器 尽量少用通用选择器 * 尽量少用 ID 选择器 不使用无具体语义定义的标签选择器 div span 123456789/* 推荐 */.jdc {}li {}p{}/* 不推荐 */*{}#jdc {}div{} 因为div 没有语义，我们尽量少用 第01阶段.前端基础.CSS字体样式 CSS字体样式属性调试工具 目标 应用 使用css字体样式完成对字体的设置 使用css外观属性给页面元素添加样式 使用常用的emment语法 能够使用开发人员工具代码调试 1.font字体font-size:大小 作用： font-size属性用于设置字号 123p { font-size:20px; } 单位： 可以使用相对长度单位，也可以使用绝对长度单位。 相对长度单位比较常用，推荐使用像素单位px，绝对长度单位使用较少。 注意： 我们文字大小以后，基本就用px了，其他单位很少使用 谷歌浏览器默认的文字大小为16px 但是不同浏览器可能默认显示的字号大小不一致，我们尽量给一个明确值大小，不要默认大小。一般给body指定整个页面文字的大小 font-family:字体 作用： font-family属性用于设置哪一种字体。 1p{ font-family:&quot;微软雅黑&quot;;} 网页中常用的字体有宋体、微软雅黑、黑体等，例如将网页中所有段落文本的字体设置为微软雅黑 可以同时指定多个字体，中间以逗号隔开，表示如果浏览器不支持第一个字体，则会尝试下一个，直到找到合适的字体， 如果都没有，则以我们电脑默认的字体为准。 1p{font-family: Arial,&quot;Microsoft Yahei&quot;, &quot;微软雅黑&quot;;} 常用技巧： 12341. 各种字体之间必须使用英文状态下的逗号隔开。2. 中文字体需要加英文状态下的引号，英文字体一般不需要加引号。当需要设置英文字体时，英文字体名必须位于中文字体名之前。3. 如果字体名中包含空格、#、$等符号，则该字体必须加英文状态下的单引号或双引号，例如font-family: &quot;Times New Roman&quot;;。4. 尽量使用系统默认字体，保证在任何用户的浏览器中都能正确显示。 CSS Unicode字体 为什么使用 Unicode字体 在 CSS 中设置字体名称，直接写中文是可以的。但是在文件编码（GB2312、UTF-8 等）不匹配时会产生乱码的错误。 xp 系统不支持 类似微软雅黑的中文。 解决： 方案一： 你可以使用英文来替代。 比如font-family:&quot;Microsoft Yahei&quot;。 方案二： 在 CSS 直接使用 Unicode 编码来写字体名称可以避免这些错误。使用 Unicode 写中文字体名称，浏览器是可以正确的解析的。 1font-family: &quot;\\5FAE\\8F6F\\96C5\\9ED1&quot;; 表示设置字体为“微软雅黑”。 字体名称 英文名称 Unicode 编码 宋体 SimSun \\5B8B\\4F53 新宋体 NSimSun \\65B0\\5B8B\\4F53 黑体 SimHei \\9ED1\\4F53 微软雅黑 Microsoft YaHei \\5FAE\\8F6F\\96C5\\9ED1 楷体_GB2312 KaiTi_GB2312 \\6977\\4F53_GB2312 隶书 LiSu \\96B6\\4E66 幼园 YouYuan \\5E7C\\5706 华文细黑 STXihei \\534E\\6587\\7EC6\\9ED1 细明体 MingLiU \\7EC6\\660E\\4F53 新细明体 PMingLiU \\65B0\\7EC6\\660E\\4F53 为了照顾不同电脑的字体安装问题，我们尽量只使用宋体和微软雅黑中文字体 font-weight:字体粗细 在html中如何将字体加粗我们可以用标签来实现 使用 b 和 strong 标签是文本加粗。 可以使用CSS 来实现，但是CSS 是没有语义的。 属性值 描述 normal 默认值（不加粗的） bold 定义粗体（加粗的） 100~900 400 等同于 normal，而 700 等同于 bold 我们重点记住这句话 提倡： 我们平时更喜欢用数字来表示加粗和不加粗。 font-style:字体风格 在html中如何将字体倾斜我们可以用标签来实现 字体倾斜除了用 i 和 em 标签， 可以使用CSS 来实现，但是CSS 是没有语义的 font-style属性用于定义字体风格，如设置斜体、倾斜或正常字体，其可用属性值如下： 属性 作用 normal 默认值，浏览器会显示标准的字体样式 font-style: normal; italic 浏览器会显示斜体的字体样式。 小技巧： 1平时我们很少给文字加斜体，反而喜欢给斜体标签（em，i）改为普通模式。 font:综合设置字体样式 (重点)font属性用于对字体样式进行综合设置 基本语法格式如下： 1选择器 { font: font-style font-weight font-size/line-height font-family;} 注意： 使用font属性时，必须按上面语法格式中的顺序书写，不能更换顺序，各个属性以空格隔开。 其中不需要设置的属性可以省略（取默认值），但必须保留font-size和font-family属性，否则font属性将不起作用。 font总结 属性 表示 注意点 font-size 字号 我们通常用的单位是px 像素，一定要跟上单位 font-family 字体 实际工作中按照团队约定来写字体 font-weight 字体粗细 记住加粗是 700 或者 bold 不加粗 是 normal 或者 400 记住数字不要跟单位 font-style 字体样式 记住倾斜是 italic 不倾斜 是 normal 工作中我们最常用 normal font 字体连写 1. 字体连写是有顺序的 不能随意换位置 2. 其中字号 和 字体 必须同时出现 CSS外观属性color:文本颜色 作用： color属性用于定义文本的颜色， 其取值方式有如下3种： 表示表示 属性值 预定义的颜色值 red，green，blue，还有我们的御用色 pink 十六进制 #FF0000，#FF6600，#29D794 RGB代码 rgb(255,0,0)或rgb(100%,0%,0%) 注意 我们实际工作中， 用 16进制的写法是最多的，而且我们更喜欢简写方式比如 #f00 代表红色 text-align:文本水平对齐方式 作用： text-align属性用于设置文本内容的水平对齐，相当于html中的align对齐属性 其可用属性值如下： 属性 解释 left 左对齐（默认值） right 右对齐 center 居中对齐 注意： 是让盒子里面的内容水平居中， 而不是让盒子居中对齐 line-height:行间距 作用： line-height属性用于设置行间距，就是行与行之间的距离，即字符的垂直间距，一般称为行高。 单位： line-height常用的属性值单位有三种，分别为像素px，相对值em和百分比%，实际工作中使用最多的是像素px 技巧： 12一般情况下，行距比字号大7.8像素左右就可以了。line-height: 24px; text-indent:首行缩进 作用： text-indent属性用于设置首行文本的缩进， 属性值 其属性值可为不同单位的数值、em字符宽度的倍数、或相对于浏览器窗口宽度的百分比%，允许使用负值, 建议使用em作为设置单位。 1em 就是一个字的宽度 如果是汉字的段落， 1em 就是一个汉字的宽度 123456p { /*行间距*/ line-height: 25px; /*首行缩进2个字 em 1个em 就是1个字的大小*/ text-indent: 2em; } text-decoration 文本的装饰text-decoration 通常我们用于给链接修改装饰效果 值 描述 none 默认。定义标准的文本。 取消下划线（最常用） underline 定义文本下的一条线。下划线 也是我们链接自带的（常用） overline 定义文本上的一条线。（不用） line-through 定义穿过文本下的一条线。（不常用） CSS外观属性总结 属性 表示 注意点 color 颜色 我们通常用 十六进制 比如 而且是简写形式 #fff line-height 行高 控制行与行之间的距离 text-align 水平对齐 可以设定文字水平的对齐方式 text-indent 首行缩进 通常我们用于段落首行缩进2个字的距离 text-indent: 2em; text-decoration 文本修饰 记住 添加 下划线 underline 取消下划线 none 开发者工具（chrome）此工具是我们的必备工具，以后代码出了问题 我们首先第一反应就是： “按F12”或者是 “shift+ctrl+i” 打开 开发者工具。 菜单： 右击网页空白出—检查 通过开发人员工具小指针工具，查找页面元素 左侧是html页面结构，右侧是css样式 小技巧： ctrl+滚轮 可以 放大开发者工具代码大小。 左边是HTML元素结构 右边是CSS样式。 右边CSS样式可以改动数值和颜色查看更改后效果。 ctrl + 0 复原浏览器大小 sublime快捷操作emmet语法Emmet的前身是Zen coding,它使用缩写,来提高html/css的编写速度。 生成标签 直接输入标签名 按tab键即可 比如 div 然后tab 键， 就可以生成 如果想要生成多个相同标签 加上 * 就可以了 比如 div*3 就可以快速生成3个div 如果有父子级关系的标签，可以用 &gt; 比如 ul &gt; li就可以了 如果有兄弟关系的标签，用 + 就可以了 比如 div+p 如果生成带有类名或者id名字的， 直接写 .demo 或者 #two tab 键就可以了 如果生成的div 类名是有顺序的， 可以用 自增符号 $ 1234.demo$*3 &lt;div class=&quot;demo1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;demo2&quot;&gt;&lt;/div&gt;&lt;div class=&quot;demo3&quot;&gt;&lt;/div&gt; 综合案例 拓展阅读@emment语法","link":"/前端笔记/css-day01/"}],"tags":[{"name":"AJAX","slug":"AJAX","link":"/tags/AJAX/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"HTML5+CSS3","slug":"HTML5-CSS3","link":"/tags/HTML5-CSS3/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"布局","slug":"布局","link":"/tags/布局/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"}],"categories":[{"name":"前端笔记","slug":"前端笔记","link":"/categories/前端笔记/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"}]}